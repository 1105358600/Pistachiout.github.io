{"pages":[],"posts":[{"title":"","date":"2023-02-15T03:03:01.059Z","path":"wiki/软件项目/小型项目/程序设计说明-罗琪源-M202276666/","text":"一、需求分析​ 设计一个简单的考试系统，可进行C++与Java的考试，考生姓名、考生学号、C++题目、Java题目、C++答案，Java答案分别存入..&#x2F;txt文件数据&#x2F;路径下的StudentsName、StudentsNum、QuestionC，QuestionJ、AnswerC、AnswerJtxt文件中，进入系统后输入学号验证并进入考试，系统将自动给选择题和填空题进行对错判断并给分，最后求出选择与填空题的考试总分并存入..&#x2F;txt文件数据&#x2F;Score.txt，而简答题与编程题则写入..&#x2F;txt文件数据&#x2F;路径下的shortAnswerC.txt&#x2F;shortAnswerJ.txt与programmingC.txt &#x2F;programming.txtJ文件供老师打分。 二、逻辑流程 ​ 图1：考试系统流程图 三、考试类设计 图2：考试系统类图 ① 学生类Student学生类包括学生姓名与学号，学号用于登录系统并认证身份，学生姓名则用于记录选择题与填空题分数以及简答编程的答案。方法包括InitStudent（）初始化考生与Register（）登录考试。 ② 问题基类QandA问题基类，属性包括问题，答案与对应的分数，而方法则包括： 虚函数InitQandA（）用来初始化考题，答案以及分数，本系统只是模拟，故对于每道题初始默认为10分的分值， choice（），fillIn（），shortAnswer（），programming（）等函数表示对于考题中的选择题，填空题等题型进行处理函数，其中shortAnswer（），programming（）为虚函数。 虚函数Exam（）,采用了模板方法模式，由于对于Java与C++考试时shortAnswer（），programming（）函数有细微的差别，但算法大致的逻辑一样，故将某些步骤推迟到子类，有助于算法的扩展。 ③ C++考试类QandACC++考试类，若选择C++考试则执行该类的方法 InitQandA（）用来初始化C++考题，答案以及分数， choice（），fillIn（），shortAnswer（），programming（）等函数表示对于C++考题中的选择题，填空题等题型进行处理函数，并写入.&#x2F;txt文件数据&#x2F;路径下的Score.txt、shortAnswerC.txt与programmingC.txt文件。 Exam（）将 choice（），fillIn（），shortAnswer（），programming（）统一调用，完成C++考试，programming（）在输入为“end”时表示代码编写结束。 ④ Java考试类QandAJJava考试类，若选择Java考试则执行该类的方法 1.InitQandA（）用来初始化Java考题，答案以及分数， 2.choice（），fillIn（），shortAnswer（），programming（）等函数表示对于Java考题中的选择题，填空题等题型进行处理函数，并写入.&#x2F;txt文件数据&#x2F;路径下的Score.txt、shortAnswerJ.txt与programmingJ.txt文件。 3.Exam（）将 choice（），fillIn（），shortAnswer（），programming（）统一调用，完成Java考试，programming（）在输入为“end”时表示代码编写结束。 四、考试截图① 用户登录 为方便老师测试，学号可输入为1 ② 选择考试课目C++** ** ③ 选择考试课目为Java** ** ④ 选择题 ⑤ 填空题作答 ⑥ 简答题作答** ** ⑦ 编程题作答** ** ⑧ 分数统计** ** ⑨ 考试结束** ** ⑩ 简答题答案文件检查** ** ⑪ 编程题文件检查作答** ** 五、总结本次实验我对于系统的功能性需求已基本全部实现，如选择判断自动判分，且分数与简答编程答案计入txt文件供后续老师判分。但由于我此前的学习没有深入C++以及QT可视化等方面的知识，对于非功能性需求没有特别突出的地方，如可视化方面、数据持久化方面没有亮点，但也尽量用到了自己学习过的知识，如在设计时进行类图设计，并考虑到了设计模式如模板方法的使用，并在代码注释方面也应有尽有。此外对于编程题也有改进的空间，虽然本系统中可以进行换行，但会消耗考生做题的时间。","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:19:26.779Z","path":"wiki/软件项目/Android项目/Android图片，视频，音乐选择播放器/","text":"1、设计目的为了更加深入的了解Android开发，我最初是打算设计是建立一个相册或视频相关的多媒体的应用，但一次偶然的机会我看到了在github中一个框架，该框架中定义了许多有关图片和视频相关操作的方法，而且能够获取到手机本地的文件，而不像之前的应用需要导入到drawable中或在网上获取，于是本次课程设计我决定利用githubhttps://github.com/LuckSiege/PictureSelector的开源框架做一个能够查看手机后台存储数据的应用，这样方便的找出手机中存储在各个位置的图片音乐视频等，比如手机拍摄的图片，本地下载的视频，或者本地下载的音乐等，在选择时进行预览方便选择，类似于手机相册。 2、功能描述 预览查看手机存储的照片，视频和音频，可以通过应用找到手机中存储的各类型照片，视频和音频，包括png，jpg，jpeg等格式 单选或多选手机本地存储的照片，音频和视频，将选择的照片视频音频返回到首页显示 拍照，录像或录音，将结果返回到首页展示 在首页播放选择的照片视频和音频 3、详细设计3.1 系统业务逻辑业务逻辑流程图 3.2 系统功能模块设计 3.3 系统界面设计 首页：显示自己选择的文件。 操作选项页面，在首页点击后进入操作选择页面，可以选择是添加照片和视频还是音频，亦或者是拍照。 本地文件展示页面：将手机本地的文件（图片，视频，音频）以类似手机相册的方式显示，可以进行选择和预览 文件预览页面：点击想要选择的文件，会预览文件 4、程序实现首先由于我用了第三方的集成框架，所以首先要利用gradle导入allprojects { repositories { jcenter() maven { url ‘https://jitpack.io‘ } }}然后建立layout中的xml文件，首先首页利用RecyclerView来便于将选择的图片进行排列，在利用相对布局和imageview以及库中的layout将图片视频等展示出来。在MainActivity中，利用getviewbyid获取到layout中的ui控件，new一个GridImageAdapter来存放选择的文件，然后判断利用库中集成的函数判断存放的文件的类型，利用switch函数利用集成的不同方法来打开各自对应的文件。 而想要获取到手机本地的文件，还要申请到写的权限 然后给ui控件设计点击相应监听器，利用控件的getid判断响应事件，在每个对应的事件中利用库中的函数将手机本地的相册显示并进行相关的操作。 5.运行结果 选择相册： 左边是我的应用的界面，右边是模拟器中自带的图库的界面，可以看到该应用找到了该模拟器中包括图片的所有文件夹，也获取到了手机本地保存的所有图片和视频。 可以点击图片进行预览，也可以左右滑动选择不同的相册。 选择的图片会返回首页进行展示，在首页也能进入查看页面 当选择音频时，显示本地的所有音频，并在点击后能进行播放 在选择视频后也能进行播放和选择到首页还能够进行录视频，拍照，录音。 6、总结 本次实验我用到了github中的开源库，其中有许多没有在课堂中学过的知识，比如文件操作权限的获取，开源库的导入，对于录像，拍照，录视频等不同拍摄的实现过程。但也有一些学过的 知识获得了加深，比如layout的页面设计中如何将图片排列整齐，如何学习使用RecyclerView；在为控件添加监听事件时利用view的getid和switch来给不同的控件添加事件；利用adapter适配器来放入照片和视频等不同的文件，并在adapter中为每个图片，视频等添加各自的点击响应事件，来完成在首页选择文件的查看。 这个系统也有许多可以改进的地方，比如在导入库和进行使用时出现很多问题，其中解决了一些问题，但也有一些没有解决，如在开源库中还有可以对图片进行裁剪旋转的功能，但在使用时却会关闭应用，并且在日志中也没有显示报错信息，最后没有解决，于是只有放弃这个功能；在进行选择时无法显示文件的名字，图片可以直接看，但视频和音频则必须要打开播放才能确定文件名字。 源码地址https://github.com/1105358600/AndroidPVASelector","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:19:18.515Z","path":"wiki/软件项目/Android项目/Android 数据库编程SQLite实现学生信息管理应用/","text":"Android 数据库编程SQLite一、实验内容1. 构建应用界面布局（1）新建一个安卓工程，在默认的layout主界面中添加一个列表(ListView)，列表绑定一个SimpleAdapter关联学生信息（学号、姓名）。（2）为ListView添加上下文菜单，菜单中包含两个选项（修改学生，删除学生），分别对应学生信息的修改和删除操作。为每个选项添加点击事件完成相应的操作，其中点击修改学生时启动“updateStu”Activity组件。（3）在ListView下方添加一个按钮(Button)，内容为“添加学生”，为按钮添加点击事件，单击按钮是启动“addStu”Activity组件。（4）为“updateStu”和“addStu”Activity组件构建对应的layout界面stuinfo.xml，添加对应的文本框和输出框显示某一个学生的信息（学号、姓名、性别、电话），添加确认按钮(Button)。注意：当由“addStu”Activity启动此界面时，相关输入内容为空白，当由“updateStu”Activity启动此界面时，相关输入内容为该学生的原始信息。 2. 利用SQLite构建数据库交互组件（1）新建一个DpHelper类继承SQLiteOpenHelper，通过构建方法启动数据库连接。构建createtable()方法完成建表操作，在数据库中建立一个学生信息表：（2）构建insert(String id, String name, String sex, String phone)方法实现插入记录操作，构建 delete(String id)方法实现删除记录操作，构建update(String id, String name, String sex, String phone)方法实现更新记录操作，构建select(String id)方法实现查询某一记录操作，构建selectAll()方法实现查询所有记录操作。 3. 实现学生信息管理应用（1）完善相关代码，实现学生信息管理应用的基本功能。包括： 学生信息列表：进入应用程序后，在ListView中自动加载所有已有学生的信息（学号，姓名）。 添加学生：单击“添加学生”按钮，打开相应的界面stuinfo.xml填写新学生信息，单击“确认”按钮后完成 添加学生操作。要求程序能够识别用户输入完整性（学号、姓名为必填项），如果新学生学号与现有学生相同，应提示更换学号。添加完成后返回主界面，同时更新ListView的内容。 删除学生：根据ListView长按位置得到要删除的学生的学号信息，完成删除操作，删除后更新ListView的内容。 修改学生：根据ListView长按位置得到要修改的学生的相关信息，打开相应的界面stuinfo.xml，将学生原始信息自动填入对应的输入框中，点击确认按钮后完成更新学生信息操作。要求程序能够识别用户输入完整性（学号、姓名为必填项），如果新学生学号与现有学生相同，应提示更换学号。修改完成后返回主界面，同时更新ListView的内容。 （2）测试相关功能，添加若干条学生信息（3条以上），再进行信息修改、删除操作的测试。 二：演示截图数据库：没有填入数据时，显示学生，姓名，性别，手机： 插入学生数据： 插入数据后： 单击某行进行学生信息修改： 长按提示是否删除，确认后删除： 如果添加的学号重复：提示学号重复 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;@dimen/item_no_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;@string/no&quot;/&gt; &lt;TextView android:layout_width=&quot;@dimen/item_name_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;@string/name&quot;/&gt; &lt;TextView android:layout_width=&quot;@dimen/item_name_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;性别:&quot;/&gt; &lt;TextView android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;@string/phone&quot;/&gt; &lt;/LinearLayout&gt; &lt;ListView android:id=&quot;@+id/lv_contact&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;/ListView&gt; &lt;Button android:id=&quot;@+id/btn_add&quot; android:layout_width=&quot;411dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom&quot; android:layout_marginTop=&quot;@dimen/margin_fix&quot; android:background=&quot;@color/btn_blue&quot; android:text=&quot;@string/add&quot; android:textSize=&quot;@dimen/btn_add_size&quot; /&gt;&lt;/LinearLayout&gt; 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;@dimen/item_no_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:id=&quot;@+id/contact_no&quot; android:textSize=&quot;@dimen/item_font_size&quot;/&gt; &lt;TextView android:layout_width=&quot;@dimen/item_name_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:id=&quot;@+id/contact_name&quot; android:textSize=&quot;@dimen/item_font_size&quot;/&gt; &lt;TextView android:id=&quot;@+id/contact_sex&quot; android:layout_width=&quot;90dp&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; /&gt; &lt;TextView android:id=&quot;@+id/contact_phonenumber&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; /&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.wsine.west.exp7.DetailActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:id=&quot;@+id/detail_title&quot; android:textSize=&quot;@dimen/title_size&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/no&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_no&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/name&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_name&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;性别:&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_sex&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/phone&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_phone&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;@dimen/margin_fix&quot; android:layout_gravity=&quot;center&quot; android:id=&quot;@+id/btn_confirm&quot; android:textSize=&quot;@dimen/btn_add_size&quot; android:text=&quot;@string/confirm&quot; android:background=&quot;@color/btn_blue&quot;/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.wsine.west.exp7;/** * Created by West on 2015/11/25. */public class Contact &#123; private int id; private String no; private String sex; private String name; private String phoneNumber; public Contact(String no, String name, String sex, String phoneNumber) &#123; this.no = no; this.sex = sex; this.name = name; this.phoneNumber = phoneNumber; &#125; public Contact(int id, String no, String name, String sex, String phoneNumber) &#123; this.id = id; this.no = no; this.sex = sex; this.name = name; this.phoneNumber = phoneNumber; &#125; public Contact() &#123;&#125; public Contact(String _name, String _phoneNumber) &#123; this.name = _name; this.phoneNumber = _phoneNumber; &#125; public Contact(String _no, String _name, String _phoneNumber) &#123; this.no = _no; this.name = _name; this.phoneNumber = _phoneNumber; &#125; public String getNo() &#123; return no; &#125; public void setNo(String _no) &#123; this.no = _no; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String _name) &#123; this.name = _name; &#125; public String getPhoneNumber() &#123; return phoneNumber; &#125; public void setPhoneNumber(String _phoneNumber) &#123; this.phoneNumber = _phoneNumber; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.wsine.west.exp7;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.SimpleAdapter;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * Created by West on 2015/11/25. */public class MySimpleAdapter extends SimpleAdapter &#123; private ArrayList&lt;Map&lt;String, String&gt;&gt; mData; public ArrayList&lt;Map&lt;String, String&gt;&gt; getmData() &#123; return mData; &#125; public MySimpleAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, int resource, String[] from, int[] to) &#123; super(context, data, resource, from, to); this.mData = (ArrayList&lt;Map&lt;String, String&gt;&gt;)data; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; final int mPosition = position; return super.getView(position, convertView, parent); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.wsine.west.exp7;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import android.widget.Toast;import static android.widget.Toast.LENGTH_SHORT;/** * Created by West on 2015/11/25. */public class MyDatabaseHelper extends SQLiteOpenHelper &#123; private static final String DB_NAME = &quot;Contacts.db&quot;; private static final String TABLE_NAME = &quot;Contacts&quot;; private static final int DB_VERSION = 1; public MyDatabaseHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; String CREATE_TABLE = &quot;create table &quot; + TABLE_NAME + &quot; (_id integer primary key autoincrement, &quot; + &quot;_no text not null, &quot; + &quot;_name text not null, &quot; + &quot;_sex text,&quot; + &quot;_pnumber text);&quot;; db.execSQL(CREATE_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; String DROP_TABLE = &quot;DROP TABLE IF exists &quot; + TABLE_NAME; db.execSQL(DROP_TABLE); onCreate(db); &#125; public long insert(Contact entity) &#123; SQLiteDatabase db = getWritableDatabase(); ContentValues values = new ContentValues(); values.put(&quot;_no&quot;, entity.getNo()); values.put(&quot;_name&quot;, entity.getName()); values.put(&quot;_sex&quot;, entity.getSex()); values.put(&quot;_pnumber&quot;, entity.getPhoneNumber()); long id = db.insert(TABLE_NAME, null, values); db.close(); return id; &#125; public int update(Contact entity,String oldNo) &#123; SQLiteDatabase db = getWritableDatabase(); String whereClause = &quot;_no = ?&quot;; String[] whereArgs = &#123; oldNo&#125;; ContentValues values = new ContentValues(); values.put(&quot;_no&quot;, entity.getNo()); values.put(&quot;_name&quot;, entity.getName()); values.put(&quot;_sex&quot;, entity.getSex()); values.put(&quot;_pnumber&quot;, entity.getPhoneNumber()); int rows = db.update(TABLE_NAME, values, whereClause, whereArgs); db.close(); return rows; &#125; public int delete(Contact entity) &#123; SQLiteDatabase db = getWritableDatabase(); String whereClause = &quot;_no = ?&quot;; String[] whereArgs = &#123; entity.getNo() &#125;; int rows = db.delete(TABLE_NAME, whereClause, whereArgs); db.close(); return rows; &#125; public Cursor query() &#123; SQLiteDatabase db = getReadableDatabase(); return db.query(TABLE_NAME, null, null, null, null, null, null); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196package com.wsine.west.exp7;import android.app.AlertDialog;import android.content.DialogInterface;import android.content.Intent;import android.database.Cursor;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.AdapterView;import android.widget.Button;import android.widget.ListView;import android.widget.Toast;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.List;import java.util.Map;public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper myDatabaseHelper = new MyDatabaseHelper(MainActivity.this); private List&lt;Map&lt;String, String&gt;&gt; dataList = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MySimpleAdapter mySimpleAdapter=updateListView(); final ArrayList&lt;Map&lt;String, String&gt;&gt; mData=mySimpleAdapter.getmData(); Button btnAdd = (Button)this.findViewById(R.id.btn_add); btnAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(MainActivity.this, DetailActivity.class); Bundle bundle = new Bundle(); int i=-1; for (Map&lt;String, String&gt; m : mData)&#123; i++; Collection&lt;String&gt; valueCollection = m.values(); final int size = valueCollection.size(); List&lt;String&gt; valueList = new ArrayList&lt;String&gt;(valueCollection); String[] valueArray = new String[size]; m.values().toArray(valueArray); bundle.putString(&quot;No&quot;+i, valueArray[3]); &#125; bundle.putBoolean(&quot;AddorNot&quot;, true); intent.putExtras(bundle); int requestCode = 1; startActivityForResult(intent, requestCode); &#125; &#125;); ListView lv = (ListView)this.findViewById(R.id.lv_contact); lv.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; ListView listView = (ListView) parent; HashMap&lt;String, String&gt; map = (HashMap&lt;String, String&gt;)listView.getItemAtPosition(position); Intent intent = new Intent(MainActivity.this, DetailActivity.class); Bundle bundle = new Bundle(); bundle.putBoolean(&quot;AddorNot&quot;, false); int i=-1; for (Map&lt;String, String&gt; m : mData)&#123; i++; Collection&lt;String&gt; valueCollection = m.values(); final int size = valueCollection.size(); List&lt;String&gt; valueList = new ArrayList&lt;String&gt;(valueCollection); String[] valueArray = new String[size]; m.values().toArray(valueArray); bundle.putString(&quot;No&quot;+i, valueArray[3]); &#125; bundle.putString(&quot;oldNo&quot;, map.get(&quot;no&quot;)); bundle.putString(&quot;oldName&quot;, map.get(&quot;name&quot;)); bundle.putString(&quot;oldSex&quot;, map.get(&quot;sex&quot;)); bundle.putString(&quot;oldPNumber&quot;, map.get(&quot;pnumber&quot;)); intent.putExtras(bundle); int requestCode = 2; startActivityForResult(intent, requestCode); &#125; &#125;); lv.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() &#123; @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; ListView listView = (ListView) parent; final HashMap&lt;String, String&gt; map = (HashMap&lt;String, String&gt;)listView.getItemAtPosition(position); AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setMessage(&quot;确认删除吗？&quot;); builder.setTitle(&quot;提示&quot;); builder.setPositiveButton(&quot;确认&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; try &#123; myDatabaseHelper.delete(new Contact(map.get(&quot;no&quot;), map.get(&quot;name&quot;), map.get(&quot;sex&quot;),map.get(&quot;pnumber&quot;))); updateListView(); &#125; catch (Exception e) &#123; Log.d(&quot;Hint&quot;, &quot;Remove failed!&quot;); &#125; &#125; &#125;); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; // nothing to do &#125; &#125;); builder.show(); return true; &#125; &#125;); &#125; private void setData(List&lt;Map&lt;String, String&gt;&gt; mDataList) &#123; Map&lt;String, String&gt; mData; Cursor c = myDatabaseHelper.query(); while (c.moveToNext()) &#123; mData = new HashMap&lt;String, String&gt;(); mData.put(&quot;no&quot;, c.getString(c.getColumnIndex(&quot;_no&quot;))); mData.put(&quot;name&quot;, c.getString(c.getColumnIndex(&quot;_name&quot;))); mData.put(&quot;sex&quot;, c.getString(c.getColumnIndex(&quot;_sex&quot;))); mData.put(&quot;pnumber&quot;, c.getString(c.getColumnIndex(&quot;_pnumber&quot;))); mDataList.add(mData); &#125; &#125; private MySimpleAdapter updateListView() &#123; dataList.clear(); setData(dataList); MySimpleAdapter mySimpleAdapter = new MySimpleAdapter(this, dataList, R.layout.contact_item, new String[] &#123; &quot;no&quot;, &quot;name&quot;,&quot;sex&quot;, &quot;pnumber&quot; &#125;, new int[] &#123; R.id.contact_no, R.id.contact_name,R.id.contact_sex, R.id.contact_phonenumber &#125;); ListView lv = (ListView)this.findViewById(R.id.lv_contact); lv.setAdapter(mySimpleAdapter); return mySimpleAdapter; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; Log.d(&quot;Hint&quot;, &quot;requestCode = &quot; + requestCode); Log.d(&quot;Hint&quot;, &quot;resultCode = &quot; + resultCode); if (resultCode == 0) return; String oldNo= data.getStringExtra(&quot;_oldNo&quot;); String newNo = data.getStringExtra(&quot;_newNo&quot;); String newName = data.getStringExtra(&quot;_newName&quot;); String newSex = data.getStringExtra(&quot;_newSex&quot;); String newPNumber = data.getStringExtra(&quot;_newPNumber&quot;); switch (requestCode) &#123; case 1: myDatabaseHelper.insert(new Contact(newNo, newName,newSex, newPNumber)); break; case 2: int i=myDatabaseHelper.update(new Contact(newNo, newName,newSex, newPNumber),oldNo); Toast.makeText(this,&quot;&quot;+i+&quot;个修改成功&quot;, Toast.LENGTH_SHORT).show(); break; default: break; &#125; updateListView(); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.wsine.west.exp7;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.KeyEvent;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;public class DetailActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.stu_info); TextView tvTitle = (TextView)this.findViewById(R.id.detail_title); final EditText edtNo = (EditText)this.findViewById(R.id.Et_no); final EditText edtName = (EditText)this.findViewById(R.id.Et_name); final EditText edtSex = (EditText)this.findViewById(R.id.Et_sex); final EditText edtPNumber = (EditText)this.findViewById(R.id.Et_phone); final Bundle bundle = getIntent().getExtras(); final boolean addOrNot = bundle.getBoolean(&quot;AddorNot&quot;); final int[] data=bundle.getIntArray(&quot;data&quot;); if (addOrNot) &#123; tvTitle.setText(getResources().getString(R.string.titleAdd)); edtNo.setText(&quot;&quot;); edtName.setText(&quot;&quot;); edtSex.setText(&quot;&quot;); edtPNumber.setText(&quot;&quot;); &#125; else &#123; tvTitle.setText(getResources().getString(R.string.titleModify)); edtNo.setText(bundle.getString(&quot;oldNo&quot;)); edtName.setText(bundle.getString(&quot;oldName&quot;)); edtSex.setText(bundle.getString(&quot;oldSex&quot;)); edtPNumber.setText(bundle.getString(&quot;oldPNumber&quot;)); &#125; Button btnConfirm = (Button)this.findViewById(R.id.btn_confirm); btnConfirm.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String newNo = edtNo.getText().toString(); String newName = edtName.getText().toString(); String newSex = edtSex.getText().toString(); String newPNumber = edtPNumber.getText().toString(); Intent intent = new Intent(); intent.putExtra(&quot;_oldNo&quot;,bundle.getString(&quot;oldNo&quot;)); intent.putExtra(&quot;_newNo&quot;, newNo); intent.putExtra(&quot;_newName&quot;, newName); intent.putExtra(&quot;_newSex&quot;, newSex); intent.putExtra(&quot;_newPNumber&quot;, newPNumber); for(int i=0;bundle.getString(&quot;No&quot;+i)!=null;i++) &#123; System.out.println(&quot;第&quot;+i+&quot;行&quot;); System.out.println(bundle.getString(&quot;No&quot;+i)); System.out.println(newNo); if (newNo.isEmpty() || newPNumber.isEmpty() || newName.isEmpty()) &#123; Toast.makeText(getApplicationContext(), getResources().getString(R.string.msgWarning),Toast.LENGTH_SHORT).show(); return; &#125; else if(newNo.equals(bundle.getString(&quot;No&quot;+i))&amp;&amp;!newNo.equals(bundle.getString(&quot;oldNo&quot;))) &#123; Toast.makeText(getApplicationContext(), getResources().getString(R.string.msgWarning2),Toast.LENGTH_SHORT).show(); return; &#125; &#125; int resultCode = 0; if (addOrNot) resultCode = 1; else resultCode = 2; DetailActivity.this.setResult(resultCode, intent); DetailActivity.this.finish(); &#125; &#125;); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if(keyCode == KeyEvent.KEYCODE_BACK) &#123; int resultCode = 0; DetailActivity.this.setResult(resultCode); DetailActivity.this.finish(); &#125; return true; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_detail, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 123456789101112131415161718192021&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Exp7&lt;/string&gt; &lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt; &lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt; &lt;string name=&quot;title_activity_detail&quot;&gt;DetailActivity&lt;/string&gt; &lt;string name=&quot;add&quot;&gt;Add&lt;/string&gt; &lt;string name=&quot;no&quot;&gt;学号:&lt;/string&gt; &lt;string name=&quot;name&quot;&gt;姓名:&lt;/string&gt; &lt;string name=&quot;phone&quot;&gt;手机:&lt;/string&gt; &lt;string name=&quot;confirm&quot;&gt;确定&lt;/string&gt; &lt;string name=&quot;titleAdd&quot;&gt;添加联系人&lt;/string&gt; &lt;string name=&quot;titleModify&quot;&gt;修改联系人&lt;/string&gt; &lt;string name=&quot;msgWarning&quot;&gt;您输入的内容为空&lt;/string&gt; &lt;string name=&quot;msgWarning2&quot;&gt;你输入的学号重复&lt;/string&gt;&lt;/resources&gt; 源码下载：https://download.csdn.net/download/qq_45808700&#x2F;19525532","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:19:11.860Z","path":"wiki/软件项目/Android项目/Android多线程与异步操作实现图片自动轮播/","text":"一、实验内容1.利用Thread和Handler实现异步操作；2.利用AsyncTast实现异步操作； 1. 利用Thread和Handler实现异步操作（1）新建一个安卓工程，在默认的layout主界面中添加一个按钮(Button)，一个图片显示控件（ImageView）。（2）将实验四资源中的所有图片导入到工程的drawable目录下。（3）参考下面的代码构建图片资源列表和计数器变量。（4）为按钮添加点击事件，当点击按钮时，启动一个新线程(传入一个handler)，并每隔100毫秒发送一条空信息，信息的what标识为0x123。（5）定义一个handler用于接受线程的信息，并在handleMessage方法中处理信息，参考下列代码循环更新ImageView中的内容，实现动画效果。（6）测试上述功能。 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginTop=&quot;200dp&quot; android:text=&quot;Button&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;300px&quot; android:layout_height=&quot;300px&quot; android:scaleType=&quot;fitXY&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789package com.example.myapplication8;public class images &#123; public final static int imgids[]=new int[]&#123;//图片资源列表 R.drawable.p1,R.drawable.p2,R.drawable.p3,R.drawable.p4, R.drawable.p5,R.drawable.p6,R.drawable.p7 &#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.myapplication8;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import androidx.annotation.NonNull;import androidx.viewpager.widget.PagerAdapter;public class ViewPagerAdapter extends PagerAdapter &#123; private Context context; private LayoutInflater layoutInflater; private int[] datas; public ViewPagerAdapter(Context context,int[] datas) &#123; this.context=context; this.datas=datas; layoutInflater=LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return datas.length; &#125; @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123; return view==object; &#125; @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; container.removeView((View) object); &#125; @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) &#123; View layout=layoutInflater.inflate(R.layout.viewpager_item,null); ImageView iv= layout.findViewById(R.id.imageView); iv.setImageResource(datas[position]); container.addView(layout); return layout; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.example.myapplication8;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager.widget.ViewPager;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.ImageView;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class MainActivity extends AppCompatActivity &#123; private int[] imgids= com.example.myapplication8.images.imgids; private ImageView imageView; public Button btn; int imgstart=0; private ScheduledExecutorService scheduledExecutorService; private Handler handler =new Handler() &#123; @Override public void handleMessage(@NonNull Message msg) &#123; switch (msg.what) &#123; case 0x123: imageView.setImageResource(imgids[imgstart++%7]); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView=findViewById(R.id.imageView1); &#125; @Override protected void onStart() &#123; super.onStart(); btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; handler.sendEmptyMessage(0x123); &#125; &#125;, 0, 100, TimeUnit.MILLISECONDS); &#125; &#125;); &#125; @Override protected void onStop() &#123; super.onStop(); if (scheduledExecutorService != null) &#123; scheduledExecutorService.shutdown(); &#125; &#125;&#125; 实现过程即通过 scheduledExecutorService的scheduleAtFixedRate（）来利用hander的sendEmptyMessage（）方法传递what标识符，然后在handleMessage（）中switch判断标识符，并修改imageView的图片。 2. 利用AsyncTast实现异步操作（1）新建另一个安卓工程，在默认的layout主界面中添加一个按钮(Button)，一个图片显示控件（ImageView）。（2）参考课堂教授的方法，使用AsyncTast实现类似的动画效果。（3）测试上述功能，比较两种方法在代码构造上的优劣。 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginTop=&quot;200dp&quot; android:text=&quot;Button&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.AsyncTask;import android.os.Bundle;import android.text.PrecomputedText;import android.view.View;import android.widget.Button;import android.widget.ImageView;public class MainActivity extends AppCompatActivity &#123; private int[] imgids= &#123;//图片资源列表 R.drawable.p1,R.drawable.p2,R.drawable.p3,R.drawable.p4, R.drawable.p5,R.drawable.p6,R.drawable.p7 &#125;;; private ImageView imageView; public Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView=findViewById(R.id.imageView1); btn=findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Task task=new Task(); task.execute(); &#125; &#125;); &#125; class Task extends AsyncTask&lt;Void,Integer,Boolean&gt; &#123; int imgstart; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Boolean doInBackground(Void... params)&#123; try &#123; while(true) &#123; Thread.sleep(100); imgstart++; imgstart=imgstart%7; publishProgress(imgstart); if(imgstart==8) &#123; break; &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); imageView.setImageResource(imgids[values[0]]); &#125; @Override protected void onPostExecute(Boolean bollean) &#123; super.onPostExecute(bollean); &#125; &#125;&#125; 四： 实验总结：在本实验中，我对多线程与异步操作的实现有了基本了解，并知道了2种线程的实现方法，即利用handle与 scheduledExecutorService和继承AsyncTask的方法，我认为这两种方法都比较好用，但AsyncTask虽然结构比较清晰，但要注意参数配置，还必须在onProgressUpdate（）中才能对Android的UI进行更新，容易出错，而handle利用时虽然代码比较复杂，但实验实现时不易出错。","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:19:05.364Z","path":"wiki/软件项目/Android项目/Android使用Service组件实现简单的音乐播放器/","text":"一、实验内容 构建应用界面布局（1）新建一个安卓工程，在默认的layout界面中添加一个按钮(button)，如下图所示：2）构建相应的java代码，添加按钮的响应事件，跳转至另一个界面musicplayer.xml，对应的activity名称为musicPlayer.java，在其界面中添加三个imagebutton，分别对应播放器的播放、退出（后台播放）、退出（停止播放）操作，如下图所示： 构建Service组件（1）新建一个MusicService类继承Service，通过重写onStartCommand()、onDestroy()方法实现对MediaPlayer播放器的控制。 实现简单的音乐播放器（1）完善musicPlayer.java中的代码，通过startService方法启动MusicService。并实现各个按钮的功能。其中：播放按钮：点击按钮开始播放音乐（播放固定音乐文件for-love.mp3，请事先将文件导入到项目的asset或者raw目录内），再次点击按钮暂停播放。退出（后台播放）：点击按钮退出musicplayer界面（回到初始界面），但此时后台仍在播放音乐。退出（停止播放）：点击按钮退出musicplayer界面（回到初始界面），同时停止播放音乐。 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/start&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;19dp&quot; android:layout_marginLeft=&quot;19dp&quot; android:layout_marginTop=&quot;23dp&quot; android:text=&quot;打开播放器&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.musicplayer&quot;&gt; &lt;ImageButton android:id=&quot;@+id/btn_play&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;4dp&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;16dp&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:srcCompat=&quot;@android:drawable/ic_media_play&quot; /&gt; &lt;ImageButton android:id=&quot;@+id/btn_return&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintStart_toEndOf=&quot;@+id/btn_play&quot; app:layout_constraintTop_toTopOf=&quot;@+id/btn_play&quot; app:srcCompat=&quot;@android:drawable/ic_menu_revert&quot; /&gt; &lt;ImageButton android:id=&quot;@+id/btn_stop&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;10dp&quot; android:layout_marginLeft=&quot;10dp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/btn_return&quot; app:layout_constraintStart_toEndOf=&quot;@+id/btn_return&quot; app:srcCompat=&quot;@android:drawable/ic_lock_power_off&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425package com.example.myapplication7;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button bt = findViewById(R.id.start); bt.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent =new Intent(MainActivity.this,musicplayer.class); startActivity(intent); &#125; &#125;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example.myapplication7;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.ImageButton;import android.widget.Toast;public class musicplayer extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.musicplayer); final Intent intent =new Intent(musicplayer.this,MusicService.class); ImageButton btn_play=(ImageButton) findViewById(R.id.btn_play); btn_play.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if( MusicService.isplay==false) &#123;startService(intent); Toast.makeText(getApplicationContext(), &quot;正在播放&quot;, Toast.LENGTH_LONG).show(); &#125; else &#123;stopService(intent); Toast.makeText(getApplicationContext(), &quot;暂停播放&quot;, Toast.LENGTH_LONG).show();&#125; &#125;&#125;); ImageButton btn_return=(ImageButton) findViewById(R.id.btn_return); btn_return.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if( MusicService.isplay==true) &#123; Intent intent2 = new Intent( musicplayer.this,MainActivity.class); startActivity(intent2); Toast.makeText(getApplicationContext(), &quot;正在播放&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;&#125;); ImageButton btn_stop=(ImageButton) findViewById(R.id.btn_stop); btn_stop.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if( MusicService.isplay==true) &#123;stopService(intent); Intent intent1 = new Intent( musicplayer.this,MainActivity.class); startActivity(intent1); Toast.makeText(getApplicationContext(), &quot;停止播放&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;&#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.myapplication7;import android.app.Service;import android.content.Intent;import android.media.MediaPlayer;import android.os.IBinder;public class MusicService extends Service &#123; static boolean isplay; MediaPlayer player; public MusicService() &#123; &#125; @Override public void onCreate() &#123; player = MediaPlayer.create(this,R.raw.for_love); super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if(!player.isPlaying()) &#123;player.start(); isplay=player.isPlaying(); &#125; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; player.stop(); isplay=player.isPlaying(); player.release(); super.onDestroy(); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125;&#125; MusicService：通过重写OnCreate（），onDestroy(),onStartCommand()实现后台service的music播放 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapplication7&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.MyApplication7&quot;&gt; &lt;service android:name=&quot;.MusicService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/service&gt; &lt;activity android:name=&quot;.musicplayer&quot; /&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:18:58.555Z","path":"wiki/软件项目/Android项目/Android UI控件的使用/","text":"Android UI控件的使用一、实验目的1.掌握Android基本布局的使用方法；2.掌握常用Android UI控件的使用方法；3.创建相应的Android应用程序实现各类控件的功能； 二、实验要求1.掌握线性布局(Linearlayout)和相对布局(Relativelayout)的使用方法；2.掌握文本框（TextView）、按钮（Button）、EditText（可编辑文本）和CheckBox（复选框）控件的使用方法；3.掌握下拉列表（Spinner）控件的使用方法；4.掌握列表（ListView）控件的使用方法；5.掌握进度条（ProgressBar）控件的使用方法；6.掌握缩放按钮（ZoomButton&amp;ZoomControl）控件的使用方法；7.独立完成实验内容，完成实验报告。 三、实验内容1. 掌握线性布局(linearlayout)和相对布局(relativelayout)的使用方法（1）新建一个安卓工程，在默认的layout界面中设置布局为线性布局水平，在布局中添加5个按钮控件和一个线性布局垂直控件，其布局如下图所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:showDividers=&quot;middle&quot; android:dividerPadding=&quot;10dp&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;2&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;2&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;2&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;3&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）其中水平线性布局中的两个按钮和垂直线性布局的高度比例为：1:1:2，垂直线性布局内三个按钮的宽度比例为：2:2:3。（3）新建一个相对布局界面，在其中添加5个ImageView控件，使用相对布局属性使其形成如下图所示的梅花型图案（其中中间控件位于界面居中位置），各个控件所使用的图片资源见实验资源文件，需要先导入到工程项目的drawable中再使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity2&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_marginEnd=&quot;56dp&quot; android:layout_marginRight=&quot;56dp&quot; android:layout_marginBottom=&quot;100dp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@+id/imageView7&quot; app:layout_constraintTop_toTopOf=&quot;@+id/imageView2&quot; app:srcCompat=&quot;@drawable/child&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginTop=&quot;187dp&quot; android:layout_marginEnd=&quot;100dp&quot; android:layout_marginRight=&quot;100dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/imageView7&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/imageView&quot; app:layout_constraintStart_toStartOf=&quot;@+id/imageView4&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:srcCompat=&quot;@drawable/arancia_fruit&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView3&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginEnd=&quot;100dp&quot; android:layout_marginRight=&quot;100dp&quot; android:layout_marginBottom=&quot;244dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/imageView&quot; app:layout_constraintStart_toStartOf=&quot;@+id/imageView4&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView7&quot; app:srcCompat=&quot;@drawable/dress2&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginStart=&quot;55dp&quot; android:layout_marginLeft=&quot;55dp&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_marginBottom=&quot;100dp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/imageView7&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/imageView2&quot; app:srcCompat=&quot;@drawable/fitness_ball&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_centerInParent=&quot;true&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/imageView3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/imageView&quot; app:layout_constraintStart_toEndOf=&quot;@+id/imageView4&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView2&quot; app:srcCompat=&quot;@android:mipmap/sym_def_app_icon&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 2. 掌握文本框（TextView）、按钮（Button）、EditText（可编辑文本）和CheckBox（复选框）控件的使用方法（1）新建一个安卓工程，在默认的layout界面中分别添加一个文本框（TextView）、按钮（Button）和EditText（可编辑文本）控件。（2）TextView包含了一段提示文字，作为另一个控件的搭配说明，Button则是相应点击事件，可以将Button理解为可以点击的TextView，而EditText则用于接受用户的输入。（3）程序初始化时给TextView设置默认值，在按钮被点击后会出现的响应，使得文本框内容发生改变（改变后的内容将包含在EditText中输入的信息）。（4）请编写代码实现：点击提交按钮后，打开一个新的界面，并在其中显示输入的信息。（5）在新的界面中再添加一个CheckBox（复选框）控件（复选框应有3个以上可选择项，内容不限）和一个Button（按钮）控件。请编写代码实现：当点击按钮时，关闭当前界面并将复选框选择的内容信息返回至第一个界面并显示。 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginBottom=&quot;18dp&quot; android:text=&quot;选择内容&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/button&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;4dp&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;93dp&quot; android:text=&quot;复选框页面&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity2&quot;&gt; &lt;Button android:id=&quot;@+id/but&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;57dp&quot; android:layout_marginLeft=&quot;57dp&quot; android:layout_marginTop=&quot;42dp&quot; android:text=&quot;返回&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/checkBox3&quot; /&gt; &lt;CheckBox android:id=&quot;@+id/checkBox1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:text=&quot;高兴&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/checkBox2&quot; app:layout_constraintStart_toStartOf=&quot;@+id/checkBox2&quot; /&gt; &lt;CheckBox android:id=&quot;@+id/checkBox2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;68dp&quot; android:layout_marginLeft=&quot;68dp&quot; android:layout_marginTop=&quot;205dp&quot; android:text=&quot;伤心&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;CheckBox android:id=&quot;@+id/checkBox3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;46dp&quot; android:text=&quot;平静&quot; app:layout_constraintStart_toStartOf=&quot;@+id/checkBox2&quot; app:layout_constraintTop_toTopOf=&quot;@+id/checkBox2&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.myapplication;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this,MainActivity2.class); startActivityForResult(intent,0x11); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); TextView textView=(TextView) findViewById(R.id.textView2); if (requestCode==0x11 &amp;&amp; resultCode==0x11)&#123; Bundle bundle =data.getExtras(); String string= bundle.getString(&quot;check&quot;); textView.setText(string); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.List;public class MainActivity2 extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Button button = (Button) findViewById(R.id.but); // 初始化控件 CheckBox checkBox1, checkBox2, checkBox3; List&lt;CheckBox&gt; checkBoxList = new ArrayList&lt;CheckBox&gt;(); checkBox1 = (CheckBox) findViewById(R.id.checkBox1); checkBox2 = (CheckBox) findViewById(R.id.checkBox2); checkBox3 = (CheckBox) findViewById(R.id.checkBox3); // 将所有的checkbox放到一个集合中 checkBoxList.add(checkBox1); checkBoxList.add(checkBox2); checkBoxList.add(checkBox3); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = getIntent(); Bundle bundle = new Bundle(); StringBuffer sb = new StringBuffer(); //遍历集合中的checkBox,判断是否选择，获取选中的文本 for (CheckBox checkbox : checkBoxList) &#123; if (checkbox.isChecked())&#123; sb.append(checkbox.getText().toString() + &quot; &quot;); &#125; &#125; String s = sb.toString(); if (sb!=null &amp;&amp; &quot;&quot;.equals(sb.toString()))&#123; Toast.makeText(getApplicationContext(), &quot;请至少选择一个&quot;, Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(getApplicationContext(), sb.toString(), Toast.LENGTH_SHORT).show(); &#125; bundle.putCharSequence(&quot;check&quot;,s); intent.putExtras(bundle); setResult(0x11,intent); finish(); &#125; &#125;); &#125;&#125; 3. 掌握下拉列表（Spinner）控件的使用方法（1）ArrayAdapter可称为数组适配器，是Spinner和ListView中最简单的一种适配器，它将一个数组和列表控件之间建立连接，可以将数组里定义的内容一一对应的显示在列表中。（2）新建一个安卓工程，在默认的layout界面中添加两个文本框（TextView）控件，一个用于显示提示信息“请选择：”，另一个用于显示下拉列表选择的结果信息。添加一个下拉列表（Spinner）控件。（3）在工程项目res&#x2F;values下的string.xml中添加一个stringarray,名称为citys，内容为城市列表信息，如下： （4）使用下列代码实现下拉列表功能。程序初始化时，为下拉列表定义一个适配器ArrayAdapter，为下拉列表赋值，列表选项从citys中获取。下拉列表从适配器中读取值，调用下拉列表赋值、响应函数。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;39dp&quot; android:text=&quot;TextView&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/textView2&quot; app:layout_constraintStart_toStartOf=&quot;@+id/textView2&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;61dp&quot; android:layout_marginLeft=&quot;61dp&quot; android:layout_marginBottom=&quot;40dp&quot; android:text=&quot;TextView&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/spinner&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Spinner android:id=&quot;@+id/spinner&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;168dp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 1234567891011&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;My Application3&lt;/string&gt; &lt;string-array name=&quot;cities&quot;&gt; &lt;item&gt;--请选择--&lt;/item&gt; &lt;item&gt;北京&lt;/item&gt; &lt;item&gt;上海&lt;/item&gt; &lt;item&gt;成都&lt;/item&gt; &lt;item&gt;南京&lt;/item&gt; &lt;item&gt;香港&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.myapplication3;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Spinner;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; TextView tv1; TextView tv2; Spinner sp; View.OnClickListener ocl = null; ArrayAdapter&lt;CharSequence&gt; adapter; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; //class super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv1 = (TextView)findViewById(R.id.textView); tv2 = (TextView)findViewById(R.id.textView2); sp = (Spinner)findViewById(R.id.spinner); tv1.setText(&quot;请选择&quot;); sp.setPrompt(&quot;选择项&quot;);//为列表项设置标题 spinner_set();//调用下拉列表赋值、响应函数 &#125; private void spinner_set()&#123; //将下拉列表的值先传给适配器 adapter = ArrayAdapter.createFromResource(this, R.array.cities, android.R.layout.simple_spinner_item); //适配器获得值 adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); //下拉列表从适配器中读取值 sp.setAdapter(adapter); //下拉列表选定值后响应 sp.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub if(arg2 != 0)&#123; tv2.setText(&quot;您选择的是：&quot; + adapter.getItem(arg2)); &#125; else&#123; tv2.setText(&quot;您还没有选择!&quot;); &#125; &#125; public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub tv2.setText(&quot;您还没有选择!&quot;); &#125; &#125;); &#125; &#125; 4.掌握列表（ListView）控件的使用方法（1）ListView控件也通过ArrayAdapter建立与数据的连接，可以将数组里定义的内容一一对应的显示在ListView中，每一项一般只有一个TextView，即一行只能显示一个数组Item调用toString()方法生成的一行字符串。（2）新建一个安卓工程项目，实现列表控件的基本功能：（3）删除lv.setOnItemClickListener相关语句内容，再次运行程序，观察其效果有何变化。思考OnItemSelectedListener和OnItemClickListener的区别。 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.myapplication4;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ListView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView lv = new ListView(this); lv.setAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1,getData())); setContentView(lv); lv.setOnItemClickListener(new AdapterView.OnItemClickListener()&#123; public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; setTitle(&quot;您点击的是：&quot; + arg0.getItemAtPosition(arg2).toString()); &#125; &#125;); lv.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener()&#123; public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; setTitle(&quot;您选择的是：&quot; + arg0.getItemAtPosition(arg2).toString()); &#125; public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; &#125; &#125;); &#125; List&lt;String&gt; getData()&#123; List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(&quot;北京&quot;); l.add(&quot;上海&quot;); l.add(&quot;成都&quot;); l.add(&quot;香港&quot;); l.add(&quot;南京&quot;); return l; &#125; &#125; 5.掌握进度条（ProgressBar）控件的使用方法（1）进度条可以为用户呈现操作的进度。一般进度条的长度用来显示进度信息，工作完成量的百分比，同时还可以加入次要进度条显示次要进度信息，比如用主要进度条显示流媒体的播放进度，用次要进度条显示缓冲进度。一个进度条也可不确定其进度。在不确定模式下，进度条显示循环动画。这种模式常用于应用程序使用任务的长度是未知的。（2）进度条相关的重要方法包括：getMax()：返回这个进度条的范围的上限getProgress()：返回进度getSecondaryProgress()：返回次要进度incrementProgressBy(int diff)：指定增加的进度isIndeterminate()：指示进度条是否在不确定模式下setIndeterminate(boolean indeterminate)：设置不确定模式下setVisibility(int v)：设置该进度条是否可视（3）新建一个安卓项目工程，将初始界面的布局改为线性布局（水平），添加五个进度条，其中前三个分别为圆形进度条（小、中、大），第四个为静止条形进度条（进度为50%），第五个为动态条形进度条（初始进度为50%，次要进度为80%），并可通过两个按钮对第五个进度条的进度进行增加和减少操作。相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:layout_editor_absoluteX=&quot;192dp&quot; tools:layout_editor_absoluteY=&quot;308dp&quot;&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar1&quot; style=&quot;?android:attr/progressBarStyleSmallTitle&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar3&quot; style=&quot;?android:attr/progressBarStyleLarge&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar4&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;250dip&quot; android:layout_height=&quot;wrap_content&quot; android:max=&quot;100&quot; android:progress=&quot;50&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar5&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;250dip&quot; android:layout_height=&quot;wrap_content&quot; android:max=&quot;100&quot; android:progress=&quot;50&quot; android:secondaryProgress=&quot;80&quot; android:layout_marginTop=&quot;20dp&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;增加&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;减少&quot; /&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.myapplication5;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.Window;import android.widget.Button;import android.widget.ProgressBar;public class MainActivity extends AppCompatActivity &#123; ProgressBar pb1,pb2,pb3,pb4,pb5; View.OnClickListener ocl1 = null; View.OnClickListener ocl2 = null; Button bt1; Button bt2; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);//设置应用程序窗体显示状态 setContentView(R.layout.activity_main); setProgressBarIndeterminateVisibility(true);//设置窗体显示状态为真，表示一个程序正在运行 pb5 = (ProgressBar)findViewById(R.id.progressBar5); bt1 = (Button)findViewById(R.id.button); bt2 = (Button)findViewById(R.id.button2); ocl1 = new View.OnClickListener()&#123; public void onClick(View v)&#123; pb5.setProgress((int)(pb5.getProgress()*1.2)); //进度条显示为当前长度的1.2倍 &#125; &#125;; ocl2 = new View.OnClickListener()&#123; public void onClick(View v)&#123; pb5.setProgress((int)(pb5.getProgress()*0.8)); //进度条显示为当前长度的0.8倍 &#125; &#125;; bt1.setOnClickListener(ocl1);//按钮绑定响应操作 bt2.setOnClickListener(ocl2); &#125; &#125; 6.掌握缩放按钮（ZoomButton&amp;ZoomControl）控件的使用方法（1）ZoomControls是一个包含放大、缩小按钮的控件。而ZoomButton是您自己定义的缩放按钮，它允许你定义多个这样的按钮，它显示的只能是图片，没有Text属性。（2）新建一个安卓工程项目，添加一个TextView控件用来显示要进行缩放的文本，添加一个ZoomControls控件用来完成缩放。相关代码如下： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:layout_editor_absoluteX=&quot;163dp&quot; tools:layout_editor_absoluteY=&quot;306dp&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;979dp&quot; android:layout_height=&quot;207dp&quot; android:text=&quot;我是放大了还是缩小了&quot; /&gt; &lt;ZoomControls android:id=&quot;@+id/myZoomController&quot; android:layout_width=&quot;211dp&quot; android:layout_height=&quot;99dp&quot; android:gravity=&quot;center_horizontal&quot; /&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021222324252627282930313233343536package com.example.myapplication6;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;import android.widget.ZoomControls;public class MainActivity extends AppCompatActivity &#123; TextView tv1; static float size1 = 20; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv1 = (TextView)findViewById(R.id.textView);//定义一个图片视图对象 ZoomControls zc = (ZoomControls)findViewById(R.id.myZoomController); zc.setOnZoomInClickListener(new View.OnClickListener()&#123;//设置ZoomControls的放大监听器 public void onClick(View v) &#123; size1 += 10; tv1.setText(&quot;ZoomControlsLarger&quot;); tv1.setTextSize(size1); &#125; &#125;); zc.setOnZoomOutClickListener(new View.OnClickListener()&#123;//设置ZoomControls的缩小监听器 public void onClick(View v) &#123; size1 -= 10; tv1.setText(&quot;ZoomControlsSmaller&quot;); tv1.setTextSize(size1); &#125; &#125;); &#125; &#125;","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:17:45.428Z","path":"wiki/软件项目/JavaWeb项目/基于SSM框架的网上购物送货系统/","text":"基于SSM框架的网上购物送货系统系统开发平台：Tomcat8.0 + JDK1.8 + Windows10 开发语言：JavaEE JAR包管理：Maven3.6.1 前端：jQuery html5&#x2F;css3 后台 核心架构：SpringBoot Web框架：SpringMVC 持久层框架：Mybatis 模板引擎：Thymeleaf 数据库：Mysql 1.系统参与角色：管理者、购物者、送货员。 管理者：负责管理商品，提供商品信息，处理订单事务，系统的日常维护，控制超市状态。 购物者：在线注册账户，更新个人信息，管理账户，搜索浏览商品，管理购物车，支付订单，申请退款，留言以及售后评价。 送货员：注册成为送货员，更新个人信息，查看订单信息。 2.系统应用场景 活动泳道图之管理者在现实应用中，管理员可以通过管理员界面进行登录，然后管理商品，账号等信息。也可以设置超市公告，查看销售情况和订单信息等2.活动泳道图之购物者在现实应用中，购物者可以通过顾客界面进行登录，然后查看商品并对其进行各项操作，包括加入购物车和购买支付等，也可以管理自身信息，留言3.活动泳道图之送货员在现实应用中，送货员可以通过送货员界面进行登录，然后管理自身信息，也可以查看订单信息并操作 3.1需求模型1.购物者业务流程图2.管理员业务流程图3.送货员业务流程图4.订单管理业务流程图 3.2功能模型 3.3用例模型 4.系统截图用户页面 送货员页面 管理员页面 5.难点实现2.支付宝支付实现! 2.服务器的搭建服务器搭建教程：https://blog.csdn.net/qq_35206244&#x2F;article&#x2F;details&#x2F;83184173https://blog.csdn.net/Aidiying/article/details/84442638为了实现用户的远程操作，我们把项目部署到了云服务器上，云服务器可以节省经济成本，又节约了大量时间。我们项目用的是腾讯云服务器。 3.销量图表为了方便管理员进货，我们利用图表来帮助管理员了解商城销售商品的数量以及占比，利用ECharts来将后台的销量数据可视化，以便于直观显示销量占比 4.订单号设置随机数保证一定的并发性在购物时，会根据购物时间来生成订单号，为了避免多人同时购买商品时订单号重复使系统出现问题，我们利用ordernum++来生成不重复的订单号，保证一定程度的并发性。 5.定时调用轮转实现图片轮换 6.按序排列 6.源码地址：https://github.com/1105358600/MailSystem","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:17:34.404Z","path":"wiki/软件项目/JavaWeb项目/基于ssm的在线提问、回答系统/","text":"名称：在线提问、回答系统功能要求： 非登陆用户可以看其他人的问答，按最后一个回答时间的倒序排列 登陆用户可以发布、终结自己的问题。 对于未终结的问题，登陆用户可以发布、修改、删除自己的回答。 不分板块。 普通人可申请注册，管理员同意后算作注册成功；管理员可将现有用户拉黑，管理员不能删除用户。 被拉黑用户的问题、回答对其他人不可见。 管理员可以屏蔽掉某个问题或者回答，也可取消屏蔽。 被屏蔽的问题或回答对其他人不可见；提问人或回答人自己可见。 被屏蔽的问题或者回答，提问人或回答人不能改、删。 用例图：OOA类图： 源代码：https://github.com/1105358600/Qusetion_Answer","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:16:35.197Z","path":"wiki/软件项目/Linux项目/Ubuntu编制模拟一个简单的进程管理子系统，由进程建立模块、进程撤消模块、进程控制表组成，并包括进程切换和调度模块/","text":"一、进程管理子系统在Ubuntu下编制一个程序，模拟实现一个简单的进程管理子系统，它由进程建立模块、进程撤消模块、进程控制表组成，并包括进程切换和调度模块。 【设计要求1】该子系统接收新进程建立请求的方式是循环显示“请输入新命令行”，然后根据用户键入内容启动相应进程，其后不等待子进程结束，马上显示下一个“请输入新命令行”如此循环往复。当建立进程时，相应读写进程控制表，然后借助底层环境OS中象fork和exec这样的函数将新进程投入运行（这与底层环境的实际OS不同，实际OS将新进程投入运行时要布置现场，最后时程序技术器寄存器）。进程撤消时，利用底层OS的wait( )从子进程回到本子系统，相应修改PCB。比较该子系统与实际系统中的相应功能的异同与差距，尤其在现场保存与恢复方面的比较。 【设计要求2】在上题的基础上，进一步模拟实现进程切换。希望能实现时间片满或接到sleep调用（或信号时）进行进程切换（选择其一即可）。若要实现时间片，假设时间片为1秒钟，设定底层环境OS每个1秒向该系统发一个信号，本子系统将本子系统的进程切换和调度模块设定为该信号的处理程序。或者每当接到子进程发出的的sleep调用（或信号）时进行进程切换，这里子进程发出的sleep调用（或信号）代表实际系统中可能发生的sleep( )调用、等待某一时间发生等情况，进程调度采用简单的FIFO算法。 【设计要求3】编制一个进程调度算法模块。进程调度是处理机管理的核心内容。本设计要求用编写和调试一个简单的进程调度程序。通过设计本项目可以加深理解有关进程控制块、进程队列的概念，并体会和了解最高优先数优先的调度算法（即把处理机分配给优先数最高的进程）和先来先服务算法的具体实施办法。(1) 进程调度算法：采用最高优先数优先的调度算法（即把处理机分配给优先数最高的进程）和先来先服务算法。 (2) 每个进程有一个进程控制块（PCB）表示。进程控制块可以包含如下信息：进程名、优先数、到达时间、需要运行时间、已用CPU时间、进程状态等等。(3) 进程的优先数及需要的运行时间可以事先人为地指定（也可以由随机数产生）。进程的到达时间为进程输入的时间。进程的运行时间以时间片为单位进行计算。(4) 每个进程的状态可以是就绪W（Wait）、运行R（Run）、或完成F（Finish）三种状态之一。(5) 就绪进程获得CPU后都只能运行一个时间片。用已占用CPU时间加1来表示。如果运行一个时间片后，进程的已占用CPU时间已达到所需要的运行时间，则撤消该进程，如果运行一个时间片后进程的已占用CPU时间还未达所需要的运行时间，也就是进程还需要继续运行，此时应将进程的优先数减1（即降低一级），然后把它插入就绪队列等待CPU。(6) 每进行一次调度程序都打印一次运行进程、就绪队列、以及各个进程的PCB，以便进行检查。(7) 重复以上过程，直到所要进程都完成为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; //进程类class pcb&#123;public: //构造函数 pcb(char Name[20], int Rank, int Needtime) &#123; strcpy(name, Name); state = &quot;Wait&quot;; rank = Rank; needtime = Needtime; runtime = 0; next = NULL; &#125; char name[20]; string state; int rank; int needtime; int runtime; pcb* next;&#125;;pcb *ready = NULL, *now = NULL;//输出进程void output(pcb *point)&#123; cout &lt;&lt; &quot;.............................................................................&quot;; cout &lt;&lt; &quot;\\n 进程名称 \\t 进程状态 \\t 优先级 \\t 所需时间 \\t 已运行时间&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| &quot; &lt;&lt; point-&gt;name ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;state ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;rank ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;needtime; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;runtime &lt;&lt; endl; cout &lt;&lt; &quot;.............................................................................&quot; &lt;&lt; endl;&#125; //进程依次排序void sort(pcb *point)&#123; if (ready == NULL)//若链表为空 &#123; ready = point; &#125; else &#123; pcb *point1 = ready, *point2 = ready-&gt;next; if (point-&gt;rank &gt; point1-&gt;rank)//若为优先等级最高，放在队首 &#123; point-&gt;next = ready; ready = point; &#125; else &#123; while (point2 != NULL)//遍历链表，直到找到合适位置 &#123; if (point-&gt;rank &gt; point2-&gt;rank) &#123; point1-&gt;next = point; point-&gt;next = point2; break; &#125; point1 = point2; point2 = point2-&gt;next; &#125; if (point2 == NULL)//若为优先等级最低，放在队尾 &#123; point1-&gt;next = point; &#125; &#125; &#125;&#125; //进程结束函数，打印已完成进程，释放内存void finish(pcb *point)&#123; point-&gt;state = &quot;Finish&quot;; cout &lt;&lt; &quot;******************************** 进程&quot; &lt;&lt; point-&gt;name &lt;&lt; &quot;已经完成 ********************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n 进程名称 \\t 进程状态 \\t 优先级 \\t 所需时间 \\t 已运行时间&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| &quot; &lt;&lt; point-&gt;name ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;state ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;rank ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;needtime; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;runtime &lt;&lt; endl; delete(point); point = NULL;&#125; //运行一个单位时间void running()&#123; now = ready; ready = ready-&gt;next; now-&gt;next = NULL; now-&gt;state = &quot;Run&quot;; now-&gt;rank--; now-&gt;runtime++; if (now-&gt;needtime == now-&gt;runtime) &#123; //若当前进程执行完毕 finish(now); now = NULL; &#125; else &#123; //若当前进程没有执行完毕 cout &lt;&lt; &quot;*************************** 当前正在运行的进程是 *************************** &quot; &lt;&lt; endl; output(now); &#125; //打印就绪队列 cout &lt;&lt; &quot;*************************** 当前就绪队列状态为 *************************** &quot; &lt;&lt; endl; pcb *point = ready; while (point != NULL) &#123; output(point); point = point-&gt;next; &#125; //把没执行完的进程重新放入队列 if (now != NULL) &#123; now-&gt;state = &quot;Wait&quot;; sort(now); &#125;&#125; int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int t; cout&lt;&lt;&quot;**** 输入进程数目：&quot;; cin &gt;&gt; t; cout &lt;&lt; endl; //进程信息输入 for (int i = 1; i &lt;= t; i++) &#123; pcb *temp; char name[20];int rank;int needtime; cout &lt;&lt; &quot;**** 请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个进程的信息 ****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入该进程的名字：&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;请输入该进程的优先等级:&quot;; cin &gt;&gt; rank; cout &lt;&lt; &quot;请输入该进程需要的运行时间:&quot;; cin &gt;&gt; needtime; temp = new pcb(name, rank, needtime); sort(temp); temp = NULL; cout &lt;&lt; endl; &#125; //打印执行前的就绪队列 cout &lt;&lt; &quot;*************************** 执行前就绪队列排序 *****************************&quot; &lt;&lt; endl; pcb *point = ready; while (point != NULL) &#123; output(point); point = point-&gt;next; &#125; cout &lt;&lt; &quot;*************************** 程序准备正式开始执行 *****************************&quot; &lt;&lt; endl; //程序开始执行 char ch; while (now != NULL || ready != NULL) &#123; //一次运行一个单位时间 cout &lt;&lt; &quot;\\n\\n 按任一键继续......&quot; &lt;&lt; endl; ch = getchar(); running(); cout &lt;&lt; endl; &#125; //所有进程完成 cout &lt;&lt; &quot;*************************** 所有进程均已执行完成 ***************************&quot; &lt;&lt; endl; return 0;&#125; 二、进程管理子系统截图","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Linux项目","slug":"软件项目/Linux项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Linux%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:16:23.325Z","path":"wiki/软件项目/Linux项目/UNIX简单文件系统的实现/","text":"1.1设计目的和内容要求1. 设计目的 通过具体的文件存储空间的管理、文件的物理结构、目录结构和文件操作的实现，加深对文件系统内部数据结构、功能以及实现过程的理解。 2．内容要求(1)在内存中开辟一个虚拟磁盘空间作为文件存储分区，在其上实现一个简单的基于多级目录的单用户单任务系统中的文件系统。在退出该文件系统的使用时，应将该虚拟文件系统以一个文件的方式保存到磁盘上，以便下次可以再将它恢复到内存的虚拟磁盘空间中。(2)文件存储空间的分配可采用显式链接分配或其他的办法。(3)文件目录结构采用多级目录结构。为了简单起可以通过目录项实现对文件的读和写的保护。见，可以不使用索引结点，其中的每个目录项应包含文件名、物理地址、长度等信息，还(4)要求提供以下操作命令： my_format：对文件存储器进行格式化，即按照文件系统的结构对虚拟磁盘空间进行布局，并在其上创建根目录以及用于管理文件存储空间等的数据结构。 my_mkdir：用于创建子目录。 my_rmdir：用于删除子目录。 my_ls：用于显示目录中的内容。 my_cd：用于更改当前目录。 my_create：用于创建文件。 my_open：用于打开文件。 my_close：用于关闭文件。 my_write：用于写文件。 my_read：用于读文件。 my_rm：用于删除文件。 List item my_exitsys：用于退出文件系统。 1.2 预备知识1．打开文件函数open()（1）格式：fd&#x3D;open(name, rwmode[,pmode]);（2）功能：打开一个已存在的文件。 2．关闭文件函数close()（1）格式：status&#x3D;close(fd);（2）功能：用来关闭先前open()打开的一个文件。此动作会让缓冲区内的数据写入文件中，并释放系统所提供的文件资源。 3．读文件函数read()（1）格式：n&#x3D; read( fd,buffer,size )；（2）功能：对文件的读操作。（3）输入参数说明：n是一次读操作的返回字节数； buffer：是指向读缓冲区的指针；size： 本次读文件时请求读的字节数； 4. 写文件函数write()（1）格式：n&#x3D; write( fd,buffer,size )；（2）功能：将数据写到二进制文件中。（3）输入参数说明：n是一次写操作的返回字节数； buffer：是指向写缓冲区的指针；size： 本次写文件时请求写的字节数； 5. 定位文件函数lseek()（1）格式：newpos&#x3D;lseek( fd, offset, origin )；（2）功能： 改变文件指针所处的位置。（3）输入参数说明：newpos是一个长整数返回值，若lseek调用成功则返回文件指针的新位置，若调用失败则返回-1； fd是被打开文件的描述符offset：位移量，以字节为单位；origin：初始位置，是确定文件指针偏移量的基准点，有三个常量：SEEK_CUR：读写指针当前位置；SEEK_SET：文件开头；SEEK_END：文件末尾。 1.3实例系统的设计与实现1.3.1 数据结构设计1．需要包含的头文件 （1）#include &lt;stdio.h&gt;（2）#include &lt;malloc.h&gt;（3）#include &lt;string.h&gt;（4）#include &lt;time.h&gt; 2．定义的常量（1）#define BLOCKSIZE 1024 磁盘块大小（2）#define SIZE 1024000 虚拟磁盘空间大小（3）#define END 65535 文件结束标志（4）#define FREE 0 盘块空闲标志（5）#define ROOTBLOCKNUM 2 根目录区所占盘块总数（6）#define MAXOPENFILE 10 最多同时打开文件个数 3．数据结构（1）文件控制块FCB用于记录文件的描述和控制信息，每个文件设置一个FCB，它也是文件的目录项的内容。 typedef struct FCB &#x2F;&#x2F;仿照FAT16设置的{ char filename[8]; &#x2F;&#x2F;文件名 char exname[3];&#x2F;&#x2F;文件扩展名 unsigned char attribute;&#x2F;&#x2F;文件属性字段：为简单起见，我们只为文件设置了两种属性：&#x2F;&#x2F;值为0时表示目录文件，值为1时表示数据文件 unsigned short time;&#x2F;&#x2F;文件创建时间 unsigned short data;&#x2F;&#x2F;文件创建日期 unsigned short first;&#x2F;&#x2F;文件起始盘块号 unsigned long length;&#x2F;&#x2F;文件长度（字节数） char free；&#x2F;&#x2F;表示目录项是否为空，若值为0，表示空，值为1，表示已分配}fcb; （2）文件分配表FAT 在本实例中，文件分配表有两个作用：一是记录磁盘上每个文件所占据的磁盘块的块号；二是记录磁盘上哪些块已经分配出去了，哪些块是空闲的，即起到了位示图的作用。若FAT中某个表项的值为FREE，则表示该表项所对应的磁盘块是空闲的；若某个表项的值为END，则表示所对应的磁盘块是某文件的最后一个磁盘块；若某个表项的值是其他值，则该值表示某文件的下一个磁盘块的块号。为了提高系统的可靠性，本实例中设置了两张FAT表，它们互为备份，每个FAT占据两个磁盘块。typedef struct FAT{ unsigned short id;}fat; （3）用户打开文件表USEROPEN 当打开一个文件时，必须将文件的目录项中的所有内容全部复制到内存中，同时还要记录有关文件操作的动态信息，如读写指针的值等。在本实例中实现的是一个用于单用户单任务系统的文件系统，为简单起见，我们把用户文件描述符表和内存FCB表合在一起，称为用户打开文件表，表项数目为10，即一个用户最多可同时打开10个文件。然后用一个数组来描述，则数组下标即某个打开文件的描述符。另外，我们在用户打开文件表中还设置了一个字段“char dir[80]”，用来记录每个打开文件所在的目录名，以方便用户打开不同目录下具有相同文件名的不同文件。typedef struct USEROPEN{ char filename[8]; &#x2F;&#x2F;文件名 char exname[3];&#x2F;&#x2F;文件扩展名 unsigned char attribute;&#x2F;&#x2F;文件属性：值为0时表示目录文件，值为1时表示数据文件 unsigned short time;&#x2F;&#x2F;文件创建时间 unsigned short data;&#x2F;&#x2F;文件创建日期 unsigned short first;&#x2F;&#x2F;文件起始盘块号 unsigned long length;&#x2F;&#x2F;文件长度（对数据文件是字节数，对目录文件可以是目录项个数） char free；&#x2F;&#x2F;表示目录项是否为空，若值为0，表示空，值为1，表示已分配 &#x2F;&#x2F;前面内容是文件的FCB中的内容。 &#x2F;&#x2F; 下面设置的dirno和diroff记录了相应打开文件的目录项在父目录文件中的位置，&#x2F;&#x2F;这样如果该文件的fcb被修改了，则要写回父目录文件时比较方便 int dirno; &#x2F;&#x2F;相应打开文件的目录项在父目录文件中的盘块号 int diroff；&#x2F;&#x2F; 相应打开文件的目录项在父目录文件的dirno盘块中的目录项序号 char dir[MAXOPENFILE][80]; &#x2F;&#x2F;相应打开文件所在的目录名，这样方便快速检查出&#x2F;&#x2F;指定文件是否已经打开 int count; &#x2F;&#x2F;读写指针在文件中的位置 char fcbstate; &#x2F;&#x2F;是否修改了文件的FCB的内容，如果修改了置为1，否则为0char topenfile; &#x2F;&#x2F;表示该用户打开表项是否为空，若值为0，表示为空，否则表示已&#x2F;&#x2F;被某打开文件占据}useropen; （4）引导块BLOCK0 在引导块中主要存放逻辑磁盘的相关描述信息，比如磁盘块大小、磁盘块数量、文件分配表、根目录区、数据区在磁盘上的起始位置等。如果是引导盘，还要存放操作系统的引导信息。本实例是在内存的虚拟磁盘中创建一个文件系统，因此所包含的内容比较少，只有磁盘块大小、磁盘块数量、数据区开始位置、根目录文件开始位置等。typedef struct BLOCK0 &#x2F;&#x2F;引导块内容{&#x2F;&#x2F;存储一些描述信息，如磁盘块大小、磁盘块数量、最多打开文件数等、 char information[200]; unsigned short root; &#x2F;&#x2F;根目录文件的起始盘块号 unsigned char *startblock; &#x2F;&#x2F;虚拟磁盘上数据区开始位置 }block0; 4．全局变量定义 （1）unsigned char *myvhard： 指向虚拟磁盘的起始地址（2）useropen openfilelist[MAXOPENFILE]： 用户打开文件表数组（3）useropen ptrcurdir： 指向用户打开文件表中的当前目录所在打开文件表项的位置；（4）char currentdir[80]： 记录当前目录的目录名（包括目录的路径）（5）unsigned char startp： 记录虚拟磁盘上数据区开始位置 5．虚拟磁盘空间布局 由于真正的磁盘操作需要涉及到设备的驱动程序，所以本实例是在内存中申请一块空间作为虚拟磁盘使用，我们的文件系统就建立在这个虚拟磁盘上。虚拟磁盘一共划分成1000个磁盘块，每个块1024个字节，其布局格式是模仿FAT文件系统设计的，其中引导块占一个盘块，两张FAT各占2个盘块，剩下的空间全部是数据区，在对虚拟磁盘进行格式化的时候，将把数据区第1块（即虚拟磁盘的第6块）分配给根目录文件。 当然，也可以仿照FAT16文件系统，设置根目录区，其位置紧跟第2张FAT后面，大小也是固定的，这个思路相对要简单一点，请同学们自己去实现。 1.3.2 实例主要命令及函数设计1．系统主函数main()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：void main()（4）功能：系统主函数（5）输入：无（6）输出：无（7）函数需完成的工作：① 对前面定义的全局变量进行初始化；② 调用startsys()进入文件系统；③ 列出文件系统提供的各项功能及命令调用格式；④ 显示命令行提示符，等待用户输入命令；⑤ 将用户输入的命令保存到一个buf中；⑥ 对buf中的内容进行命令解析，并调用相应的函数执行用户键入的命令；⑦ 如果命令不是“my_exitsys”，则命令执行完毕后转④。 2. 进入文件系统函数startsys()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：void startsys()（4）功能：由main()函数调用，进入并初始化我们所建立的文件系统，以供用户使用。（5）输入：无 （6）输出：无。（7）函数需完成的工作：① 申请虚拟磁盘空间；② 使用c语言的库函数fopen()打开myfsys文件：若文件存在，则转③；若文件不存在，则创建之，转⑤③ 使用c语言的库函数fread()读入myfsys文件内容到用户空间中的一个缓冲区中，并判断其开始的8个字节内容是否为“10101010”（文件系统魔数），如果是，则转④；否则转⑤；④ 将上述缓冲区中的内容复制到内存中的虚拟磁盘空间中；转⑦⑤ 在屏幕上显示“myfsys文件系统不存在，现在开始创建文件系统”信息，并调用my_format()对①中申请到的虚拟磁盘空间进行格式化操作。转⑥；⑥ 将虚拟磁盘中的内容保存到myfsys文件中；转⑦⑦ 使用c语言的库函数fclose()关闭myfsys文件；⑧ 初始化用户打开文件表，将表项0分配给根目录文件使用，并填写根目录文件的相关信息，由于根目录没有上级目录，所以表项中的dirno和diroff分别置为5（根目录所在起始块号）和0；并将ptrcurdir指针指向该用户打开文件表项。⑨ 将当前目录设置为根目录。 3．磁盘格式化函数my_format()（1）对应命令：my_format（2）命令调用格式：my_format（3）函数设计格式：void my_format()（4）功能：对虚拟磁盘进行格式化，布局虚拟磁盘，建立根目录文件（或根目录区）。（5）输入：无 （6）输出：无。（7）函数需完成的工作：① 将虚拟磁盘第一个块作为引导块，开始的8个字节是文件系统的魔数，记为“10101010”；在之后写入文件系统的描述信息，如FAT表大小及位置、根目录大小及位置、盘块大小、盘块数量、数据区开始位置等信息；② 在引导块后建立两张完全一样的FAT表，用于记录文件所占据的磁盘块及管理虚拟磁盘块的分配，每个FAT占据两个磁盘块；对于每个FAT中，前面5个块设置为已分配，后面995个块设置为空闲；③ 在第二张FAT后创建根目录文件root，将数据区的第1块（即虚拟磁盘的第6块）分配给根目录文件，在该磁盘上创建两个特殊的目录项：“.”和“..”，其内容除了文件名不同之外，其他字段完全相同。 4．更改当前目录函数my_cd()（1）对应命令：my_cd（2）命令调用格式：my_cd dirname（3）函数设计格式：void my_cd(char *dirname)（4）功能：改变当前目录到指定的名为dirname的目录。（5）输入：dirname：新的当前目录的目录名； （6）输出：无（7）函数需完成的工作：① 调用my_open()打开指定目录名的父目录文件，并调用do_read()读入该父目录文件内容到内存中；② 在父目录文件中检查新的当前目录名是否存在，如果存在则转③，否则返回，并显示出错信息；③ 调用my_close()关闭①中打开的父目录文件；④ 调用my_close()关闭原当前目录文件；⑤ 如果新的当前目录文件没有打开，则打开该目录文件；并将ptrcurdir指向该打开文件表项；⑥ 设置当前目录为该目录。 5．创建子目录函数my_mkdir()（1）对应命令：my_mkdir（2）命令调用格式：my_ mkdir dirname（3）函数设计格式：void my_mkdir(char *dirname)（4）功能：在当前目录下创建名为dirname的子目录。（5）输入：dirname：新建目录的目录名。 （6）输出：无。（7）函数需完成的工作：① 调用do_read()读入当前目录文件内容到内存，检查当前目录下新建目录文件是否重名，若重名则返回，并显示错误信息；② 为新建子目录文件分配一个空闲打开文件表项，如果没有空闲表项则返回-1，并显示错误信息；③ 检查FAT是否有空闲的盘块，如有则为新建目录文件分配一个盘块，否则释放①中分配的打开文件表项，返回，并显示错误信息；④ 在当前目录中为新建目录文件寻找一个空闲的目录项或为其追加一个新的目录项;需修改当前目录文件的长度信息，并将当前目录文件的用户打开文件表项中的fcbstate置为1；⑤ 准备好新建目录文件的FCB的内容，文件的属性为目录文件，以覆盖写方式调用do_write()将其填写到对应的空目录项中；⑥ 在新建目录文件所分配到的磁盘块中建立两个特殊的目录项“.”和“..”目录项，方法是：首先在用户空间中准备好内容，然后以截断写或者覆盖写方式调用do_write()将其写到③中分配到的磁盘块中；⑦ 返回。 6．删除子目录函数rmdir()（1）对应命令：my_ rmdir（2）命令调用格式：my_ rmdir dirname（1）函数设计格式：void my_rmdir(char *dirname)（2）功能：在当前目录下删除名为dirname的子目录。（3）输入：dirname：欲删除目录的目录名。 （4）输出：无。（5）函数需完成的工作：① 调用do_read()读入当前目录文件内容到内存，检查当前目录下欲删除目录文件是否存在，若不存在则返回，并显示错误信息；② 检查欲删除目录文件是否为空（除了“.”和“..”外没有其他子目录和文件），可根据其目录项中记录的文件长度来判断，若不为空则返回，并显示错误信息；③ 检查该目录文件是否已经打开，若已打开则调用my_close()关闭掉；④ 回收该目录文件所占据的磁盘块，修改FAT；⑤ 从当前目录文件中清空该目录文件的目录项，且free字段置为0：以覆盖写方式调用do_write()来实现；⑥ 修改当前目录文件的用户打开表项中的长度信息，并将表项中的fcbstate置为1；⑦ 返回。 7．显示目录函数my_ls()（1）对应命令：my_ls（2）命令调用格式：my_ls（3）函数设计格式：void my_ls(void)（4）功能：显示当前目录的内容（子目录和文件信息）。（5）输入：无 （6）输出：无（7）函数需完成的工作：① 调用do_read()读出当前目录文件内容到内存；② 将读出的目录文件的信息按照一定的格式显示到屏幕上；③ 返回。 8．创建文件函数my_create()（1）对应命令：my_create（2）命令调用格式：my_create filename（3）函数设计格式：int my_create (char *filename)（4）功能：创建名为filename的新文件。（5）输入：filename：新建文件的文件名，可能包含路径。 （6）输出：若创建成功，返回该文件的文件描述符（文件打开表中的数组下标）；否则返回-1。（7）函数需完成的工作：① 为新文件分配一个空闲打开文件表项，如果没有空闲表项则返回-1，并显示错误信息；② 若新文件的父目录文件还没有打开，则调用my_open()打开；若打开失败，则释放①中为新建文件分配的空闲文件打开表项，返回-1，并显示错误信息；③ 调用do_read()读出该父目录文件内容到内存，检查该目录下新文件是否重名，若重名则释放①中分配的打开文件表项，并调用my_close()关闭②中打开的目录文件；然后返回-1，并显示错误信息；④ 检查FAT是否有空闲的盘块，如有则为新文件分配一个盘块，否则释放①中分配的打开文件表项，并调用my_close()关闭②中打开的目录文件；返回-1，并显示错误信息；⑤ 在父目录中为新文件寻找一个空闲的目录项或为其追加一个新的目录项;需修改该目录文件的长度信息，并将该目录文件的用户打开文件表项中的fcbstate置为1；⑥ 准备好新文件的FCB的内容，文件的属性为数据文件，长度为0，以覆盖写方式调用do_write()将其填写到⑤中分配到的空目录项中；⑦ 为新文件填写①中分配到的空闲打开文件表项，fcbstate字段值为0，读写指针值为0；⑧ 调用my_close()关闭②中打开的父目录文件；⑨ 将新文件的打开文件表项序号作为其文件描述符返回。 9．删除文件函数my_rm()（1）对应命令：my_rm（2）命令调用格式：my_rm filename（3）函数设计格式：void my_rm(char *filename)（4）功能：删除名为filename的文件。（5）输入：filename：欲删除文件的文件名，可能还包含路径。 （6）输出：无。（7）函数需完成的工作：① 若欲删除文件的父目录文件还没有打开，则调用my_open()打开；若打开失败，则返回，并显示错误信息；② 调用do_read()读出该父目录文件内容到内存，检查该目录下欲删除文件是否存在，若不存在则返回，并显示错误信息；③ 检查该文件是否已经打开，若已打开则关闭掉；④ 回收该文件所占据的磁盘块，修改FAT；⑤ 从文件的父目录文件中清空该文件的目录项，且free字段置为0：以覆盖写方式调用do_write()来实现；；⑥ 修改该父目录文件的用户打开文件表项中的长度信息，并将该表项中的fcbstate置为1；⑦ 返回。 10．打开文件函数my_open()（1）对应命令：my_open（2）命令调用格式：my_open filename（3）函数设计格式：int my_open(char *filename)（4）功能：打开当前目录下名为filename的文件。（5）输入：filename：欲打开文件的文件名 （6）输出：若打开成功，返回该文件的描述符（在用户打开文件表中表项序号）；否则返回-1。（7）函数需完成的工作：① 检查该文件是否已经打开，若已打开则返回-1，并显示错误信息；② 调用do_read()读出父目录文件的内容到内存，检查该目录下欲打开文件是否存在，若不存在则返回-1，并显示错误信息；③ 检查用户打开文件表中是否有空表项，若有则为欲打开文件分配一个空表项，若没有则返回-1，并显示错误信息；④ 为该文件填写空白用户打开文件表表项内容，读写指针置为0；⑤ 将该文件所分配到的空白用户打开文件表表项序号（数组下标）作为文件描述符fd返回。 11．关闭文件函数my_close()（1）对应命令：my_close（2）命令调用格式：my_close fd（3）函数设计格式：void my_close(int fd)（4）功能：关闭前面由my_open()打开的文件描述符为fd的文件。（5）输入：fd：文件描述符。 （6）输出：无。（7）函数需完成的工作：① 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1；② 检查用户打开文件表表项中的fcbstate字段的值，如果为1则需要将该文件的FCB的内容保存到虚拟磁盘上该文件的目录项中，方法是：打开该文件的父目录文件，以覆盖写方式调用do_write()将欲关闭文件的FCB写入父目录文件的相应盘块中；③ 回收该文件占据的用户打开文件表表项（进行清空操作），并将topenfile字段置为0；④ 返回。 12．写文件函数my_write()（1）对应命令：my_write（2）命令调用格式：my_write fd（3）函数设计格式：int my_write(int fd)（4）功能：将用户通过键盘输入的内容写到fd所指定的文件中。磁盘文件的读写操作都必须以完整的数据块为单位进行，在写操作时，先将数据写在缓冲区中，缓冲区的大小与磁盘块的大小相同，然后再将缓冲区中的数据一次性写到磁盘块中；读出时先将一个磁盘块中的内容读到缓冲区中，然后再传送到用户区。本实例为了简便起见，没有设置缓冲区管理，只是在读写文件时由用户使用malloc()申请一块空间作为缓冲区，读写操作结束后使用free()释放掉。写操作常有三种方式：截断写、覆盖写和追加写。截断写是放弃原来文件的内容，重新写文件；覆盖写是修改文件在当前读写指针所指的位置开始的部分内容；追加写是在原文件的最后添加新的内容。在本实例中，输入写文件命令后，系统会出现提示让用户选择其中的一种写方式，并将随后键盘输入的内容按照所选的方式写到文件中，键盘输入内容通过CTR+Z键（或其他设定的键）结束。（5）输入：fd： open()函数的返回值，文件的描述符； （6）输出：实际写入的字节数。（7）函数需完成的工作：① 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1，并显示出错信息；② 提示并等待用户输入写方式：（1：截断写；2：覆盖写；3：追加写）③ 如果用户要求的写方式是截断写，则释放文件除第一块外的其他磁盘空间内容（查找并修改FAT表），将内存用户打开文件表项中文件长度修改为0，将读写指针置为0并转④；如果用户要求的写方式是追加写，则修改文件的当前读写指针位置到文件的末尾，并转④；如果写方式是覆盖写，则直接转④；④ 提示用户：整个输入内容通过CTR+Z键（或其他设定的键）结束；用户可分多次输入写入内容，每次用回车结束；⑤ 等待用户从键盘输入文件内容，并将用户的本次输入内容保存到一临时变量text[]中，要求每次输入以回车结束，全部结束用CTR+Z键（或其他设定的键）；⑥ 调用do_write()函数将通过键盘键入的内容写到文件中。⑦ 如果do_write()函数的返回值为非负值，则将实际写入字节数增加do_write()函数返回值，否则显示出错信息，并转⑨；⑧ 如果text[]中最后一个字符不是结束字符CTR+Z，则转⑦继续进行写操作；否则转⑨；⑨ 如果当前读写指针位置大于用户打开文件表项中的文件长度，则修改打开文件表项中的文件长度信息，并将fcbstate置1；⑩ 返回实际写入的字节数。 13．实际写文件函数do_write()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：int my_write(int fd，char *text，int len，char wstyle)（4）功能：被写文件函数my_write()调用，用来将键盘输入的内容写到相应的文件中去。（5）输入：fd： open()函数的返回值，文件的描述符；text：指向要写入的内容的指针；len：本次要求写入字节数 wstyle：写方式（6）输出：实际写入的字节数。（7）函数需完成的工作：① 用malloc()申请1024B的内存空间作为读写磁盘的缓冲区buf，申请失败则返回-1，并显示出错信息；② 将读写指针转化为逻辑块块号和块内偏移off，并利用打开文件表表项中的首块号及FAT表的相关内容将逻辑块块号转换成对应的磁盘块块号blkno；如果找不到对应的磁盘块，则需要检索FAT为该逻辑块分配一新的磁盘块，并将对应的磁盘块块号blkno登记到FAT中，若分配失败，则返回-1，并显示出错信息；③ 如果是覆盖写，或者如果当前读写指针所对应的块内偏移off不等于0，则将块号为blkno的虚拟磁盘块全部1024B的内容读到缓冲区buf中；否则便用ASCII码0清空buf；④ 将text中未写入的内容暂存到缓冲区buff的第off字节开始的位置，直到缓冲区满，或者接收到结束字符CTR+Z为止；将本次写入字节数记录到tmplen中；⑤ 将buf中1024B的内容写入到块号为blkno的虚拟磁盘块中；⑥将当前读写指针修改为原来的值加上tmplen；并将本次实际写入的字节数增加tmplen；⑦ 如果tmplen小于len，则转②继续写入；否则转⑧；⑧ 返回本次实际写入的字节数。 14．读文件函数my_read()（1）对应命令：my_read（2）命令调用格式：my_read fd len（3）函数设计格式：int myread (int fd, int len)（4）功能：读出指定文件中从读写指针开始的长度为len的内容到用户空间中。（5）输入：fd： open()函数的返回值，文件的描述符；len: 要从文件中读出的字节数。 （6）输出：实际读出的字节数。（7）函数需完成的工作：① 定义一个字符型数组text[len]，用来接收用户从文件中读出的文件内容；② 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1，并显示出错信息；③ 调用do_read()将指定文件中的len字节内容读出到text[]中；④ 如果do_read()的返回值为负，则显示出错信息；否则将text[]中的内容显示到屏幕上；⑤ 返回。 15．实际读文件函数do_read()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：int do_read (int fd, int len,char *text)（4）功能：被my_read()调用，读出指定文件中从读写指针开始的长度为len的内容到用户空间的text中。（5）输入：fd： open()函数的返回值，文件的描述符；len: 要求从文件中读出的字节数。 text：指向存放读出数据的用户区地址（6）输出：实际读出的字节数。（7）函数需完成的工作：① 使用malloc()申请1024B空间作为缓冲区buf，申请失败则返回-1，并显示出错信息；② 将读写指针转化为逻辑块块号及块内偏移量off，利用打开文件表表项中的首块号查找FAT表，找到该逻辑块所在的磁盘块块号；将该磁盘块块号转化为虚拟磁盘上的内存位置；③ 将该内存位置开始的1024B（一个磁盘块）内容读入buf中；④ 比较buf中从偏移量off开始的剩余字节数是否大于等于应读写的字节数len，如果是，则将从off开始的buf中的len长度的内容读入到text[]中；否则，将从off开始的buf中的剩余内容读入到text[]中；⑤ 将读写指针增加④中已读字节数，将应读写的字节数len减去④中已读字节数，若len大于0，则转②；否则转⑥；⑥ 使用free()释放①中申请的buf。⑦ 返回实际读出的字节数。 16. 退出文件系统函数my_exitsys()（1）对应命令：my_exitsys（2）命令调用格式：my_ exitsys（1）函数设计格式：void my_exitsys()（2）功能：退出文件系统。（3）输入：无 （4）输出：无。（5）函数需完成的工作：① 使用C库函数fopen()打开磁盘上的myfsys文件；② 将虚拟磁盘空间中的所有内容保存到磁盘上的myfsys文件中；③ 使用c语言的库函数fclose()关闭myfsys文件；④ 撤销用户打开文件表，释放其内存空间⑤ 释放虚拟磁盘空间。 github代码地址https://github.com/1105358600/LunixFileSystem","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Linux项目","slug":"软件项目/Linux项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Linux%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:15:54.236Z","path":"wiki/实用工具/使用nvm管理node版本，实现高版本与低版本node之间的转换/","text":"先清空本地安装的node.js版本1.按健win+R弹出窗口，键盘输入cmd,然后敲回车（或者鼠标直接点击电脑桌面最左下角的win窗口图标弹出，输入cmd再点击回车键） 然后进入命令控制行窗口，并输入where node查看之前本地安装的node的路径 2.找到上面找到的路径，将node.exe所在的父目录里面的所有东西都删除 3.为了彻底删除之前安装的node.js，鼠标点击电脑左面最左下角的win窗口图标弹出，输入“控制面板”再点击回车键进入，进入控制面板后，找到所安装的node.js并卸载。 安装nvm管理工具1.从官网下载安装包 https://github.com/coreybutler/nvm-windows/releases，下载红框里面的那个，下载后，直接进行安装 2.nvm安装完成后，检验是否安装成功，进入命令控制行窗口（进入方法见前面），输入命令nvm v查看，如果出现版本号，即安装成功（如果安装不成功，查看之前自己安装的node.js有没有删除彻底、安装nvm工过程有没有漏掉什么！）。 安装node.js版本(1) 输入命令行nvm ls anaillable查看可用的node.js版本号 (2) 输入命令行nvm install node版本号(例如：nvm install 12.17.0)即可安装对应版本以及自动安装对应的npm版本。安装完成后可以首先输入npm use+版本号（使用此命令行可以根据你自己的需要随意切换node.js版本运行），之后可分别输入命令行node -v和npm -v，检验node.js以及对应npm是否安装成功，如果可以显示版本号这说明安装成功。 (4) 输入命令行nvm ls查看你安装的所有node.js版本号，以及你当前所选择的node.js运行版本 (4) 如果想删除某node.js版本的话，输入命令行nvm install node版本号（例如：nvm use 12.17.0）即可删除对应版本总结：使用nvm来管理node.js的版本真的很方便，这样就可以根据自己的需要来回切换node.js版本！ 配置镜像在 nvm 的安装路径下，找到 settings.txt，设置node_mirro与npm_mirror为国内镜像地址。下载就飞快了~~ root: D:\\nvmpath: D:\\nodejsnode_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/","tags":[],"categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://pistachiout.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"","date":"2023-02-15T02:15:28.460Z","path":"wiki/论文研究/Nginx高并发实现原理学习/","text":"目前，互联网已经得到了广泛的普及与应用，个人电脑和移动设备的发展,使得即时信息与娱乐服务变的更加方便精巧,基础用户的不断增加使得应用访问量变得巨大。为了提供安全可靠的服务,服务器端正在面临着越来越大的压力。传统的服务器多线程业务逻辑设计在大量用户访问时支撑并发连接的能力有限，不利于构建高性能服务器架构。Nginx 作为当下的高并发连接的负载均衡服务器因其极强的性能得到广泛的使用。本文主要对高并发Nginx进行详细的介绍，重点说明使用Nginx实现Web系统的高并发的原理。 一、Web系统高并发性（一）高并发概念高并发在外行人眼里似乎很高大上，但其实并不难理解，它指的就是我们通过各种设计使得系统能够在同一时间并行处理很多请求。一般来说高并发是一个结果导向的东西，现实中的例子也不少。常见的高并发场景有：双11时淘宝等系统处理大量购物者的购物请求、选课时的学校选课系统、春节时12306网站处理大量的购票请求、微博出现各种惊人热搜等，高并发的概念并不是突然出现的，而是随着业务的发展而产生的需求。高并发的业务场景出现了，随之而来的就是要支持这个高并发业务场景的架构——技术要为业务服务，业务倒逼技术发展，高并发是随着业务发展的。 （二）高并发指标接下来分析高并发的指标。高并发并不意味着仅仅只追求高性能。从宏观的角度来看，高并发系统有三个基本的设计目标，分别是高性能、高可用以及高可扩展性，而这三方面并不是孤立存在的，它们彼此之间是可以相互支撑的。 高性能：性能主要体现了系统的并行处理能力，在有限的硬件投入下，提高性能就意味着能节省成本。衡量软件性能包括了响应时间、TPS、服务器资源利用率等客观指标，也可以是用户的主观感受（从程序员、业务用户、终端用户&#x2F;客户不同的视角，可能会得出不同的结论）。 .高可用性：可用即表示一般情况下系统可以正常服务的时间，指系统具有较高的无故障运行能力，可用性 &#x3D; 平均故障时间 &#x2F; 系统总运行时间。一个全年无故障，能够正常服务；而另一个过不久就出线上事故、宕机，那么用户肯定会选择前者，另外，如果系统可用性过低，也一定会大大拖累业务。 高扩展：表示的是系统处理的扩展能力。在流量高峰时能否在短时间内完成扩容，更平稳地承接峰值流量，比如双11、微博各种惊人热搜等流量巨大时的扩展能力。面对突发流量，不可能临时改造架构，最快的方式就是增加机器来线性提高系统的处理能力。从高并发系统的整体架构角度来看，扩展的目标不仅仅是把服务设计成无状态就行了，因为当流量增加 10 倍，业务服务可以快速扩容 10 倍，但是数据库可能就成为了新的瓶颈。我们需要站在整体架构的角度，而不仅仅是业务服务器的角度来考虑系统的扩展性，所以说，数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等都是系统扩展时需要考虑的因素。我们要知道系统并发到了某一个量级之后，哪一个因素会成为我们的瓶颈点，从而针对性地进行扩展[1]。 （三）高并发架构实现的方法高并发的解决方案包括以下几种： · 流量优化： 防盗链处理（把一些恶意的请求拒之门外） · 前端优化：减少HTTP请求、添加异步请求、启用浏览器的缓存和文件压缩、CDN加速、建立独立的图片服务器； · 服务端优化：页面静态化处理、并发处理、队列处理； · . 数据库优化：数据库的缓存、分库分表、分区操作、读写分离、负载均衡； Web服务器优化：负载均衡。[3] 以上案例总而言之在方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能的提升。垂直维度可包括以下措施： 提升单机的硬件性能：通过增加内存、 CPU核数、存储容量、或者将磁盘 升级成SSD等堆硬件的方式来提升。 ·提升单机的软件性能：使用缓存减少IO次数，使用并发或者异步的方式增加吞吐量。 水平维度可包括以下措施： ·做好分层架构：这是横向扩展的前提，因为高并发系统往往业务复杂，通过分层处理可以简化复杂问题，更容易做到水平扩展。 ·各层进行水平扩展：无状态水平扩容，有状态做分片路由。 业务集群通常能设计成无状态的，而数据库和缓存往往是有状态的，因此需要设计分区键做好存储分片，当然也可以通过主从同步、读写分离的方案提升读性能。[2] 用一个比喻，你想要一个人打十个人，这时候就得想办法了。第一个办法就是努力锻炼自己，然后全副武装，这就是垂直扩展；第二个办法，你一看对面人多，你叫10多个兄弟，然后你们二十个打他们十个，这就是水平扩展；此外还有第三个不常用的办法，你找个门把住，每次就放一个大汉进来，打倒一个再放下一个，这个就是削峰限流的做法。从上面举的例子容易看出，垂直维度方案比较适合业务阶段早期和成本可接受的阶段，该方案是提升性能最简单直接的方式，但是受成本与硬件能力天花板的限制。而水平维度方案所带来的好处一般在业务发展的后期才能体现出来，但是没有垂直方案的天花板问题。一旦达到一定的业务阶段，水平维度是技术发展的必由之路。 本文主要从理论层面研究水平维度上利用Nginx在web服务器上来实现一定的高并发的原理。 二、Nginx实现高并发Nginx是一款是由程序设计师Igor Sysoev所开发的高性能的 Web和 反向代理服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器，以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。很多高知名度的网站都使用 Nginx，比如：Netflix，GitHub， SoundCloud， MaxCDN 等。[4]在高连接并发的情况下，Nginx是Apache服务器不错的替代品。Nginx的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。官方测试Nginx能够支撑5万并发链接，并且CPU、内存等资源消耗却非常低，运行非常稳定。Nginx的主要着眼点就是其高性能以及对物理计算资源的高密度利用，因此其采用了不同的架构模型。受启发于多种操作系统设计中基于“事件”的高级 处理机制，Nginx采用了模块化、事件驱动、异步、单线程及非阻塞的架构，并大量采用了多路复用及事件通知机制。在Nginx中，连接请求由为数不多的几个仅包含一个线程的进程worker以高效的回环(run-loop)机制进行处理，而每个worker可以并行处理数千个的并发连接及请求。[5] （一） Nginx实现高并发的整体架构Nginx 启动时，会生成两种类型的进程，一个是主进程 （master），一个或多个工作进程（worker），因此，Nginx 启动以后，查看操作系统的进程列表，我们就能看到至少有两个Nginx进程。master进程并不处理网络请求，主要负责调度和监控工作进程，接收外部的操作（信号），服务器实际处理网络请求及响应的是工作进程，在类 unix 系统上，Nginx可以配置多个工作进程，而每个工作进程都可以同时处理数以千计的网络请求，而工作进程包括核心和功能性模块，核心模块负责维持一个运行循环，执行网络请求处理的不同阶段的模块功能，也使得我们可以根据需要对功能模块进行适当的选择和修改，编译成具有特定功能的服务器。 （二） Nginx实现高并发的模块化设计高度模块化的设计是 Nginx 的架构基础。1.核心模块：Nginx 服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、事件驱动机制、进程管理等核心功能。2.标准 HTTP 模块提供 HTTP 协议解析相关的功能。3.可选HTTP模块主要用于 扩展 标准的 HTTP 功能，让 Nginx 能处理一些特殊的服务。4.邮件服务模块主要用于支持 Nginx 的 邮件服务。5.第三方模块是为了扩展 Nginx 服务器应用，完成开发者自定义功能。Nginx服务器被分解为多个模块 ，每个模块就是一个功能模块 ，只负责自身的功能，模块之间严格遵循 “高内聚，低耦合”的原则，这有利于高并发的实现。[6] （三） Nginx实现高并发的请求方式处理Nginx结合多进程机制和异步机制中的异步非阻塞方式。服务器每当收到一个客户端时，就有服务器主进程生成一个子进程出来和客户端建立连接进行交互，直到连接断开，该子进程就结束了。使用多进程的好处是各个进程之间相互独立，不需要加锁，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。其次，采用独立的进程，如果一个进程发生异常退出时，其它进程正常工作， master进程则很快启动新的工作进程，确保服务不会中断，从而将风险降到最低。每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求以后，调用 IO 进行处理，如果不能立即得到结果，就去处理其他请求（非阻塞），而客户端在此期间也无需等待响应，可以去处理其他事情（异步）当IO返回时，就会通知此工作进程，该进程得到通知，暂时挂起当前处理的事务去响应客户端请求。Nginx 的异步非阻塞工作方式正把当中的等待时间利用起来了。在需要等待的时候，这些进程就空闲出来待命了，因此表现为少数几个进程就解决了大量的并发问题。 （四） Nginx实现高并发的进程处理模型Nginx 在启动后，会有一个主进程和多个相互独立的工作进程，主进程负责接收来自外界的信号，向各工作进程发送信号，每个进程都有可能来处理这个连接。主进程能监控工作进程的运行状态，当工作进程由于异常情况退出后，会自动启动新的工作进程。每进来一个请求，会有一个工作进程去处理。但不是全程的处理，处理到可能发生阻塞的地方，比如向上游（后端）服务器转发请求，并等待请求返回。那么，这个处理的工作不会这么傻等着，他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有请求进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，工作才会来接手，这个请求才会接着往下走。由于web server的工作性质决定了每个请求的大部份生命都是在网络传输中，实际上花费在server机器上的时间片不多，这就是为什么几个进程就解决了高并发。每个工作进程都是独立的进程，不共享资源，不需要加锁。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，主进程则很快重新启动新的工作进程。而且 Nginx为了更好的利用多核特性，提供CPU亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换 带来 Cache 的失效对于每个请求，有且只有一个工作进程对其处理。[9] （五） Nginx实现高并发的反向代理与负载均衡反向代理方式是指以代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打 10086 一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx 就是性能非常好的反向代理服务器，用来做负载均衡。而什么是负载均衡呢？随着请求数的快速增长，单服务器已经无法承担大量用户的并发访问，这个时候，就需要建立服务器集群，来让多台服务器协同工作，提高整体项目的吞吐量和QPS。假设一台设备资源占有率已经饱和，而另一台服务器却只有零星几个请求处理，这显然是不合理的。我们期望多台服务器需要平均承担客户端发来的请求，使每台机器都充分利用。这时，我们就需要用到一种技术，叫做负载均衡。负载均衡是多台服务器组合为一个集群，其中每台机器可以单独运行，服务器之间地位相同，通过负载均衡技术，将客户端发来的请求平均分配到每台服务器中，使得项目的负载能够均衡的分布，每台服务器的资源使用量也基本相同。通过负载均衡技术，使得项目巨额访问量从单台服务器均匀的分摊到每台服务器上。[10][12]Nginx对外表现为服务器, 当接受到客户端的HTTP请求时, 并不产生响应, 但也不同于Squid等其他服务器直接转发, 而是会将用户发来的请求缓存一份, 然后再通过负载均衡算法将完整的请求缓存从它的上游集群服务器中选择合适的进行转发, 而上游服务器处理请求生成的响应会直接转发给Nginx, 此时Nginx会边接受边将响应转发给客户, 而不是完整地缓存到响应再一并转发。这正是Nginx作为反向代理服务器的优势所在。[15] Nginx负载均衡主要有三种策略。 轮循（默认）：Nginx根据请求次数，将每个请求均匀分配到每台服务器 最少连接：将请求分配给连接数最少的服务器。Nginx会统计哪些服务器的连接数最少。 ·IP Hash：绑定处理请求的服务器。第一次请求时，根据该客户端的IP算出一个HASH值，将请求分配到集群中的某一台服务器上。后面该客户端的所有请求，都将通过HASH算法，找到之前处理这台客户端请求的服务器，然后将请求交给它来处理。[16][18] 负载均衡对实现高并发有很大作用。一是转发功能按照一定的算法，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。二是故障移除：通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。第三，恢复添加：如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。 通过以上分析可以发现Nginx对比apache服务器的诸多优点。 Nginx 更主要是作为反向代理，而非Web服务器使用。 Nginx是事件驱动服务器，最适合做的就是这种 I&#x2F;O 密集型工作，如反向代理。因为进程在一个地方进行计算时，那么这个进程就不能处理其他事件了。 Nginx 只需要少量进程配合事件驱动，而不像 Apache 多进程模型那样大量的进程数。 Nginx处理静态文件效果也很好，那是因为读写文件和网络通信其实都是 I&#x2F;O操作，处理过程一样。 三、总结本文介绍了高并发的各种概念以及指标，接着说明了Nginx实现高并发的一些原理，并且对比apache服务器，就Nginx在实现高并发方面的诸多优点进行了分析说明。当然本文只是在原理上做了一些分析，在实际中，高并发没有具体的标准，业务场景不一样，执行复杂度不一样，单看并发量也没有意义，必须结合具体场景进行判断。举个例子，访问百度首页通常情况下都是鼠标点击一下就看到结果了，几乎感觉不到等待时间，且百度每秒处理的访问量也非常的大，而如果支付宝扫描二维码支付，通常需要等较久的时间，这就是业务场景上的差距。再比如配置上的不同，用高配物理机得出的数据和最老最低配的虚拟器上的出来的结果是无法比较的。总之，高并发的本质不是多大算高并发的一个数字，而是从架构上、设计上、编码上怎么来保证或者解决由并发引起的问题。高并发的实际要求以及实现远远不止以上说到的内容，Nginx的实现也有更多的方法，往往要根据处理的业务场景和实际的设备以及要求做出灵活应变。 参考文献[1]冰河 海量数据处理与大数据技术实战 北京大学出版社2020-08-01[2]李运华《从零开始学架构》 2021-01-23[3]张开涛 亿级流量网站架构核心技术 电子工业出版社2017年[4]吴宝花 基于Nginx的服务器集群负载均衡策略研究与优化[D].南昌大学,2020.[5]吴翰清 《白帽子讲Web安全 》2012年电子工业出版社[6]杜星. 轻量级Web服务器Nginx的理论与技术研究[D].南京邮电大学,2016.[7]吴陈. 基于Nginx的服务器集群负载均衡策略的研究与改进[D].华南理工大学,2020.[8]刘佳祎,崔建明,智春.基于Nginx服务器的动态负载均衡策略[J].桂林理工大学学报,2020,40(02):403-408.[9]张泽宇. VPPNGX：基于FD.io VPP的高性能Nginx实现[D].上海交通大学,2020.[10]刘茜. 一种基于Nginx负载均衡软件技术实现方法[A]. 天津市电子学会、天津市仪器仪表学会.第三十三届中国（天津）2019’IT、网络、信息技术、电子、仪器仪表创新学术会议论文集[C].天津市电子学会、天津市仪器仪表学会:天津市电子学会,2019:4.[11]刘金秀,陈怡华,谷长乐.基于Nginx的高可用Web系统的架构研究与设计[J].现代信息科技,2019,3(11):94-97.[12]林丽丽.使用高性能Web服务器Nginx实现开源负载均衡[J].大众科技,2010(07):37-38+27.[13]许诺.大数据下基于Nginx负载均衡的教务系统优化设计[J].信息技术与信息化,2021(06):191-193.[14]李刚.Nginx负载均衡技术在高校教务系统中的应用[J].辽宁师专学报(自然科学版),2020,22(03):19-22+32.[15]赵凯.一种基于Nginx反向代理机制的微服务负载均衡方法分析[J].无线互联科技,2020,17(16):140-141.[16]刘旻昊.Nginx服务器“秘籍”[J].中国传媒科技,2018(04):13-14.[17]马原龙. Nginx负载均衡技术研究[D].重庆邮电大学,2016.[18]王艳,陈卫卫.基于Nginx替代Apache在高并发WEB负载均衡系统中的应用[J].电子测试,2015(06):88-92.[19]Castien René F,Coppieters Michel W,Durge Tom S C,ScholtenPeeters Gwendolyne G M. High concurrent validity between digital and analogue algometers to measure pressure pain thresholds in healthy participants and people with migraine: a cross-sectional study.[J]. The journal of headache and pain,2021,22(1):[20]Wang Ling. Design and Implementation of Online Exam Platform Based on High-Concurrency Processing Mode[J]. International Journal of Computational and Engineering,2021,6(2):[21]赵俊哲. 网络流量高并发优化处理研究[D].南京邮电大学,2020.","tags":[],"categories":[{"name":"论文研究","slug":"论文研究","permalink":"https://pistachiout.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"}]},{"title":"","date":"2023-02-15T01:58:28.039Z","path":"wiki/软件项目/JavaWeb项目/支付宝支付模拟demo/","text":"1.实验环境1.利用沙箱环境模拟支付宝支付的实验，首先配置沙箱环境，下载官方DEMO，环境配置，生成公钥和私钥的工具类，使用RSA签名验签工具生成公钥和私钥，配置环境运行。 2.支付流程图： 3.支付宝支付实现-代码：支付设置-商户方： 支付设置-支付宝服务端： 将订单整合修改成为账单向支付宝发送请求： 同步通知接口： 异步通知接口： 4.运行截图","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:52:49.664Z","path":"wiki/软件项目/小型项目/C++状态模式，建造者模式，观察者模式，单例模式，备忘录模式实现超市购物/","text":"一、设计内容及要求 .该课程设计的基本目标：1.掌握系统分析与设计的基本概念和方法。2.掌握23种设计模式的基本概念。3.掌握设计模式的常用方法和C++语言的编程实现。4.了解在软件开发过程中所面临的问题的最佳解决方案，通过一种简单快捷的方式来学习软件设计。 该课程设计要求开发一个小型的应用程序，其内容来源于：1.对于该课程的相应的实验报告的内容的扩展。2.本科学习阶段开发过的系统的重要部分的改造或代码重构。3.设计者自己全新构造的小系统。 该课程设计的主要要求：1.要求设计的小系统包含至少3个该课程中提及的设计模式。2.设计的小系统包含简单的应用界面。系统开发的程序设计语言不限。 二、系统的主要目标与功能在本次设计中，考虑到目前超市都流行在线购物，于是我设计了一个超市在线网上购物的系统，这个系统的主要目标是帮助人们在家里购买自己需要的套餐，充值账户，同时该系统能查看自己的历史金额变动记录，也能够撤销前一次购买或充值，这样能够帮助没有时间的人们快速购物，也能够减少疫情期间出门购物的可能带来的危害。本超市目前功能如下 查看超市套餐 购买超市套餐” 给账户充值 查看历史余额记录 撤回上次存款或消费 退出本超市在线购物系统 三、系统中使用的设计模式（详细描述场景、解决的问题、模式的效果及意义）•1.状态模式：状态模式在购物时提供用户信息和余额的信息，允许购买后余额少于0，但当余额少于0后不能购买。在进入程序时便初始化账户，通过这个账户记录余额信息，同时考虑到余额不足时不能购物，考虑到方便，设计余额不足购买时允许赊欠，但当前余额小于0时不能购物，这样是考虑到实际，余额小于0时是不能购买的，因此使用状态模式。 •2.建造者模式：建筑者模式用于构建不同的购买套餐，帮助快速购买，并且使客户便于查看各个套餐的内容与价格便于购买。 •3.观察者模式：在进入系统时会有弹窗信息提醒客户套餐的信息，并提醒客户注意财产安全，这样是考虑到现实中大部分应用都会在初次使用时提醒使用者。 •4.单例模式：只允许创建一个超市类，且该超市类是建造者模式的指挥者，指挥套餐的建立。 •5.备忘录模式：记录在系统中的余额变动历史记录，并可以撤销上一次余额变动的操作，在现实中大部分购物应用都可以查看历史记录与撤销，因此利用备忘录模式实现该操作，便于观察余额变化。 项目源码：https://github.com/1105358600/DesignPattern","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:52:39.327Z","path":"wiki/软件项目/小型项目/芯片+步进电机档位控制实验/","text":"1、系统功能目的：学习步进电机的控制。使用设备：步进电机、两位共阴数码管、按键功能：驱动步进电机以不同转速（4档）转动，并将当前档位用数码管显示(1)按键 KEY1 作为启动和停止的切换按键；(2)按键 KEY2 加速键。(3)最开始按下 KEY1 ，系统以默认的最低档位（1档最低，4档最高）启动电机转动；(4)每按一次 KEY2 ，电机转速提升一档。提到最高4档后，自动降到最低的1档。(5)数码管显示当前的档位。(6)电机处于停止状态时，数码管显示0。 2、硬件结构本课程实验主控芯片选择的是STM32F103ZET6作为MCU，该芯片是STM32F103里面配置非常强大的了,它拥有的资源包括：64KB SRAM、 512KB FLASH、2个基本定时器、4个通用定时器、2个高级定时器、2个DMA控制器（共12个通道）、3个SPI、2个IIC、5个串口、1个USB、1个CAN、3个12位ADC、1个12位DAC、1个SDIO接口、1个FSMC接口以及112个通用IO口。该芯片的配置十分强悍，并且还带外部总线（FSMC）可以用来外扩SRAM和连接LCD等，通过FSMC（可变静态存储控制器）驱动LCD，可以显著提高LCD的刷屏速度。 3、主要外设本项目用到的主要外设为步进电机与两位共阴数码管，其中步进电机由ULN2003芯片控制。ULN2003是高耐压、大电流达林顿阵列，由七个硅NPN达林顿管组成。ULN2003的每一对达林顿都串联一个2.7K的基极电阻,在5V的工作电压下它能与TTL和CMOS电路直接相连，可以直接处理原先需要标准逻辑缓冲器来处理的数据。ULN2003工作电压高，工作电流大，灌电流可达500mA，并且能够在关态时承受50V的电压，输出还可以在高负载电流并行运行。步进电机的驱动采用1-2相励磁法：1相和2相轮流交替导通，精度较高，且运转平滑。每送一个励磁信转动二分之一标称角度。有称为半步驱动。4相电机中，1、2种方式称4相4拍，3种称4相8拍。1-2相励磁法如下图所示，即采用A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA的方式陆续为线圈通电。 共阴数码管是指八段数码管的八段发光二极管的阴极（负极）都连在一起，而阳极对应的各段分别控制。 4、设计思路4.1硬件设计原理IN1(连接在PF0),IN2(连接在PF1),IN3(连接在PF2),IN4(连接在PF3)驱动板电源负极连接开发板GND，正极连接开发板5v。连接如下图所示（连线紧密，请根据杜邦线颜色来判断） 数码管的连接如下图所示。1接PD3，2接PC8,3接PG13,4接PG7,5接PG11,6接PD6,7接PA8,8接PC7,9接PC6,10接PC9。 模块本身的连接方式如下图所示。 4.2软件设计流程实验代码 首先步进电机的工作原理实际上是电磁铁的作用原理。是将电脉冲信号转变为角位移或线位移的开环控制步进电机元件，通过控制施加在电机线圈上的电脉冲顺序、频率和数量，可以实现对步进电机的转向、速度和旋转角度的控制，配合以直线运动执行机构或齿轮箱装置，更可以实现更加复杂、精密的线性运动控制要求。 共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极的数码管，共阴数码管在应用时应将公共极COM接到地线GND上，当某一字段发光二极管的阳极为高电平时，相应字段就点亮，当某一字段的阳极为低电平时，相应字段就不亮。 在整体流程上，通过芯片上的按键控制步进电机的转速与数码管的显示，按键 KEY1 作为启动和停止的切换按键，按键 KEY2 用来增大步进电机工作档位，故在软件设计时，首先要根据这些硬件设施设置对应的模块，包括对应的按键模块key.h与key.c用来读取是否进行按键操作，还有数码管对应的模块led.h与led.c来处理按键后的数码管，与最后的步进电机的模块motor.h与motor.c来处理步进电机的转动速度。 在key模块中，主要靠KEY_Init()与KEY_Scan（）函数实现控制， 其中KEY_Scan（）用来进行按键处理，若检测到按键KEY1或KEY2，则赋值KEY0_PRES与KEY1_PRES。 在led模块中，使用LED_Init函数，通过GPIO_Initure()与HAL_GPIO_WritePin()对控制数码管各部分亮灭的每个引脚进行初始化。 在motor.c模块中，通过Motor_Init（）函数对控制A、B、C、D四个线圈的PF0、PF1、PF2、PF3进行初始化。 在main.c模块中，采用1-2相励磁法驱动步进电机，1相和2相交替导通。在本系统中分别由PF0、PF1、PF2和PF3分别来控制线圈A、B、C、D的通电，因此采用如下方法通过对四个引脚的状态的控制，分别按A→AB→B→BC→C→CD→D→DA的顺序对线圈进行充放电从而产生电流驱动步进电机。通过HAL_Delay（）进行对电机转机转速的控制，针对不同档位采用大小不同的参数speed，档位越低speed值越大，从而在每一轮次对线圈进行充放电的过程中延迟更长的时间。通过open和level两个参数来控制步进电机的是否工作与其工作档位。当按下KEY1键时，KEY0_PRES响应，此时先判断open的值，若open为1则置0；若open为0则置1且level默认为1。当按下KEY2键时，KEY1_PRES响应，此时先判断level的值，再使其加一，当level为4时将其置为1，再通过HAL_GPIO_WritePin()函数控制引脚从而控制数码管各部分的亮灭，使得数码管能够显示对应档位的数字。 5、软件开发环境5.1软件开发环境安装和配置开发工具为RT-Thread Studio。访问官网https://www.rt-thread.org/page/studio.html，在官网下载最新的 RT-Thread Studio 软件安装包。使用MCUISP工具配合开发板上的下载电路可实现串口下载，此外还需下载CH340驱动。5.2工程文件的目录结构和文件本工程文件共分为4个模块，包括对应的按键模块key.h与key.c用来读取是否进行按键操作，还有数码管对应的模块led.h与led.c来处理按键后的数码管，与最后的步进电机的模块motor.h与motor.c来处理步进电机的转动速度，然后还有main.c文件，以进入主函数。 首先打开RT-Thread Studio，导入我们建好的裸板模板工程 Template，之后将工程文件中的.h头文件与.cpp文件复制，粘贴到创建的工程下的applications文件夹内，点击按下图进行配置，使编译生成.hex 文件。 然后点击构建按钮完成编译构建，之后打开MCUISP下载到电路板上，在电路板上进行测试。 6、运行和测试项目总体的接线情况如下： 上电后，首先数码管显示为0，步进电机尚未工作。 首先按下KEY1按键，此时系统以默认的最低档位1档开始工作，数码管数字显示为1，步进电机开始工作，旋转速度为1档，较慢。 再按下KEY2按键，此时数码管数字显示为2，步进电机旋转速度提升至2档。 此时，连续两次按下KEY2按键，此时数码管数字显示先升到3再升到4，步进电机旋转速度提升至4档，为最高档。 再次按下KEY2按键后，数码管数字显示变为1，步进电机旋转速度降至1档。 最后按下KEY1按键，数码管数字显示变为0，步进电机停止工作。","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:52:24.879Z","path":"wiki/软件项目/小型项目/C++重载实现m_n_k三维矩阵，且矩阵元素为复数/","text":"1.实验要求 设计实现三维（3D）矩阵A[i] [j] [k]，支持矩阵运算符+，[]，&#x3D;等运算符重载，并完成结果展示 矩阵中元素为复数类型 2.代码展示1.complex类1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; using namespace std; class Complex &#123; public: Complex() &#123; real=0; imag=0; &#125; Complex(double r,double i) &#123; real=r; imag=i; &#125; friend Complex operator+(Complex &amp;c1, Complex &amp;c2) &#123; Complex c; c.real=c1.real+c2.real; c.imag=c1.imag+c2.imag; return c; &#125; friend Complex operator-(Complex &amp;c1, Complex &amp;c2) &#123; Complex c; c.real=c1.real-c2.real; c.imag=c1.imag-c2.imag; return c; &#125; /*Complex &amp;Complex::operator=(const Complex &amp;c1) &#123; Complex* c; c-&gt;real=c1.real; c-&gt;imag=c1.imag; return c; &#125; */ void display()&#123; cout&lt;&lt;&quot;(&quot;&lt;&lt;real&lt;&lt;&quot;,&quot;&lt;&lt;imag&lt;&lt;&quot;i)&quot;; &#125; double real; double imag; &#125;; 2.二维矩阵Martix_22类，矩阵元素为Complex类型12345678910111213141516#include&lt;iostream&gt;#include&lt;stdlib.h&gt;// 用于退出程序#include &quot;Complex.cpp&quot;using namespace std;class Matrix// 设立一个矩阵类&#123;public: int row,col; Complex *p;// 用来储存矩阵元素 Matrix(); Matrix(int r,int c); Matrix(const Matrix &amp;m); void disp();//展示矩阵 friend Matrix operator + (const Matrix &amp;am,const Matrix &amp;bm);// 加法运算符的重载 Matrix &amp; operator = (const Matrix &amp;a);// “=”运算符的重载&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&quot;Martix_22.h&quot;Matrix::Matrix()&#123; row=1; col=2; p=new Complex();&#125;Matrix::Matrix(int r,int c):row(r),col(c)&#123; int i=r*c; this-&gt;row=r; this-&gt;col=c; p=new Complex(); for(int a=0;a&lt;i;a++) &#123; p[a]=*new Complex(); cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素实部：&quot;&lt;&lt;endl; cin&gt;&gt;p[a].real; cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素虚部：&quot;&lt;&lt;endl; cin&gt;&gt;p[a].imag; &#125;&#125; Matrix::Matrix(const Matrix &amp;m)// 当加法运算符重载函数被调用时，会调用复制构造函数，由于数据成&#123; // 员有指针，因此为了防止析构函数调用时发生错误，设立一个复制构 // 造函数 row=m.row; col=m.col; int len=col*row; p=new Complex[len]; for(int i=0;i&lt;len;i++) &#123; p[i]=m.p[i]; &#125;&#125;void Matrix::disp()&#123; for(int i=0;i&lt;row;i++) &#123; cout&lt;&lt;&#x27;\\t&#x27;; for(int j=0;j&lt;col;j++) p[i*col+j].display(); cout&lt;&lt;endl; &#125;&#125;Matrix operator + (const Matrix &amp;am,const Matrix &amp;bm)&#123; if(am.row==bm.row&amp;&amp;am.col==bm.col) &#123; int i,j; Matrix temp(am); i=am.row*am.col; for(j=0;j&lt;i;j++) &#123; temp.p[j]=am.p[j]+bm.p[j]; &#125; return temp; &#125; else &#123; cout&lt;&lt;&quot;++++program terminated!&quot;&lt;&lt;endl; exit(1); &#125;&#125;Matrix &amp; Matrix::operator = (const Matrix &amp;bm)&#123; if((row==0)&amp;&amp;(col==0)) &#123; if(p) delete p; row=bm.row; col=bm.col; int len=bm.row*bm.col; p=new Complex[len]; for(int i=0;i&lt;len;i++) &#123; p[i]=bm.p[i]; &#125; return *this; &#125; else if((row==bm.row)&amp;&amp;(col==bm.col)) &#123; for(int i=0;i&lt;row*col;i++) &#123; this-&gt;p[i]=bm.p[i]; &#125; return *this; &#125; else if((row!=bm.row)||(col!=bm.col)) &#123; for(int i=0;i&lt;row*col;i++) &#123; this-&gt;p[i]=bm.p[i]; &#125; return *this; &#125;&#125; 3.三维矩阵类，包含二维矩阵的数组1234567891011121314151617#include&lt;iostream&gt;#include&lt;stdlib.h&gt;// 用于退出程序#include &quot;Martix_22.h&quot;using namespace std;class Matrix_33// 设立一个矩阵类&#123;public: Matrix *res; int h,row,col; Matrix_33(); Matrix_33(int r,int c,int h); Matrix_33(const Matrix_33 &amp;m); void disp();//展示矩阵 friend Matrix_33 operator + (const Matrix_33 &amp;am,const Matrix_33 &amp;bm);// 加法运算符的重载 Matrix_33 &amp; operator = (const Matrix_33 &amp;a);// “=”运算符的重载 Matrix &amp; operator [] (int i);// []运算符的重载&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&quot;Martix_33.h&quot;Matrix_33::Matrix_33()&#123; this-&gt;h=2; this-&gt;row=1; this-&gt;col=2; this-&gt;res=new Matrix();&#125;Matrix_33::Matrix_33(int r,int c,int h)&#123; this-&gt;h=h; this-&gt;row=r; this-&gt;col=c; res=new Matrix(); for(int j=0;j&lt;h;j++) &#123;cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;j+1&lt;&lt;&quot;个二维矩阵：&quot;&lt;&lt;endl; res[j].row=r; res[j].col=c; res[j].p=new Complex(); res[j]=*new Matrix(); res[j].row=r; res[j].col=c; res[j]=*new Matrix(r,c); /*res[j].row=r; res[j].col=c; int i=r*c; res[j].p=new Complex(); for(int a=0;a&lt;i;a++) &#123;cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素实部：&quot;&lt;&lt;endl; cin&gt;&gt;res[j].p[a].real; cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素虚部：&quot;&lt;&lt;endl; cin&gt;&gt;res[j].p[a].imag; &#125;*/ res[j].disp(); &#125;&#125;Matrix_33::Matrix_33(const Matrix_33 &amp;m_33)// 当加法运算符重载函数被调用时，会调用复制构造函数，由于数据成&#123; // 员有指针，因此为了防止析构函数调用时发生错误，设立一个复制构造函数 h=m_33.h; row=m_33.row; col=m_33.col; res=m_33.res; if(!res)// 当指针未被赋值时，指针被赋予随机数，或当指针被赋值后，通过此语句指针也可以被删除调 delete res;// 空间,从而去使用新的空间 for(int j=0;j&lt;h;j++) &#123; res[j].row=row; res[j].col=col; res[j].p=new Complex(); res[j]=m_33.res[j]; &#125; &#125;void Matrix_33::disp()&#123; for(int j=0;j&lt;h;j++) &#123; cout&lt;&lt;&quot;该三维矩阵的第&quot;&lt;&lt;j+1&lt;&lt;&quot;个&quot;&lt;&lt;row&lt;&lt;&#x27;*&#x27;&lt;&lt;col&lt;&lt;&quot;阶二维矩阵:&quot; &lt;&lt;endl; for(int i=0;i&lt;row;i++) &#123; for(int c=0;c&lt;col;c++) &#123; cout&lt;&lt;&#x27;\\t&#x27;; res[j].p[i*col+c].display(); &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125; &#125;Matrix_33 operator + (const Matrix_33 &amp;am,const Matrix_33 &amp;bm)&#123; if(am.h==bm.h) &#123; Matrix_33 temp; temp.h=am.h; temp.row=am.row; temp.col=am.col; temp.res=new Matrix(); for(int j=0;j&lt;am.h;j++) &#123; temp.res[j].row=am.res[0].row; temp.res[j].col=am.res[0].col; temp.res[j].p=new Complex(); cout&lt;&lt;&quot;第&quot;&lt;&lt;j&lt;&lt;&quot;个二维矩阵&quot;&lt;&lt;endl; /*temp.res[j].p-&gt;real=am.res[j].p-&gt;real+bm.res[j].p-&gt;real; temp.res[j].p-&gt;imag=am.res[j].p-&gt;imag+bm.res[j].p-&gt;imag;*/ for(int i=0;i&lt;temp.row;i++) &#123; for(int c=0;c&lt;temp.col;c++) &#123; temp.res[j].p[i*temp.col+c]=*new Complex(); temp.res[j].p[i*temp.col+c]=am.res[j].p[i*temp.col+c]+bm.res[j].p[i*temp.col+c]; temp.res[j].p[i*temp.col+c].display(); &#125; cout&lt;&lt;endl; &#125; &#125; return temp; &#125;&#125;Matrix &amp; Matrix_33::operator [] (int i)&#123; return this-&gt;res[i];&#125;Matrix_33 &amp; Matrix_33::operator = (const Matrix_33 &amp;bm)&#123; h=bm.h; row=bm.row; col=bm.col; this-&gt;res=new Matrix(); &#123; for(int j=0;j&lt;h;j++) &#123; this-&gt;res[j].row=bm.res[j].row; this-&gt;res[j].col=bm.res[j].col; this-&gt;res[j].p=new Complex(); for(int i=0;i&lt;row*col;i++) &#123; this-&gt;res[j].p-&gt;real=bm.res[j].p-&gt;real; this-&gt;res[j].p-&gt;imag=bm.res[j].p-&gt;imag; &#125; &#125;&#125;&#125; 4.main函数12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include &quot;Martix_33.h&quot;using namespace std;int main()&#123; int h,row,col; cout&lt;&lt;&quot;请输入三维矩阵的行数和列数和高:&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col&gt;&gt;h; cout&lt;&lt;&quot;请输入三维矩阵A:&quot;&lt;&lt;endl; Matrix_33 am(row,col,h); cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; am.disp(); cout&lt;&lt;&quot;请输入三维矩阵B:&quot;&lt;&lt;endl; Matrix_33 bm(row,col,h); cout&lt;&lt;&quot;B:&quot;&lt;&lt;endl; bm.disp(); int i; Matrix_33 cm; cout&lt;&lt;&quot;C=A+B:&quot;&lt;&lt;endl; cm=am+bm; cout&lt;&lt;&quot;请输入i显示B[i]，即第i个二维矩阵:&quot;&lt;&lt;endl; cin&gt;&gt;i; bm[i].disp(); return 0;&#125; 3.实验截图初始化A，B矩阵，可自由设定三维矩阵的行，列，高，以及对应元素的虚部实部重载+，[]，&#x3D;运算符，输出3D矩阵C&#x3D;A+B以及B[i]","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:52:14.030Z","path":"wiki/软件项目/小型项目/C++设计模式实践——线上购物系统/","text":"一、系统的主要目标与功能 &amp;emsp; 在本次设计中，考虑到目前疫情反复不断，为了方便群众，超市都推出在线购物并有配送员送货，于是我设计了一个超市在线网上购物送货的系统，这个系统的主要目标是帮助人们在家里购买自己需要的套餐，充值账户，同时该系统能查看自己的历史金额变动记录，也能够撤销前一次操作，这样能够帮助疫情期间的人们快速购物，也能够减少疫情期间出门购物的可能带来的危害。本超市目前功能如下： 查看超市套餐 购买超市套餐 给账户充值 查看历史余额记录 撤回上次操作 系统自动提示配送员 退出本超市在线购物系 系统运行比较简单，且每一步完成后都会有提示信息，按照提示信息一步一步运行即可。 二 、系统中使用的设计模式（UML类图、详细描述场景、解决的问题、模式的效果及意义） •1.状态模式： &amp;emsp;对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。在一个对象内在状态改变时也改变了其行为，这个对象看起来像改变了其类，因此选择使用状态模式。• &amp;emsp;•设计思路：在本系统中，状态模式在购物时提供用户信息和余额的信息，分别为正常状态GreenState，欠款状态RedState与会员VIP状态。在进入程序时便初始化账户Account，通过这个账户记录余额balance信息，同时考虑到余额不足时不能购物，考虑到特殊情况，设计余额不足购买时允许赊欠，但当前余额小于0时不能购物，这样是考虑到实际，余额小于0时是不能购买的；此外若充值后余额超过1000元，则当前状态变为VIP模式，之后购买商品可以有8折优惠。 &amp;emsp;程序设计：Account中有属性state来聚合AccountState记录当前Account的状态，且有RedState，GreenState，VIP三个子状态继承AccountState，AccountState中有balance余额属性，在每个子状态里面有stateCheck()函数，可以在调用该函数后判断balance的数值，来改变当前Account所处的状态，并在改变状态后改变消费的行为。Accout有函数deposit和withdraw，分别是存款和取款来对balance进行操作，并会根据属性state的不同有不同的行为。 &amp;emsp;Account中有属性msStrategy，这是与策略模式结合的属性，在代码中设计的为若状态为GreenState或RedState，即初试化为MessageStrategy2直接在窗口输出，若为VIP状态，则初试化为MessageStrategy1，产生MessageBox弹窗通知。 •2.建造者模式 &amp;emsp;建筑者模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示。• &amp;emsp;设计思路：在本系统中建造者模式可用于构建不同的套餐1，套餐2，套餐3，由超市Supermarket作为指挥者，将套餐的内部表象与生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象Product，并且使客户便于查看各个套餐的内容与价格便于购买。 &amp;emsp;程序设计：首先Supermarket是系统中建造者模式的Director指导者，拥有Construct()函数，且拥有Builder类的bld属性，使用Construct（）即可调佣bld中的BuildPartA，B，C函数，来构建出Product产品类，从而返回Product完成建造，将Product的复杂构造在ConcreteBuilder内实现，而Supermarket只需要设置不同的bld属性和调用Construct（）函数，即可创建不同的产品，实现产品构建的封装。 •3.观察者模式 &amp;emsp;观察者模式建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。 &amp;emsp;设计思路：在本系统中，观察者模式的观察目标为商家系统Supermarket，具体观察者为配送员DeliveryObserver，多个配送员DeliveryObserver观察对应的商家系统Supermarket，当有客户在商家购买套餐时，商家系统会发出通知提醒观察了自己的配送员。 &amp;emsp;程序设计：在Supermarket中有Attach()和Detach()两个函数与list&lt;DeliveryObserver*&gt;accs即 DeliveryObserver的一个列表，Attach()来增加配送员Observer为观察者，Detach()删除观察者Observer，然后在消费者进行购物后，通过调用notify（）函数来进行通知，且Observer中具体的notify（）函数与策略模式相结合，对于list中的单数采用MessageStrategy1通知，list采用MessageStrategy2来通知。 •4.单例模式 &amp;emsp;单例类只有一个实例对象，且该单例对象必须由单例类自行创建，单例类对外提供一个访问该单例的全局访问点。• &amp;emsp;设计思路：在本系统中，单例类为商家类，只允许创建一个商家类，且该商家类是建造者模式的指挥者，指挥套餐的建立。 &amp;emsp;程序设计：在Supermarket里面，有私有静态的Supermarket类属性_instance，然后将构造函数定义为保护函数防止外界调用，在调用构造函数时判断_instance是否为空，若为空则可初始化，否则返回_instance。 •5.策略模式 &amp;emsp;该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式的主要目的是将算法的定义与使用分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。 &amp;emsp;设计思路：本系统中，策略模式在观察者模式的基础上使用，在观察者模式通知Observer时，通知方式可选择不同的策略，如短信通知或软件信息通知等，在本系统中选择弹窗通知MessageStrategy1与直接输出通知MessageStrategy2来模拟这两种不同的通知方式。 &amp;emsp;此外，策略模式与状态模式也有在一起联合使用，若Account目前状态为GreenState或RedState，即初试化为MessageStrategy2直接在命令行窗口输出，若为VIP状态，则初试化为MessageStrategy1，产生MessageBox弹窗通知。 &amp;emsp;程序设计：MessageStrategy有两个子类，分别为MessageStrategy1与MessageStrategy2，MessageStrategy1即采用MessageBox进行弹窗输出，而MessageStrategy2即为cout直接输出，使用时可具体不同的策略类来实现不同的通知方式 •6.备忘录模式 &amp;emsp;在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。 &amp;emsp;设计思路：在本系统中，备忘录模式记录在系统中的余额变动，并可查看所有的历史变动记录，并可以撤销上一次余额变动的操作，在现实中大部分购物应用都可以查看历史记录与撤销，因此利用备忘录模式实现该操作，便于观察余额变化。 &amp;emsp;程序设计：首先通过UserInfoDTO来在主函数中将每次余额改变时的balance即state记入Memento，然后利用Caretaker中的mementoList来记录每次余额改变后的Memento值。在查看历史记录时，即调用UserInfoDTO的getStateFromMemento()函数来遍历mementoList所有记录的历史余额；在想要进行撤销操作时，即首先调用user.getStateFromMemento（）获取最近一次操作后的余额值，之后调用p-&gt;setbalance(user.getState())将余额记录到Account账户中，且对于第一次操作与第0次操作有不同的撤销行为。 三、系统运行截图 &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; 四、设计模式总结 &amp;emsp; 本次实践作业我使用了一些比较常见的设计模式，包括状态模式，单例模式，建造者模式，观察者模式，策略模式，备忘录模式。我个人认为在设计模式的使用有两个亮点。 &amp;ensp;第一个亮点就是策略模式与观察者模式与状态模式联合使用，而不是将策略模式进行单一的使用。这个想法是我在进行观察者模式设计时，发现观察者模式的通知功能可以有不同的策略实现后做出的模式设计。我将策略模式与观察者模式与状态模式联合使用，对于不同的观察者，不同的状态时会有不同的行为，因此我将策略模式融合到这两种模式中，这也是对于设计模式的一种深入使用，而不仅仅是生硬的套用。在本次实践中，。 &amp;ensp; 第二个亮点是备忘录模式的使用，我个人认为备忘录模式的理解和代码设计都有一定的难度，在实践过程中也确实遇到了一些困难如Caretaker和Memento的区别，以及如何存和取历史数据，但经过认真学习进行了解决。 &amp;ensp; 通过使用这些设计模式，代码对修改有了封闭性，在客户端没有具体实现，难以修改，而在进行扩展时更加容易，如对于策略模式，如果想要添加一个新的策略实现不同的通知方式，只需要增加一个策略实现的子类MessageStrategy3即可实现策略添加。 五、个人的模式学习心得 &amp;emsp;在本次面向对象与系统建模的课程学习中，我个人认为收获良多，与本科学习过的设计模式相比学到了更多与更加深入，首先是因为研一与本科学习时相比自己做过的项目与见过的代码更多，更加理解了为什么要运用设计模式来进行代码封装与复用，如何使用设计模式来更好的扩展代码，为什么设计代码时要满足开闭原则等多项原则。（而不像是本科学习时觉得进行这些设计模式的使用没有用处，反而让人看不懂代码具体逻辑）。&amp;emsp;此外，也正是提前了解到了设计模式的重要性，我学习的兴趣也更加浓厚，因此我除了在上课时的学习，还购买了《大话设计模式》进行课外学习，同时参加了软件设计师的考试，于是我对设计模式的复用性有了更深入的了解，对于重要的模式如观察者模式、状态模式、工厂模式，适配器模式等理论方面有了更加深入的理解，对于每种设计模式的UML类图也更加理解，对于该在哪种应用场景来使用某种设计模式、如何用代码实现这些模式也更加明确，对一些不太常见的模式如原型模式，访问者模式也了解更多，更加理解了设计模式对于修改封闭，扩展开放的好处，对于迪米特法则、单一职责原则等更加理解。 六、意见和建议 &amp;emsp;个人认为对于设计模式的学习不能追求通过上课来速成，要在自己进行代码编写的过程中以及后续代码修改过程中才能深入理解设计模式的重要性。&amp;emsp;因此对于学习过程中建议可以不用课本，直接用能够运行的使用了2-3个设计模式的简单项目，并编写2个不同的代码，一个没有使用设计模式的代码，一个使用了设计模式代码，首先演示让同学们了解代码的作用，然后平时作业可以让同学们分别对两种代码进行扩展，如对于状态模式，可以让学生对两种代码都加一种状态，这样可能比对着书本更容易理解设计模式的作用，而在期末作业上也可以要求同学们对于上课时的简单项目进行扩展，如多加几个设计模式。 七、main函数与抽象类代码 &amp;emsp;Main函数：可以看到在Main函数与抽象类中没有看到具体的实现代码，仅仅只有函数的调用，因此基本满足开闭原则，扩展性良好，想要扩展时仅仅只需要增加子类。 .","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"Hello World","date":"2023-02-14T01:15:19.740Z","path":"wiki/index/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]}],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"},{"name":"Linux项目","slug":"软件项目/Linux项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Linux%E9%A1%B9%E7%9B%AE/"},{"name":"实用工具","slug":"实用工具","permalink":"https://pistachiout.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"论文研究","slug":"论文研究","permalink":"https://pistachiout.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"}],"tags":[]}
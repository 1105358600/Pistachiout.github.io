{"pages":[],"posts":[{"title":"","date":"2023-02-15T03:03:01.059Z","path":"wiki/软件项目/小型项目/程序设计说明-罗琪源-M202276666/","text":"一、需求分析​ 设计一个简单的考试系统，可进行C++与Java的考试，考生姓名、考生学号、C++题目、Java题目、C++答案，Java答案分别存入..&#x2F;txt文件数据&#x2F;路径下的StudentsName、StudentsNum、QuestionC，QuestionJ、AnswerC、AnswerJtxt文件中，进入系统后输入学号验证并进入考试，系统将自动给选择题和填空题进行对错判断并给分，最后求出选择与填空题的考试总分并存入..&#x2F;txt文件数据&#x2F;Score.txt，而简答题与编程题则写入..&#x2F;txt文件数据&#x2F;路径下的shortAnswerC.txt&#x2F;shortAnswerJ.txt与programmingC.txt &#x2F;programming.txtJ文件供老师打分。 二、逻辑流程 ​ 图1：考试系统流程图 三、考试类设计 图2：考试系统类图 ① 学生类Student学生类包括学生姓名与学号，学号用于登录系统并认证身份，学生姓名则用于记录选择题与填空题分数以及简答编程的答案。方法包括InitStudent（）初始化考生与Register（）登录考试。 ② 问题基类QandA问题基类，属性包括问题，答案与对应的分数，而方法则包括： 虚函数InitQandA（）用来初始化考题，答案以及分数，本系统只是模拟，故对于每道题初始默认为10分的分值， choice（），fillIn（），shortAnswer（），programming（）等函数表示对于考题中的选择题，填空题等题型进行处理函数，其中shortAnswer（），programming（）为虚函数。 虚函数Exam（）,采用了模板方法模式，由于对于Java与C++考试时shortAnswer（），programming（）函数有细微的差别，但算法大致的逻辑一样，故将某些步骤推迟到子类，有助于算法的扩展。 ③ C++考试类QandACC++考试类，若选择C++考试则执行该类的方法 InitQandA（）用来初始化C++考题，答案以及分数， choice（），fillIn（），shortAnswer（），programming（）等函数表示对于C++考题中的选择题，填空题等题型进行处理函数，并写入.&#x2F;txt文件数据&#x2F;路径下的Score.txt、shortAnswerC.txt与programmingC.txt文件。 Exam（）将 choice（），fillIn（），shortAnswer（），programming（）统一调用，完成C++考试，programming（）在输入为“end”时表示代码编写结束。 ④ Java考试类QandAJJava考试类，若选择Java考试则执行该类的方法 1.InitQandA（）用来初始化Java考题，答案以及分数， 2.choice（），fillIn（），shortAnswer（），programming（）等函数表示对于Java考题中的选择题，填空题等题型进行处理函数，并写入.&#x2F;txt文件数据&#x2F;路径下的Score.txt、shortAnswerJ.txt与programmingJ.txt文件。 3.Exam（）将 choice（），fillIn（），shortAnswer（），programming（）统一调用，完成Java考试，programming（）在输入为“end”时表示代码编写结束。 四、考试截图① 用户登录 为方便老师测试，学号可输入为1 ② 选择考试课目C++** ** ③ 选择考试课目为Java** ** ④ 选择题 ⑤ 填空题作答 ⑥ 简答题作答** ** ⑦ 编程题作答** ** ⑧ 分数统计** ** ⑨ 考试结束** ** ⑩ 简答题答案文件检查** ** ⑪ 编程题文件检查作答** ** 五、总结本次实验我对于系统的功能性需求已基本全部实现，如选择判断自动判分，且分数与简答编程答案计入txt文件供后续老师判分。但由于我此前的学习没有深入C++以及QT可视化等方面的知识，对于非功能性需求没有特别突出的地方，如可视化方面、数据持久化方面没有亮点，但也尽量用到了自己学习过的知识，如在设计时进行类图设计，并考虑到了设计模式如模板方法的使用，并在代码注释方面也应有尽有。此外对于编程题也有改进的空间，虽然本系统中可以进行换行，但会消耗考生做题的时间。","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:24:24.922Z","path":"wiki/计算机基础知识/数据库/LeetCode1179. 重新格式化部门表，使用group by与case聚合处理/","text":"解题思路聚合函数本质上就是常见编程语言里的reduce，也就是把一组数据处理成一个单一数据，所以可以这样写： 123select id, sum(revenue) as totalfrom Departmentgroup by id 来表示一个部门的总收入。 这个操作在javascript中类似于这样： 1departments.reduce(total, department =&gt; total + department.revenue) max等其它聚合函数同理，都可以找到用reduce表示的等价形式。 那么代码 1sum(case month when &#x27;Jan&#x27; then revenue end) as Jan_Revenue, 的意思就是说把所有的revenue聚合处理，处理的方法是，如果month的值是Jan，那么结果就是revenue，否则忽略。 代码123456789101112131415select id, sum(case month when &#x27;Jan&#x27; then revenue end) as Jan_Revenue, sum(case month when &#x27;Feb&#x27; then revenue end) as Feb_Revenue, sum(case month when &#x27;Mar&#x27; then revenue end) as Mar_Revenue, sum(case month when &#x27;Apr&#x27; then revenue end) as Apr_Revenue, sum(case month when &#x27;May&#x27; then revenue end) as May_Revenue, sum(case month when &#x27;Jun&#x27; then revenue end) as Jun_Revenue, sum(case month when &#x27;Jul&#x27; then revenue end) as Jul_Revenue, sum(case month when &#x27;Aug&#x27; then revenue end) as Aug_Revenue, sum(case month when &#x27;Sep&#x27; then revenue end) as Sep_Revenue, sum(case month when &#x27;Oct&#x27; then revenue end) as Oct_Revenue, sum(case month when &#x27;Nov&#x27; then revenue end) as Nov_Revenue, sum(case month when &#x27;Dec&#x27; then revenue end) as Dec_Revenuefrom Departmentgroup by id","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"计算机基础知识/数据库","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"","date":"2023-02-15T02:23:35.306Z","path":"wiki/计算机基础知识/算法笔记/dp解最长回文子串/","text":"解题思路动态规划对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串“ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”。 根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P(i,j) 表示 s[i:j]是否为回文串： 那么我们就可以写出动态规划的状态转移方程：P(i, j) &#x3D; P(i+1, j-1)∧(Si&#x3D;&#x3D;Sj) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) &#123; return s; &#125; int maxLen = 1; int begin = 0; // dp[i][j] 表示 s[i..j] 是否是回文串 boolean[][] dp = new boolean[len][len]; // 初始化：所有长度为 1 的子串都是回文串 for (int i = 0; i &lt; len; i++) &#123; dp[i][i] = true; &#125; char[] charArray = s.toCharArray(); // 递推开始 // 先枚举子串长度 for (int L = 2; L &lt;= len; L++) &#123; // 枚举左边界，左边界的上限设置可以宽松一些 for (int i = 0; i &lt; len; i++) &#123; // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 int j = L + i - 1; // 如果右边界越界，就可以退出当前循环 if (j &gt;= len) &#123; break; &#125; if (charArray[i] != charArray[j]) &#123; dp[i][j] = false; &#125; else &#123; if (j - i &lt; 3) &#123; dp[i][j] = true; &#125; else &#123; dp[i][j] = dp[i + 1][j - 1]; &#125; &#125; // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substring(begin, begin + maxLen); &#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:22:05.059Z","path":"wiki/计算机基础知识/操作系统/Ubuntu编制模拟一个简单的进程管理子系统，由进程建立模块、进程撤消模块、进程控制表组成，并包括进程切换和调度模块/","text":"一、进程管理子系统在Ubuntu下编制一个程序，模拟实现一个简单的进程管理子系统，它由进程建立模块、进程撤消模块、进程控制表组成，并包括进程切换和调度模块。 【设计要求1】该子系统接收新进程建立请求的方式是循环显示“请输入新命令行”，然后根据用户键入内容启动相应进程，其后不等待子进程结束，马上显示下一个“请输入新命令行”如此循环往复。当建立进程时，相应读写进程控制表，然后借助底层环境OS中象fork和exec这样的函数将新进程投入运行（这与底层环境的实际OS不同，实际OS将新进程投入运行时要布置现场，最后时程序技术器寄存器）。进程撤消时，利用底层OS的wait( )从子进程回到本子系统，相应修改PCB。比较该子系统与实际系统中的相应功能的异同与差距，尤其在现场保存与恢复方面的比较。 【设计要求2】在上题的基础上，进一步模拟实现进程切换。希望能实现时间片满或接到sleep调用（或信号时）进行进程切换（选择其一即可）。若要实现时间片，假设时间片为1秒钟，设定底层环境OS每个1秒向该系统发一个信号，本子系统将本子系统的进程切换和调度模块设定为该信号的处理程序。或者每当接到子进程发出的的sleep调用（或信号）时进行进程切换，这里子进程发出的sleep调用（或信号）代表实际系统中可能发生的sleep( )调用、等待某一时间发生等情况，进程调度采用简单的FIFO算法。 【设计要求3】编制一个进程调度算法模块。进程调度是处理机管理的核心内容。本设计要求用编写和调试一个简单的进程调度程序。通过设计本项目可以加深理解有关进程控制块、进程队列的概念，并体会和了解最高优先数优先的调度算法（即把处理机分配给优先数最高的进程）和先来先服务算法的具体实施办法。(1) 进程调度算法：采用最高优先数优先的调度算法（即把处理机分配给优先数最高的进程）和先来先服务算法。 (2) 每个进程有一个进程控制块（PCB）表示。进程控制块可以包含如下信息：进程名、优先数、到达时间、需要运行时间、已用CPU时间、进程状态等等。(3) 进程的优先数及需要的运行时间可以事先人为地指定（也可以由随机数产生）。进程的到达时间为进程输入的时间。进程的运行时间以时间片为单位进行计算。(4) 每个进程的状态可以是就绪W（Wait）、运行R（Run）、或完成F（Finish）三种状态之一。(5) 就绪进程获得CPU后都只能运行一个时间片。用已占用CPU时间加1来表示。如果运行一个时间片后，进程的已占用CPU时间已达到所需要的运行时间，则撤消该进程，如果运行一个时间片后进程的已占用CPU时间还未达所需要的运行时间，也就是进程还需要继续运行，此时应将进程的优先数减1（即降低一级），然后把它插入就绪队列等待CPU。(6) 每进行一次调度程序都打印一次运行进程、就绪队列、以及各个进程的PCB，以便进行检查。(7) 重复以上过程，直到所要进程都完成为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; //进程类class pcb&#123;public: //构造函数 pcb(char Name[20], int Rank, int Needtime) &#123; strcpy(name, Name); state = &quot;Wait&quot;; rank = Rank; needtime = Needtime; runtime = 0; next = NULL; &#125; char name[20]; string state; int rank; int needtime; int runtime; pcb* next;&#125;;pcb *ready = NULL, *now = NULL;//输出进程void output(pcb *point)&#123; cout &lt;&lt; &quot;.............................................................................&quot;; cout &lt;&lt; &quot;\\n 进程名称 \\t 进程状态 \\t 优先级 \\t 所需时间 \\t 已运行时间&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| &quot; &lt;&lt; point-&gt;name ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;state ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;rank ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;needtime; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;runtime &lt;&lt; endl; cout &lt;&lt; &quot;.............................................................................&quot; &lt;&lt; endl;&#125; //进程依次排序void sort(pcb *point)&#123; if (ready == NULL)//若链表为空 &#123; ready = point; &#125; else &#123; pcb *point1 = ready, *point2 = ready-&gt;next; if (point-&gt;rank &gt; point1-&gt;rank)//若为优先等级最高，放在队首 &#123; point-&gt;next = ready; ready = point; &#125; else &#123; while (point2 != NULL)//遍历链表，直到找到合适位置 &#123; if (point-&gt;rank &gt; point2-&gt;rank) &#123; point1-&gt;next = point; point-&gt;next = point2; break; &#125; point1 = point2; point2 = point2-&gt;next; &#125; if (point2 == NULL)//若为优先等级最低，放在队尾 &#123; point1-&gt;next = point; &#125; &#125; &#125;&#125; //进程结束函数，打印已完成进程，释放内存void finish(pcb *point)&#123; point-&gt;state = &quot;Finish&quot;; cout &lt;&lt; &quot;******************************** 进程&quot; &lt;&lt; point-&gt;name &lt;&lt; &quot;已经完成 ********************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n 进程名称 \\t 进程状态 \\t 优先级 \\t 所需时间 \\t 已运行时间&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| &quot; &lt;&lt; point-&gt;name ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;state ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;rank ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;needtime; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;runtime &lt;&lt; endl; delete(point); point = NULL;&#125; //运行一个单位时间void running()&#123; now = ready; ready = ready-&gt;next; now-&gt;next = NULL; now-&gt;state = &quot;Run&quot;; now-&gt;rank--; now-&gt;runtime++; if (now-&gt;needtime == now-&gt;runtime) &#123; //若当前进程执行完毕 finish(now); now = NULL; &#125; else &#123; //若当前进程没有执行完毕 cout &lt;&lt; &quot;*************************** 当前正在运行的进程是 *************************** &quot; &lt;&lt; endl; output(now); &#125; //打印就绪队列 cout &lt;&lt; &quot;*************************** 当前就绪队列状态为 *************************** &quot; &lt;&lt; endl; pcb *point = ready; while (point != NULL) &#123; output(point); point = point-&gt;next; &#125; //把没执行完的进程重新放入队列 if (now != NULL) &#123; now-&gt;state = &quot;Wait&quot;; sort(now); &#125;&#125; int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int t; cout&lt;&lt;&quot;**** 输入进程数目：&quot;; cin &gt;&gt; t; cout &lt;&lt; endl; //进程信息输入 for (int i = 1; i &lt;= t; i++) &#123; pcb *temp; char name[20];int rank;int needtime; cout &lt;&lt; &quot;**** 请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个进程的信息 ****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入该进程的名字：&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;请输入该进程的优先等级:&quot;; cin &gt;&gt; rank; cout &lt;&lt; &quot;请输入该进程需要的运行时间:&quot;; cin &gt;&gt; needtime; temp = new pcb(name, rank, needtime); sort(temp); temp = NULL; cout &lt;&lt; endl; &#125; //打印执行前的就绪队列 cout &lt;&lt; &quot;*************************** 执行前就绪队列排序 *****************************&quot; &lt;&lt; endl; pcb *point = ready; while (point != NULL) &#123; output(point); point = point-&gt;next; &#125; cout &lt;&lt; &quot;*************************** 程序准备正式开始执行 *****************************&quot; &lt;&lt; endl; //程序开始执行 char ch; while (now != NULL || ready != NULL) &#123; //一次运行一个单位时间 cout &lt;&lt; &quot;\\n\\n 按任一键继续......&quot; &lt;&lt; endl; ch = getchar(); running(); cout &lt;&lt; endl; &#125; //所有进程完成 cout &lt;&lt; &quot;*************************** 所有进程均已执行完成 ***************************&quot; &lt;&lt; endl; return 0;&#125; 二、进程管理子系统截图","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"操作系统","slug":"计算机基础知识/操作系统","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"","date":"2023-02-15T02:21:56.276Z","path":"wiki/计算机基础知识/操作系统/P、V操作与c++代码实现爸爸放苹果，妈妈放桔子，两个儿子专吃盘子中桔子，两个女儿专吃盘子中苹果问题/","text":"二、吃水果综合设计桌子上有一只盘子，最多可容纳两个水果，每次只能放入或取出一个水果。爸爸专向盘子放苹果（apple），妈妈专向盘子中放桔子（orange）；两个儿子专等吃盘子中的桔子，两个女儿专等吃盘子中的苹果。请用P、V操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。【设计要求】了解信号量机制，了解并掌握进程同步和互斥机制，熟悉信号量的操作函数，利用信号量实现对共享资源的控制。编程模拟实现这一问题的程序控制，分析处理过程。 1. 1.pv操作代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667semaphore empty=2,mutex=1,apple=0,orange=0; void father()&#123; do&#123; P(empty); //等待盘子为空 P(metux); //等待获取对盘子的操作 爸爸向盘中放一个苹果; V(mutex); //释放对盘子的操作 V(apple); //通知女儿可以来盘子中取苹果 &#125;while(TRUE);&#125;void mather()&#123; do&#123; P(empty); //等待盘子为空 P(metux); //等待获取对盘子的操作 妈妈向盘中放一个桔子; V(mutex); //释放对盘子的操作 V(orange); //通知儿子可以来盘子中取橘子 &#125;while(TRUE);&#125;void son1()&#123; do&#123; P(orange); //判断盘子中是否有桔子 P(metux); //等待获取对盘子的操作 儿子1取出盘中的桔子; V(mutex); //释放对盘子的操作 V(empty); //盘子空了，可以继续放水果了 &#125;while(TRUE);&#125;void son2()&#123; do&#123; P(orange); //判断盘子中是否有桔子 P(metux); //等待获取对盘子的操作 儿子2取出盘中的桔子; V(mutex); //释放对盘子的操作 V(empty); //盘子空了，可以继续放水果了 &#125;while(TRUE);&#125;void daugther1()&#123; do&#123; P(apple); //判断盘子中是否有苹果 P(metux); //等待获取对盘子的操作 女儿1取出盘中的苹果; V(mutex); //释放对盘子的操作 V(empty); //盘子空了，可以继续放水果了 &#125;while(TRUE);&#125;void daugther2()&#123; do&#123; P(apple); //判断盘子中是否有苹果 P(metux); //等待获取对盘子的操作 女儿2取出盘中的苹果; V(mutex); //释放对盘子的操作 V(empty); //盘子空了，可以继续放水果了 &#125;while(TRUE);&#125;void main() &#123; //四个并发进程的同步执行 cobegin father(); mather(); son();son();daugther();daugther(); coend&#125; 2.c++程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;semaphore.h&gt;#include &lt;errno.h&gt; #include &lt;unistd.h&gt;#define total 2 sem_t remain, apple, orange, mutex;static unsigned int vremain = 2, vapple = 0, vorange = 0; void *father(void *);void *mather(void *);void *son1(void *);void *son2(void *);void *daughter1(void *);void *daughter2(void *);void print_sem(); int main() &#123; pthread_t fa, ma, so ,da; sem_init(&amp;remain, 0, total);//总数初始化为2 sem_init(&amp;apple, 0, 0);//盆子中苹果数, 开始为0 sem_init(&amp;orange, 0, 0);//盆子中梨子数, 开始为0 sem_init(&amp;mutex, 0, 1);//互斥锁, 初始为1 pthread_create(&amp;fa, NULL, &amp;father, NULL); pthread_create(&amp;ma, NULL, &amp;mather, NULL); pthread_create(&amp;so, NULL, &amp;son1, NULL); pthread_create(&amp;da, NULL, &amp;daughter1, NULL); pthread_create(&amp;so, NULL, &amp;son2, NULL); pthread_create(&amp;da, NULL, &amp;daughter2, NULL); for(;;);&#125; void *father(void *arg) &#123; while(1) &#123; sem_wait(&amp;remain); sem_wait(&amp;mutex); vremain--; vapple++; printf(&quot;父亲放苹果, 剩余空间=%u, 苹果数=%u\\n&quot;, vremain, vapple); sem_post(&amp;mutex); sem_post(&amp;apple); sleep(1); &#125;&#125; void *mather(void *arg) &#123; while(1) &#123; sem_wait(&amp;remain); sem_wait(&amp;mutex); vremain--; vorange++; printf(&quot;母亲放橘子, 剩余空间=%u, 橘子数=%u\\n&quot;, vremain, vorange); sem_post(&amp;mutex); sem_post(&amp;orange); sleep(2); &#125;&#125; void *son1(void *arg) &#123; while(1) &#123; sem_wait(&amp;orange); sem_wait(&amp;mutex); vremain++; vorange--; printf(&quot;儿子吃橘子, 剩余空间=%u, 橘子数=%u\\n&quot;, vremain, vorange); sem_post(&amp;mutex); sem_post(&amp;remain); sleep(3); &#125;&#125; void *son2(void *arg) &#123; while(1) &#123; sem_wait(&amp;orange); sem_wait(&amp;mutex); vremain++; vorange--; printf(&quot;儿子2吃橘子, 剩余空间=%u, 橘子数=%u\\n&quot;, vremain, vorange); sem_post(&amp;mutex); sem_post(&amp;remain); sleep(3); &#125;&#125;void *daughter1(void *arg) &#123; while(1) &#123; sem_wait(&amp;apple); sem_wait(&amp;mutex); vremain++; vapple--; printf(&quot;女儿1吃苹果, 剩余空间=%u, 苹果数=%u\\n&quot;, vremain, vapple); sem_post(&amp;mutex); sem_post(&amp;remain); sleep(3); &#125;&#125; void *daughter2(void *arg) &#123; while(1) &#123; sem_wait(&amp;apple); sem_wait(&amp;mutex);vremain++; vapple--; printf(&quot;女儿2吃苹果, 剩余空间=%u, 苹果数=%u\\n&quot;, vremain, vapple); sem_post(&amp;mutex); sem_post(&amp;remain); sleep(3); &#125;&#125; void print_sem() &#123; int val1, val2, val3; sem_getvalue(&amp;remain, &amp;val1); sem_getvalue(&amp;apple, &amp;val2); sem_getvalue(&amp;orange, &amp;val3); printf(&quot;Semaphore: remain:%d, apple:%d, orange:%d\\n&quot;, val1, val2, val3);&#125; 3.程序模拟实现截图第一次模拟实验截图 第二次模拟实验截图","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"操作系统","slug":"计算机基础知识/操作系统","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"","date":"2023-02-15T02:21:23.988Z","path":"wiki/计算机基础知识/算法笔记/有_无重复二分查找，矩阵查找，有序数组中位数，接雨水算法/","text":"1、二分查找问题：一个无重复的有序整数数组中查找某个数的位置，如果找到则返回下标，否则返回-1。 123456789101112131415161718def BinarySearch(Arr,x):#二分查找 if len(Arr)==0: return -1 left=0 right=len(Arr)-1 while right&gt;=left: mid=(int)((left+right)/2) if Arr[mid]&lt;x: left=mid+1 elif Arr[mid]&gt;x: right=mid-1 else: return mid return -1Array=[0,1,2,3,5,6,7,8,10,55]print(Array)print(BinarySearch(Array,5)) 二分查找算法，每次循环都相当于去掉一半的值，并将剩下一半的值内设好right，left，mid等索引，然后在剩下一半的值内查找，直到找到值，由此可以很快的找到所要找的值. 2、 有重复的二分查找：在一个可重复的升序的整数数组中查找某个数的开始位置和结束位置。 如果数组中不存在，则返回 [-1, -1]。 算法时间复杂度要求为 O(log n) 。示例1：输入：nums &#x3D; [5,7,7,8,8,10] target &#x3D; 8输出：[3,4]示例2：输入：nums &#x3D; [5,7,7,8,8,10] target &#x3D; 6输出：[-1,-1] - 在看到这道题时，我马上想到还是使用二分法查找到所要找的target的其中一个，然后再依次查找所找到target的索引两边的值，直到索引左边或右边的值不再是所查值target时，但很快便发现这样的时间复杂度不是O(log n)，于是只好改变算法。因此想到用二分查找法找到其中一个Arr[mid]&#x3D;target后，不查找到target的所有范围，而只是对比target左边或右边一个位置的值，如果Arr[mid]左边还有target，则将right等于mid-1，循环将在已找到的target左边继续查找，直到Arr[mid]左边不是target，这样返回的mid则是target在数组中在开始的索引；如果Arr[mid]右边还有target，则将left等于mid+1，循环将在已找到的target右边继续查找，直到Arr[mid]右边不是target，这样返回的mid则是target在数组中最后的索引，而且由于每次循环仅判断target左边或右边一次的值，故数据循环度还是O(log n).这样将找到开始值与结束值分别用函数表示出来，从而得到target的范围，这样完成了有重复的某个数的开始位置和结束位置的查找，且时间复杂度符合要求。 1234567891011121314151617181920212223242526272829303132333435363738394041def searchFirstIndex(Arr,target):#定义函数得到查找数的开始位置 if len(Arr)==0:#如果数组不存在，返回-1 return -1 left=0 right=len(Arr)-1#设置左、右两个坐标 while right&gt;=left:#循环条件为右坐标大于左坐标 mid=left+(right-left)//2#每次循环重新取mid为left与right的中值 if Arr[mid]&gt;target:#如果mid的值小于target的值，则x位于mid右边,left+1 right=mid-1 elif Arr[mid]&lt;target:#如果mid的值大于target的值，则x位于mid左边,right-1 left=mid+1 else: if mid==left or Arr[mid-1]!=target:#如果mid已是所查数的开始位置 return mid right=mid-1 #mid左边还有target，则将right等于mid-1，循环将在已找到的target左边继续查找，直到mid左边不是target return -1def searchLastIndex(Arr,target):#定义函数得到查找数的结束位置 if len(Arr)==0: return -1 left=0 right=len(Arr)-1 while right&gt;=left: mid=left+(right-left)//2 if Arr[mid]&gt;target: right=mid-1 elif Arr[mid]&lt;target: left=mid+1 else: if mid==left or Arr[mid-1]!=target:#如果mid已是所查数的最后位置 return mid left=mid+1 #mid右边还有target，则将left等于mid+1，循环将在已找到的target右边继续查找，直到mid右边不是target return -1def searchRange(Arr,target):#定义函数得到查找数的范围 first=searchFirstIndex(Arr,target) last=searchLastIndex(Arr,target) return [first,last]Arr=[1,2,3,5,5,5,5,6,7,8,9,10]print (searchRange(Arr,5)) 3、矩阵查找问题：在一个 m x n 的有序整数矩阵中查找某个数。有序矩阵是指每行中的整数从左到右为升序排列、每行的第一个整数大于前一行的最后一个整数。找到返回true，否则返回false。示例1：输入：matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] target &#x3D; 3输出：true示例2：输入：matrix &#x3D; [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] target &#x3D; 13输出：false 首先想到将矩阵转换为数组，对数组进行二分查找找到所查的数，而且也很好实现。 之后又想到一种方法，由于有序矩阵是指每行中的整数从左到右为升序排列、每行的第一个整数大于前一行的最后一个整数，因此我们可以先对每一行最后一列的值与所查的值比较，这样就能找到所查值所在的行，然后再在该行进行遍历，便能找到所查的值是否存在。存在则返回true，否则返回false。 123456789101112131415def searchMatrix(matrix,num): i = 0 j = len(matrix[0]) - 1#j为列值 max_i = len(matrix) - 1#行值 while i &lt;= max_i and j &gt;= 0:#循环条件 if matrix[i][j] == num: return True#存在返回true elif matrix[i][j] &lt;num:#当值比所求值小，则增加行数，得到所求值的行数 i = i + 1 else:#在行内减少列数，得到是否存在所求值 j = j - 1 return False#不存在返回falsematrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12]]print(searchMatrix(matrix,5)) 4、 寻找两个有序数组的中位数：给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 找出这两个有序数组的中位数， 假设 nums1 和 nums2 不会同时为空，要求算法的时间复杂度为 O(log(m + n))。示例1：输入：nums1 &#x3D; [1, 3] nums2 &#x3D; [2] 输出：2.0示例2：输入：nums1 &#x3D; [1, 2] nums2 &#x3D; [3, 4] 输出：2.5 看到2个有序数组，由于学习过归并排序的缘故马上想到将两个数组归并到一个数组后使用得到中位数，但要求算法的时间复杂度为 O(log(m + n))，很明显归并法并不满足。在进过星期三递归算法的学习后，知道递归算法的时间复杂度是log类型的，于是考虑使用递归法求解，但还是没有想到算法。于是百度后发现有很多不同的解析，有些解析写得很深奥，我认真学习了其中最容易懂的算法。该方法的关键函数就是找到2个有序数组中第k大值（从1开始）的函数，该函数就是运用了递归法，先将所求2个数组的num【k&#x2F;&#x2F;2-1】进行比较看，哪个数组的num【k&#x2F;&#x2F;2-1】小，而两个k&#x2F;&#x2F;2的数最多k个数，则第k大的数必不在num【k&#x2F;&#x2F;2-1】小的前k&#x2F;&#x2F;2个数内，故递归，对该数组从num【k&#x2F;&#x2F;2+1】与另一数组再次使用函数，并使k&#x3D;k-k&#x2F;&#x2F;2，一直循环，直到k&#x3D;1时返回2个数组中最小的值，这就是2个有序数组中第k大的值。如[1,2,3,4]与[5,6,7]两个数组，对比nums【4&#x2F;&#x2F;2-1】，明显知道[1,2,3,4]内2比[5,6,7]中6小，因此2必是比第k个数小的数，因此去掉1,2，递归继续在[3,4]与[5,6,7]内找到第4-2&#x3D;2大的数。若两数组总长度length为奇数，查找中位数即找到两个数组第length&#x2F;&#x2F;2大的数，两数组总长度length为奇数length为偶数，查找中位数即找到两个数组第length&#x2F;&#x2F;2与第length&#x2F;&#x2F;2+1个数的平均值。 1234567891011121314151617181920212223242526def findkth(nums1,nums2,k):#递归找到两个数组中第k大的数 if len(nums1)&gt;len(nums2):#保证nums1的长度比nums2的长度短 return findkth(nums2,nums1,k) if(len(nums1)==0):#如果nums1为空，则返回nums2的第k大的数 return nums2[k-1] if k==1:#k=1时，返回最小的值 return min(nums1[0],nums2[0]) i=k//2 if nums1[i-1]&gt;nums2[i-1]: #比较数组的第i个数，如果nums1[i-1]大，而两个i的数组内最多k个数， #则第k大的数必不在nums2的前k//2个数内，故返回num1与nums2[i:]的第k-1个小的数 return findkth(nums1,nums2[i:],k-i) else: return findkth(nums1[i:],nums2,k-i) def findmid(nums1,nums2): length=len(nums1)+len(nums2) if length%2==1:#length为奇数，查找中位数即找到两个数组第length//2大的数 return findkth(nums1,nums2,length//2+1) elif length%2==0:#length为偶数，查找中位数即找到两个数组第length//2与第length//2+1个数的平均值 return (findkth(nums1,nums2,length//2)+findkth(nums1,nums2,length//2+1))/2.0nums1=[1,2,3,4,5]nums2=[5,6,7,8,11]print(findmid(nums1,nums2)) 5、 假设给定的一个数组描述了 n 个宽度为 1 的柱子高度，请求出按此排列的柱子，下雨之后能接多少雨水。示例：输入： [0,1,0,2,1,0,1,3,2,1,2,1]输出： 6示例图： 刚看到该题时，以为改题目很难，但认真想了一会便发现很简单，将接到水按每一高度来算，在这一高度想要接到水，至少这一高度要有2个该高度的柱子，且接到水的量等于两个柱子索引的差再减一，即类似种树问题。因此，从数组最大值到1进行遍历，每次遍历找到数组中等于该值的所有索引，再将该高度的水全加起来，如高度&#x3D;2时，数组值等于2的下标为[3, 7, 8, 10]，3到7有3格水，7到8接不到水，8到10一格水，则2这一高度共有4格水。因此将高度从最大值到1每一高度的水加起来就能得到接到水的总量 1234567891011121314151617def sumOfWater(nums): num=max(nums)#num为遍历的值，从最大值开始遍历 sum=0#sum表示接到水的重量 for num in range (max(nums),0,-1):#对数组按值从最大值到1遍历，每次循环sum增加所遍历高度能接到的水 temp=[]#数组temp用来记录大于等于遍历值的数组索引 for j in range (0,len(nums)):#下标遍历数组，temp记录索引 if nums[j]&gt;=num: temp.append(j) print(temp)#输出数组便于观察 if len(temp)&gt;1:#当数组中遍历的值的个数大于1时 for index in range (0,len(temp)-1):#分别求出该遍历高度每2个索引间的水数 sum=sum+temp[index+1]-temp[index]-1 #如num=2时，temp为[3, 7, 8, 10]，3到7有3格水，7到8没水，8到10一格水 return sumnums= [0,1,0,2,1,0,1,3,2,1,2,1]print(sumOfWater(nums))","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:21:15.093Z","path":"wiki/计算机基础知识/算法笔记/逆序问题，最大间隙问题，棋盘覆盖问题，最接近点对问题/","text":"一、实验目的及要求1、从数组 seq 中找出和为 s 的数值组合，有多少种可能，并打印这些组合。（1）问题描述：求一个算法：N个数，用其中M个任意组合相加等于一个已知数X。得出这M个数是哪些数。（2）问题举例：seq &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9] s &#x3D; 14 则全部可能的数字组合有： 5+9, 6+8 1+4+9, 1+5+8, 1+6+7, 2+3+9, 2+4+8, 2+5+7, 3+4+7, 3+5+6 1+2+5+6, 1+3+4+6, 1+2+4+7, 1+2+3+8, 2+3+4+5 共计15种。 123456789101112131415161718def combination(seq, s, tmp=&#x27;&#x27;): global M#全局变量M记录第几种 if len(seq)==0: # 一次递归直到seq长度为0时结束 return if seq[0] == s: # 当seq[0]等于s时，找到一种，则M+1，并输出tmp+str(seq[0]) M+=1 print(&#x27;第&#x27;+str(M)+&#x27;种:&#x27;+tmp + str(seq[0])) #每次函数两次递归，分别为是否包含seq[0] combination(seq[1:], s, tmp) #第一次递归不包含seq[0]，下一次递归tmp不变 combination(seq[1:], s-seq[0], str(seq[0]) + &#x27;+&#x27; + tmp) #第二次递归包含seq[0],下一次递归tmp加上str(seq[0])seq = [1, 2, 3, 4, 5, 6, 7, 8, 9]M=0combination(seq,14) 实验时，想到要求出所有可能的组合，而每组组合则需要考虑数组中每个数，则使用递归，每次减少一个数，并每次函数2次递归，第一个递归则是不包括数组第一个数，第二个递归则是包括数组第一个数，这样递归完则可以将每个数是否加上共2^len(num)种情况全考虑，将每种组合得到并输出。 2、编程实现统计逆序问题（1）问题描述：豆瓣是一家图书、电影和音乐唱片的评价与推荐网站。这类推荐类网站会根据你对系列书籍的评价，从它的读者数据库中找出与你的评价非常类似的读者推荐给你，从而帮助你找到品味相近的朋友。假设你对五本书进行了评价，这五本书你的打分从低到高依次是[1，2，3，4，5]。另外，读者A的对这五本书的打分是[2，4，1，3，5]，而读者B的打分是[3，4，1，5，2]。那么，应该把读者A还是读者B推荐给你呢? 豆瓣也许会把读者A推荐给你，因为相比较于读者B，读者A与你的口味更为相投。那怎么来量化推荐的准则呢?这可以通过计算一个称为逆序量的来度量相似度。对于输入序列，如果元素的索引 i＜j，且ai＞aj，那么元素ai和aj是一对逆序。打分[1，2，3，4，5]的逆序对数为0，读者A打分[2，4，1，3，5]存在3对逆序，分别是｛2，1],[4，1]和[4，3]。读者B打分[3，4，1，5，2]的逆序数为5对，分别是[3，1]，[3，2]，[4，1],[4，2]和[5，2]。因此，如果用逆序数来度量推荐准则，那么读者A相比较于读者B与你有更为接近的品位。本问题就是计算给定序列的逆序数。（2）算法设计：一个简单直接的算法就是对于每一个元素，计算该元素右边有几个元素比它小。例如，对于输入序列[2，4，1，3，5]，元素2的右边共有1个元素叫比它小，元素4的右边 共有2个元素[1，3]比它小。因此，以上序列共有3对逆序。 123456789101112def inverseNum(nums): sum=0 if len(nums)==1: return 0 for i in range(1,len(nums)): if nums[0]&gt;nums[i]:#判断num[0]相对数组是否有逆序数，有着sum+1 sum=sum+1 return sum+inverseNum(nums[1:])#递归nums=[1,2,3,4,5,4,3]print(inverseNum(nums)) 算法：每个函数仅判断数组第一个值对数组是否有逆序数，然后再对数组【1：】递归 3、编程实现最大间隙问题（1）问题描述：给定n 个实数x1 , x2 , , xn ，求这n 个数在实轴上相邻2 个数之间的最大差值。要求设计出线性时间算法。（2）问题举例：输入数据：5 2.3，3.1，7.5，1.5，6.3 输出数据：3.2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def maxGap(nums): max=nums[0] min=nums[0] for i in range(0,len(nums)):#找到数组的最大值与最小值 if nums[i]&gt;max: max=nums[i] if nums[i]&lt;min: min=nums[i] if len(nums)==2:#如果数组长度为2，返回2值之差 return abs(nums[0]-nums[1]) length=(max-min)/(len(nums)-1)#将最大值与最小值之间平均分为n-1个范围 low,high,count=&#123;&#125;,&#123;&#125;,&#123;&#125; for j in range(0,len(nums)-1): low[j]=max+1#将每个范围的左坐标赋值为数组max+1 high[j]=min-1#将每个范围的右坐标赋值为数组min-1 count[j]=0 #count用来记录数组中的值落在范围中的个数 for i in range(0,len(nums)):#对数组中每个数遍历，找到每个数应该在哪个范围 index=(nums[i]-min)//length#index表示数在第index+1个范围内 if index==len(nums)-1: #当index为n-1时，表示该数为最大值，index-1,分在第index+1即第n-1个范围内 index-=1 if nums[i]&lt;low[index]: #low[index]最开始赋值为max+1，即第一次落在该范围内的数赋给low[index] #之后落在该范围内数如果比low[index]小，即将该数赋给low[index] low[index]=nums[i] if nums[i]&gt;high[index]: #high[index]最开始赋值为min+1，即第一次落在该范围内的数赋给high[index] #之后落在该范围内数如果比high[index]大，即将该数赋给high[index] high[index]=nums[i] count[index]+=1#第index+1个范围内每落入一个数，count[index]+1 i=0 maxgap=0 for i in range(1,len(nums)-1): #因为除了min和max还有n-2个数，放入到n-1个范围内，必至少有一个范围内没有数放入 #且易知没有数的范围两边的范围内的数之间的间距比在同一范围内的数的间距大 #因此数组最大间距必是相邻范围内差距 if count[i]==0: #当范围内没有放入数时，该范围最小值与最大值都设为左边的范围的最大值 low[i]=high[i-1] high[i]=low[i] if low[i]-high[i-1]&gt;maxgap: #求2个范围之间的差距，差距最大值即为数组的最大差距 maxgap=low[i]-high[i-1] return maxgapnums=[1,2,3,5,6,4,4,9]print(&#x27;最大间隙为&#x27;,end=&#x27;&#x27;)print(maxGap(nums)) 刚开始以为可以先排序，然后再求出最大间隙，后来发现这样达到不了线性时间长度的要求，于是百度发现，可以先求出最大值与最小值，然后再将其中的间隙分为len(nums)-1个范围，这样将剩下的len-2个放入到这些范围中，然后再进行最大间隙的处理便能再线性时间内解决。 4、编程实现棋盘覆盖问题（1）问题描述：在一个2^k * 2^k个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。现在要用L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。（2）算法设计：把棋盘等分成四个正方形分别是：左上、左下、右上、右下 四个子棋盘，对子棋盘进行递归求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344def chess(tr,tc,pr,pc,size):#tr，tc为左上角在棋盘中的位置，pr，pc为特殊棋子的位置，size为棋盘大小 global mark global table if size==1: return mark+=1#每次新的递归当size大于1时，用新的l型方块填，即mark+1 count=mark#为count赋值mark half=size//2#half为size大小的一半 if pr&lt;tr+half and pc&lt;tc+half:#如果特殊棋子的位置小于初始位置+half，即特殊棋子在左上角，则在左上角棋盘递归 chess(tr,tc,pr,pc,half) else:#如果特殊棋子不在左上角，则在右下角用count型覆盖，并使右下角定义为特殊棋子，再递归左上角 table[tr+half-1][tc+half-1]=count chess(tr,tc,tr+half-1,tc+half-1,half) if pr&lt;tr+half and pc&gt;=tc+half:#如果特殊棋子在右上角 chess(tr,tc+half,pr,pc,half) else: table[tr+half-1][tc+half]=count chess(tr,tc+half,tr+half-1,tc+half,half) if pr&gt;=tr+half and pc&lt;tc+half:#如果特殊棋子在左下角 chess(tr+half,tc,pr,pc,half) else: table[tr+half][tc+half-1]=count chess(tr+half,tc,tr+half,tc+half-1,half) if pr&gt;=tr+half and pc&gt;=tc+half:#如果特殊棋子在右下角 chess(tr+half,tc+half,pr,pc,half) else: table[tr+half][tc+half]=count chess(tr+half,tc+half,tr+half,tc+half,half) def show(table): n=len(table) for i in range(n): for j in range(n): print(&#x27;%2s&#x27;%table[i][j],end=&#x27; &#x27;) print(&#x27;&#x27;)mark=0n=8table=[[-1 for x in range(n)] for y in range(n)]#初始化tablechess(0,0,2,5,n)show(table) 在上课听过算法思路并看过代码后比较容易的写出程序。 5、编程实现最接近点对问题（1）问题描述：在包含有n个点的集合S中，找出距离最近的两个点。设 p1(x1,y1)，p2(x2,y2)，……，pn(xn,yn)是平面的n个点。严格地将，最近点对可能不止一对，输出一对即可。（2）算法设计：利用分治法思想解决此问题。将集合S分成两个子集S1和S2，最近点对将会出现三种情况：在S1中，在S2中或者最近点对分别在集合S1和S2中。利用递归法分别计算前两种情况，再与第三种情况相比较，输出三者中最小的距离。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import mathimport randomminDitsance=float(&quot;inf&quot;)def distance(x,y):#求出x，y两点间的距离 h=math.sqrt((x[0]-y[0])**2+(x[1]-y[1])**2) #print(x,y) return h def min_between(left,right,minDitsance):#找到左右各取一点的距离的最小值 x=float(&quot;inf&quot;) mini=left[-1][0]-minDitsance#比较范围最小值为左边最右点的x值减去已知最小距离 maxi=left[-1][0]+minDitsance#比较范围最大值为左边最右点的x值加上最小距离 #print(minDitsance) for i in left:#取左边的点 if (mini&lt;i[0]&lt;maxi):#当左边点x轴在离左边最右点一个最小距离内时 for j in right: if ((mini&lt;j[0]&lt;maxi)and abs(i[1]-j[1])&lt;minDitsance): #当i，j的y值也在左边最右点y值一个最小距离内时求出这些点的最小距离 x=min(x,distance(i,j)) return x def divide(list):#递归法求最小距离 global minDitsance if (len(list)==2):#列表长度为2是返回两点距离 return distance(list[0],list[1]) if (len(list)&lt;2):#长度小于2返回inf return float(&quot;inf&quot;) else: i=int(len(list)/2) left = list[0:i] right = list[i:]#长度大于2时，将已经按x轴排序的点分割为左一半元素,右一半元素,左右分别求最近点 s1=divide(left)#且用递归对分开的2边继续分直到找到最近点 s2=divide(right) #print(left) #print(right) s3=min_between(left,right,minDitsance) s=min(s1,s2,s3)#最后进行比较,将左，右两边的最近距离与左右各取一点的最短距离比较取最短 minDitsance=min(s,minDitsance) return minDitsance def minDistancePoints(point,minDistance):#求出取最短距离的两点 for i in point: for j in point: if distance(i,j)==minDistance and i[0]&gt;=j[0]: print(&#x27;最短距离的两点为&#x27;,end=&#x27;&#x27;) print(i,j)n=10point = [(random.randint(0, 50), random.randint(0, 50)) for i in range(0, n)]point.sort()print(point)minDistance=divide(point)minDistancePoints(point,minDistance)print(minDistance) 该题虽然在上课讲过算法，但我在编程时感受到了许多困难，最后孩子在百度上进行了很久的学习才能将程序写出来","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:21:07.949Z","path":"wiki/计算机基础知识/算法笔记/最大子段和问题，拾捡硬币问题， 矩阵连乘问题，最短公共超序列问题，最优二分搜索树，买卖股票的最佳时机，天平秤金条问题，动态规划解最短路径问题/","text":"1、最大子段和问题问题描述：给定长度为n的整数序列，a[1…n], 求[1,n]某个子区间[i , j]，使得a[i]+…+a[j]和最大。示例：输入：(-2,11,-4,13,-5,2) 输出：最大子段和为20，所求子区间为[2,4] 2、拾捡硬币问题问题描述：假如有n 个硬币排在一行，要求拾取其中的子序列，该序列的累加面值最大，但不能拾取相邻的两个硬币。示例：输入5; 1; 2; 10; 6; 2， 输出：Max&#x3D;17 （5，10，2） 3、 矩阵连乘问题问题描述：矩阵连乘问题是通过给矩阵连乘时加括号，使得总的计算量最小。示例：输入：[[49, 29], [29, 32], [32, 77], [77, 13], [13, 59]]， 输出：((A1(A2(A3A4)))A5) 4、最短公共超序列问题问题描述：给出两个字符串str1和str2，返回同时以str1和str2作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于T中的任意位置），可以得到字符串 S，那么S就是T的子序列。设1&lt;&#x3D;str1.length, str2.length&lt;&#x3D;1000，str1和str2都由小写英文字母组成。示例：输入：str1 &#x3D; “abac”, str2 &#x3D; “cab” 输出：”cabac” 解释：str1 &#x3D; “abac” 是 “cabac” 的一个子串，因为可以删去 “cabac” 的第一个 “c”得到 “abac”。 str2 &#x3D; “cab” 是 “cabac” 的一个子串，因为可以删去 “cabac” 末尾的 “ac” 得到 “cab”。最终给出的答案是满足上述属性的最短字符串。 5、对于一个n&#x3D;5的关键字集合，搜索概率如下表，请构造其最优二分搜索树。6、买卖股票的最佳时机问题描述：给定一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成k笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例1：输入: [2,4,1], k &#x3D; 2 输出: 2解释: 在第 1 天 (股票价格&#x3D;2)的时候买入，在第2天 (股票价格&#x3D;4)的时候卖出，这笔交易所能获得利润&#x3D;4-2&#x3D;2 。示例2：输入: [3,2,6,5,0,3], k &#x3D; 2 输出: 7解释: 在第 2 天 (股票价格&#x3D;2) 的时候买入，在第3天 (股票价格&#x3D;6)的时候卖出, 这笔交易所能获得利润&#x3D; 6-2&#x3D;4。随后，在第5天(股票价格&#x3D;0)的时候买入，在第6天(股票价格&#x3D;3)的时候卖出, 这笔交易所能获得利润&#x3D;3-0&#x3D;3 7、天平秤金条问题问题描述：有30根金条，其中一根比其它的要重，请问用一个天平至少秤几次可以将这个重的金条找出来。示例1：输入：[10, 10, 10, 10, 10, 11] 输出：The fake coin is coin 6 in the original list Number of weighings: 2示例2：输入：[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 10, 10] 输出：The fake coin is coin 25 in the original list Number of weighings: 3 8、动态规划解最短路径问题问题描述：从某顶点出发，沿图的边到达另一顶点所经过的路径中，求各边上权值之和最小的一条路径——最短路径。示例：输入如下图（图的输入形式自行确定）：输出：从A到G的最短路径长度为： 18 经过的结点为： [‘B1’, ‘C2’, ‘D1’, ‘E2’, ‘F2’]二、实验设备（环境）及要求PC机，Windows 10 三、实验内容及结果（包括实验过程、实验数据、实验结果及分析，实验代码另外单独附页）1、最大子段和问题问题描述：给定长度为n的整数序列，a[1…n], 求[1,n]某个子区间[i , j]，使得a[i]+…+a[j]和最大。示例：输入：(-2,11,-4,13,-5,2) 输出：最大子段和为20，所求子区间为[2,4] 想法：要求最大字段和与所求区间，即从0开始相加，依次记录newsum，并用begintemp与endtemp记录区间，用maxsum保存最大的sum，并且每次新的maxsum出现时重新记录begin与end区间，当sum小于0后，证明前面sum的只会使sum变小，则从i+1重新开始相加并记录newsum，并重新记录begintemp与endtemp，每次新的maxsum出现时重新记录begin与end区间。 123456789101112131415161718192021222324def maxSubSum(arr): maxsum=0 begin,end=0,0 newsum=0 for i in range(len(arr)): if newsum&lt;0:#当num小于0，则从arr[i]开始新的sum值计算，并重新记录newsum与beginTemp newsum=arr[i] beginTemp=i+1 else:#如果newsum大于0，则继续加arr[i]，并记录endTemp newsum=newsum+arr[i] endTemp=i+1 if newsum&gt;maxsum:#如果newsum大于maxsum，则给maxsum赋新值,并将记录的beginTemp与endTemp赋值 maxsum=newsum begin=beginTemp end=endTemp return maxsum,begin,end#返回最大字段和maxsum,区间首尾begin,endarr=[-2,11,-4,13,-5,2]maxsum,begin,end=maxSubSum(arr)print(&#x27;最大子段和为&#x27;,end=&#x27;&#x27;)print(maxsum)print(&#x27;所求子区间为&#x27;,end=&#x27;&#x27;)print(&#x27;[&#x27;+str(begin)+&#x27;,&#x27;+str(end)+&#x27;]&#x27;) 2、拾捡硬币问题问题描述：假如有n 个硬币排在一行，要求拾取其中的子序列，该序列的累加面值最大，但不能拾取相邻的两个硬币。示例：输入5; 1; 2; 10; 6; 2， 输出：Max&#x3D;17 （5，10，2） 123456789101112131415161718192021def dp_maxNonAdjacentSum(arr):#非递归动态规划解决不相邻的最大和 opt=(len(arr)+1)*[0]#初始化opt数组记录最大值 temp=(len(arr)+1)*[&#x27;&#x27;]#初始化temp数组记录opt值的序列 opt[1]=arr[0]#opt[1]取arr[0],temp[1]记录取值 temp[1]=str(opt[1]) opt[2]=max(arr[0],arr[1])#opt[2]取max(arr[0],arr[1])，temp记录取值 temp[2]=str(opt[2]) for i in range(3,len(arr)+1): A=opt[i-2]+arr[i-1]#A表示取arr[i-1],则A再加上opt[i-2] B=opt[i-1]#B表示不取arr[i-1]，则B=opt[i-1] if A&gt;B:#当A大于B时，opt[i]=A，temp[i]记录取值 opt[i]=A temp[i]=temp[i-2]+&#x27; &#x27;+str(arr[i-1]) else:#当Ｂ大于等于Ａ时，opt[i]=B，temp[i]记录取值 opt[i]=B temp[i]=temp[i-1] return opt[len(arr)],temp[len(arr)]#返回opt[i]与子序列arr=[5,1,2,10,6,2]maxNonAdjacentSum,Subsequence=dp_maxNonAdjacentSum(arr)print(&#x27;Max=&#x27;+str(maxNonAdjacentSum)+&#x27;(&#x27;+Subsequence+&#x27;)&#x27;) 2.两个数组opt记录最大值，temp记录选择的硬币，opt【i】为第1个硬币到第i个硬币的最大值，有两种情况，分为选第i-1硬币时A&#x3D;opt[i-2]+arr[i-1]与不选i-1硬币B&#x3D;opt[i-1]，故A与B中的最大值，同时给temp记录选取的硬币，并依次遍历。 3、 矩阵连乘问题问题描述：矩阵连乘问题是通过给矩阵连乘时加括号，使得总的计算量最小。示例：输入：[[49, 29], [29, 32], [32, 77], [77, 13], [13, 59]]， 输出：((A1(A2(A3A4)))A5)3.规划解决矩阵连乘，2个数组m s分别记录最少乘法次数与分割点的值，并用3次for循坏依次求出m,s[i][j], 123456789101112131415161718192021222324252627import numpydef MatrixChainOrder(p): n=len(p)-1 m=numpy.zeros((n+1,n+1))#m[i][j]用来记录Ai到Aj的最少乘法次数 s=numpy.zeros((n+1,n+1))#s[i][j]用来记录Ai到Aj的最优括号化方案的分割点k的值 for l in range(2,n+1):#l表示长度 for i in range(1,n-l+2): j=i+l-1 m[i][j]=float(&quot;inf&quot;) for k in range(i,j):#遍历k从i到j所有以k为分割点的括号方案 temp=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]#以k为分割点的方案的乘法次数计入temp if m[i][j]&gt;temp:#取k从i到j方案中的最优方案 m[i][j]=temp s[i][j]=int(k) return m,sdef printOptimalParens(s,i,j):#输出最优括号方案,ij表示范围，s[i][j]为记录的最优括号方案的分割点k的值 if i==j:#当i=j时就输出Ai print (&#x27;A&#x27;+str(i),end=&#x27;&#x27;) else:#当i不等于j时，输出i到k与k到j的最优括号方案 print (&#x27;(&#x27;,end=&#x27;&#x27;) printOptimalParens(s,i,int(s[i][j])) printOptimalParens(s,int(s[i][j])+1,j) print(&#x27;)&#x27;,end=&#x27;&#x27;)p=[49,29,32,77,13,59]m,s=MatrixChainOrder(p)printOptimalParens(s,1,len(p)-1) 4、最短公共超序列问题问题描述：给出两个字符串str1和str2，返回同时以str1和str2作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于T中的任意位置），可以得到字符串 S，那么S就是T的子序列。设1&lt;&#x3D;str1.length, str2.length&lt;&#x3D;1000，str1和str2都由小写英文字母组成。 4.要求最短共超序列，即先用动态规划求出最长公共子序列lcs，最短公共超序列scs即为两个字符串的最长公共子序列LCS+第一个字符串除去LCS之后的序列+第二个字符串除去LCS之后的序列。 12345678910111213141516171819202122232425262728293031323334353637383940def shortestCommonSuperSequence(str1,str2): m=len(str1) n=len(str2) dp=[[&#x27;&#x27;]*(n+1) for i in range(m+1)]#定义dp数组记录最短公共子序列 for i in range(1,m+1): for j in range(1,n+1): if(str1[i-1]==str2[j-1]): #当str1[i-1]==str2[j-1]，dp[i][j]为dp[i-1][j-1]+str1[i-1] #dp[i][j]记录str[1-1]与str[j-1]的最短公共子序列 dp[i][j]=dp[i-1][j-1]+str1[i-1] else: #如果str1[i-1]与str2[j-1]不相同时 #则令dp[i][j]取dp[i-1][j]与dp[i][j-1]中的最长子序列 if len(dp[i-1][j]) &gt; len(dp[i][j-1]): dp[i][j]=dp[i-1][j] else: dp[i][j]=dp[i][j-1] lcs=dp[i][j]#lcs即为最长公共子序列等于dp[i][j] i,j=0,0 scs=&#x27;&#x27; for char in lcs: #最短公共超序列scs即为两个字符串的最长公共子序列LCS+第一个字符串除去LCS之后的序列+第二个字符串除去LCS之后的序列。 while(i&lt;m and str1[i]!=char):#i&lt;m时若str1[i]!=charstr1[i] #即str1[i]不属于最长公共子序列LCS，则scs加上str1[i] scs+=str1[i] i=i+1 while(j&lt;n and str2[j]!=char):#j&lt;n时若str2[j]!=char #即str2[j]不属于最长公共子序列LCS，则scs加上str2[j] scs+=str2[j] j=j+1 scs+=char#scs加上循环的最长公共子序列LCS，i=i+1，j=j+1 i=i+1 j=j+1 scs+=str1[i:]+str2[j:]#当加完LCS后，再加上str1[i:]与str2[j:]，即加上最长公共子序列LCS之后的部分 return scsstr1 = &quot;abac&quot;str2 = &quot;cab&quot; print(shortestCommonSuperSequence(str1,str2)) 5、对于一个n&#x3D;5的关键字集合，搜索概率如下表，请构造其最优二分搜索树。 .要找到最优二叉搜索树， e[i][j]用来记录包含k[i]到k[j]的最优二次搜索树的期望代价w[i][j]为k[i]到k[j]的所有子树的概率之和， e[i][j]&#x3D;max（e[i][r-1]+e[r+1][j]+w[i][j]），r从1到j为根节点的位置，动态规划依次求出e[i][j],并使用flag为0，表示为根节点，flag为-1，表示k[root[i][j]]为左孩子，flag为1，表示k[root[i][j]]为右孩子，当j&#x3D;i-1时，子树只包括伪关键字d[i-1]等输出最优二叉搜索树 12345678910111213141516171819202122232425262728293031323334353637383940def OPTIMALBST(p,q,n): e=[[0]*(n+2) for i in range(n+2)]#e[i][j]用来记录包含k[i]到k[j]的最优二次搜索树的期望代价 w=[[0]*(n+2) for i in range(n+2)]#w[i][j]为k[i]到k[j]的所有子树的概率之和 root=[[0]*(n+1) for i in range(n+1)]#root[i][j]保存根节点k[r]的下标r for i in range(1,n+2):#当j=i-1时，子树只包括伪关键字d[i-1] e[i][i-1]=q[i-1] w[i][i-1]=q[i-1] for l in range(1,n+1):#l表示长度，从1到n for i in range(1,n-l+2): j=i+l-1 e[i][j]=float(&#x27;inf&#x27;) w[i][j]=w[i][j-1]+p[i]+p[j] for r in range(i,j+1): t=e[i][r-1]+e[r+1][j]+w[i][j]#t记录以k[r]为根节点的从k[i]到k[j]的搜索代价 if t&lt;e[i][j]:#取最优的二叉搜索树 e[i][j]=t root[i][j]=r return e,rootdef printOPTIMALBST(i,j,flag):#输出最优二叉树的结构 if(i&lt;=j):#当j&gt;=i时 if flag==0:#flag为0，表示为根节点 print(&#x27;k&#x27;+str(root[i][j])+&#x27;为根&#x27;) elif flag==-1:#flag为-1，表示k[root[i][j]]为左孩子 print(&#x27;k&#x27;+str(root[i][j])+&#x27;为k&#x27;+str(j+1)+&#x27;的左孩子&#x27;) else:#flag为1，表示k[root[i][j]]为右孩子 print(&#x27;k&#x27;+str(root[i][j])+&#x27;为k&#x27;+str(i-1)+&#x27;的右孩子&#x27;) printOPTIMALBST(i,root[i][j]-1,-1) printOPTIMALBST(root[i][j]+1,j,1) elif j==i-1:#当j=i-1时，子树只包括伪关键字d[i-1] if flag==-1: print(&#x27;d&#x27;+str(j)+&#x27;为k&#x27;+str(j+1)+&#x27;的左孩子&#x27;) elif flag==1: print(&#x27;d&#x27;+str(j)+&#x27;为k&#x27;+str(i-1)+&#x27;的右孩子&#x27;)p=[0,0.15,0.10,0.05,0.10,0.20]q=[0.05,0.10,0.05,0.05,0.05,0.10]n=5e,root=OPTIMALBST(p,q,n)print(&#x27;最优二叉搜索树为&#x27;)printOPTIMALBST(1,n,0) 6、买卖股票的最佳时机问题描述：给定一个数组，它的第i个元素是一支给定的股票在第i天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成k笔交易。注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。示例1：输入: [2,4,1], k &#x3D; 2 输出: 2解释: 在第 1 天 (股票价格&#x3D;2)的时候买入，在第2天 (股票价格&#x3D;4)的时候卖出，这笔交易所能获得利润&#x3D;4-2&#x3D;2 。示例2：输入: [3,2,6,5,0,3], k &#x3D; 2 输出: 7解释: 在第 2 天 (股票价格&#x3D;2) 的时候买入，在第3天 (股票价格&#x3D;6)的时候卖出, 这笔交易所能获得利润&#x3D; 6-2&#x3D;4。随后，在第5天(股票价格&#x3D;0)的时候买入，在第6天(股票价格&#x3D;3)的时候卖出, 这笔交易所能获得利润&#x3D;3-0&#x3D;3 1在这里插入代码片 要求最大利益，且用k定义买卖的次数，则只有用3维数组profit[i][j][0]表示第i天第j次交易，身上没有股票时的最大利益profit[i][j][1]表示第i天地j次交易但身上有股票时的最大利益，并且对profit[i][j][0]与profit[i][j][1]都有2种求值的方法，在第i天可以买（卖）股票或不买卖股票，且还要用j记录是第几次交易，所有第i天要求profit[i][0][0]，profit[i][0][1]，profit[i][j][0]，profit[i][j][1]（j从1到k-1），profit[i][k][0]，每种都要取2种求值方法的最大值，而最后的求解的最大值maxProfit&#x3D;profit[len(prices)-1][j][0] 123456789101112131415161718192021222324252627def maxProfit(prices,k): profit=[[[0]*2 for i in range(k+1)]for i in range(len(prices))] #profit[i][j][0]表示第i天第j次交易，身上没有股票时的最大利益 #profit[i][j][1]表示第i天地j次交易但身上有股票时的最大利益 profit[0][0][0],profit[0][0][1]=0,-prices[0] for i in range(1,k+1): profit[0][i][0],profit[0][1][1]=-float(&quot;inf&quot;),-float(&quot;inf&quot;) for i in range(1,len(prices)): profit[i][0][0]=profit[i-1][0][0]#第i天第0次交易无股票等于第i-1天第0次交易 profit[i][0][1]=max(profit[i-1][0][1],profit[i-1][0][0]-prices[i]) #第i天第0次交易但有股票的值等于第i天没有买股票即profit[i-1][0][1]和第i天买股票即profit[i-1][0][0]-prices[i]的利益的最大值 for j in range(1,k): profit[i][j][0]=max(profit[i-1][j][0],profit[i-1][j-1][1]+prices[i]) #第i天第j次无股票的值等于第i天没有买股票和第i天买股票的利益的最大值 profit[i][j][1]=max(profit[i-1][j][1],profit[i-1][j][0]-prices[i]) #第i天第j次有股票的值等于第i天没有卖股票即profit[i-1][j][1]和第i天卖股票即profit[i-1][j][0]-prices[i]的最大值 profit[i][k][0]=max(profit[i-1][k][0],profit[i-1][k-1][1]+prices[i]) #第i天第k次无股票的值等于第i-1天已进行k次交易即profit[i-1][k][0]与第i天刚完成第k次交易profit[i-1][k-1][1]+prices[i]的最大值 maxProfit=-float(&quot;inf&quot;) for j in range(0,k+1):#maxProfit等于最后一天的第0次交易到第k次交易中的最大值 if profit[len(prices)-1][j][0]&gt;maxProfit: maxProfit=profit[len(prices)-1][j][0] return maxProfitprices=[3,2,6,5,0,3]k=2print(maxProfit(prices,k)) 7、天平秤金条问题问题描述：有30根金条，其中一根比其它的要重，请问用一个天平至少秤几次可以将这个重的金条找出来。示例1：输入：[10, 10, 10, 10, 10, 11] 输出：The fake coin is coin 6 in the original list Number of weighings: 2示例2：输入：[10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 10, 10] 输出：The fake coin is coin 25 in the original list Number of weighings: 37求比较重的金块，首先想到平分金块，但当我把程序后发现与要求输出的不一样，刚开始以为是程序错了，结果发现是算法错了，用最少的步数要找到重的金快可以用3分法，比较前2堆金快，若不一样则在重的那一堆继续3分，若一样则在第3份继续3分，而且这种方法的算法也更简单，不需要考虑金快为奇数还是偶数，在程序中，由于要找到是第几块金快比较重，使用left与right作为函数参数来记录金快的位置 1234567891011121314151617181920212223def HeavierGold(golds,left,right):#golds为金块重量，left,right为比较的范围 l=(right-left +1)//3#使用3分法，将金块分为3份 global number#全局变量为number，记录称重的次数，初值为-1，每次称重前+1 number+=1 if right == left:#right==left,即为较重的金块 return(left+1) elif left+1 == right:#left+1 == right,则较重的金块在这2块之中，故返回较重的金块 if golds[right] &lt; golds[left]: return(left+1) else: return(right+1) if sum(golds[left:left+l])==sum(golds[left+l:left+2*l]):#如果第一堆金块重量等于第二堆金块重量，则返回对第三堆金块的寻找 return HeavierGold(golds,left+2*l,right) elif sum(golds[left:left+l])&lt;sum(golds[left+l:left+2*l]):#如果第一堆金块重量小于第二堆金块重量，则返回对第二堆金块的寻找 return HeavierGold(golds,left+l,left+2*l-1) else:#如果第一堆金块重量大于第二堆金块重量，则返回对第一堆金块的寻找 return HeavierGold(golds,left,left+l-1)golds=[10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,10,10]number=-1i=HeavierGold(golds,0,len(golds)-1)print(&#x27;The hevaier gold is coin &#x27;+str(i)+&#x27;in the original list&#x27;)print(&#x27;Number of weighings:&#x27;+str(number)) . 8、动态规划解最短路径问题问题描述：从某顶点出发，沿图的边到达另一顶点所经过的路径中，求各边上权值之和最小的一条路径——最短路径。示例：输入如下图（图的输入形式自行确定）：输出：从A到G的最短路径长度为： 18 经过的结点为： [‘B1’, ‘C2’, ‘D1’, ‘E2’, ‘F2’] 8.求多段图的最短路径长度，先用邻接矩阵表示出多段图，在用动态规划从终点到起点依次求出每一段的最短路径长度，并且用字典将邻接矩阵的序号与结点A1 B1等相连，最后输出进过的结点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def shortestPath(cost,path,d): for i in range(n-1,0,-1):#i从第n-1到第1个结点表示起点 temp=0 min=c[i][temp]+cost[temp] for j in range(0,n+1):#j从0到n表示目的点 if c[i][j]!=float(&quot;inf&quot;):#当c[i][j]不为无穷大，即从i到j可以到达 if (c[i][j]+cost[j])&lt;min:#取最小的c[i][j] min=c[i][j]+cost[j] temp=j cost[i]=c[i][temp]+cost[temp]#cost[i]记录i到n的最短路径 d[i]=temp path[1]=1 path[k]=n for i in range(2,k): path[i]=d[path[i-1]]global n,k#n为结点个数，k为多段图的段数n,k=16,7c=[[float(&quot;inf&quot;) for i in range(n+1)]for i in range(n+1)]#用邻接矩阵表示多段图c[1][2]=5c[1][3]=3c[2][4]=1c[2][5]=3c[2][6]=6c[3][5]=8c[3][6]=7c[3][7]=6c[4][8]=6c[4][9]=8c[5][8]=3c[5][9]=5c[6][9]=3c[6][10]=3c[7][9]=8c[7][10]=4c[8][11]=2c[8][12]=2c[9][12]=1c[9][13]=2c[10][12]=3c[10][13]=3c[11][14]=3c[11][15]=5c[12][14]=5c[12][15]=2c[13][14]=6c[13][15]=6c[14][16]=4c[15][16]=3cost=[0]*(n+1)#cost用来记录i到n的最短路径长度d=[0]*npath=[0]*(k+1)#path记录最短路径的进过的结点shortestPath(cost,path,d)map=&#123;&#x27;1&#x27;:&#x27;A&#x27;,&#x27;2&#x27;:&#x27;B1&#x27;,&#x27;3&#x27;:&#x27;B2&#x27;,&#x27;4&#x27;:&#x27;C1&#x27;,&#x27;5&#x27;:&#x27;C2&#x27;,&#x27;6&#x27;:&#x27;C3&#x27;,&#x27;7&#x27;:&#x27;C4&#x27;,&#x27;8&#x27;:&#x27;D1&#x27;,&#x27;9&#x27;:&#x27;D2&#x27;,&#x27;10&#x27;:&#x27;D3&#x27;,&#x27;11&#x27;:&#x27;E1&#x27;,&#x27;12&#x27;:&#x27;E2&#x27;,&#x27;13&#x27;:&#x27;E3&#x27;,&#x27;14&#x27;:&#x27;F1&#x27;,&#x27;15&#x27;:&#x27;F2&#x27;,&#x27;16&#x27;:&#x27;G&#x27;&#125;#map是字典用来记录结点序号与结点名称的对应print(&quot;从A到G的最短路径长度为： &quot;+str(cost[1]))print(&#x27;经过的结点为： [&#x27;,end=&#x27;&#x27;)for i in range(2,k-1): print(&quot;&#x27;&quot;+map[str(path[i])]+&quot;&#x27;,&quot;,end=&#x27;&#x27;)print(map[str(path[k-1])]+&quot;&#x27;] &quot;)","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:21:01.052Z","path":"wiki/计算机基础知识/算法笔记/情侣牵手，分发糖果，跳跃游戏，单源最短路径Dijkstra算法，贪心算法构造霍夫曼编码/","text":"1、情侣牵手问题描述：N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。一次交换可选择任意两人，让他们站起来交换座位。人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。这些情侣的初始座位 row[i] 是由最初始坐在第 i 个座位上的人决定的。示例1：输入: row &#x3D; [0, 2, 1, 3] 输出: 1 解释: 我们只需要交换row[1]和row[2]的位置即可。示例2：输入: row &#x3D; [3, 2, 0, 1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 2、分发糖果问题描述：老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：（1）每个孩子至少分配到 1 个糖果；（2）相邻的孩子中，评分高的孩子必须获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？示例 1: 输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。示例 2: 输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 3、跳跃游戏问题描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明: 假设你总是可以到达数组的最后一个位置。 4、编程实现单源最短路径Dijkstra算法，并回答如果将图中所有边的权重+1，所得到的最短路径是否仍为原最短路径，为什么？5、证明题：请证明利用贪心算法构造的霍夫曼编码的正确性。三、实验内容及结果1、情侣牵手问题描述：N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。一次交换可选择任意两人，让他们站起来交换座位。人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。这些情侣的初始座位 row[i] 是由最初始坐在第 i 个座位上的人决定的。示例1：输入: row &#x3D; [0, 2, 1, 3] 输出: 1 解释: 我们只需要交换row[1]和row[2]的位置即可。示例2：输入: row &#x3D; [3, 2, 0, 1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 利用贪心算法，想到当找到一对座位上的人不是一对情侣时，则遍历后面的每个座位直到找到情侣与第二个座位上的人相互调换，而在代码中寻找情侣时使用x^1，x异或1即x为奇数即为x-1，x为偶数即为x+1，能得到相应的情侣，由贪心算法这样就能得到最少交换次数。 123456789101112131415161718def minSwapsCouples(row): num=0 for i in range(0,len(row),2):#每次遍历2个位置 x=row[i]#x为第一个位置的值 if row[i+1]==x^1:#x^1异或操作当x为奇数即为x-1，x为偶数即为x+1，可以完美表示x的情侣的序号 continue num+=1#当没有coninue重新循环说明row[i+1]不是情侣，则num+1 for j in range(i+2,len(row)): #对i+2后的数遍历，找到情侣交换而且由贪心算法可得出该方式为最少的交换方式 if row[j] == x^1: row[i+1],row[j] = row[j],row[i+1] break return numrow1 = [1,2,0,3]print(minSwapsCouples(row1))row2 = [3, 2, 0, 1]print(minSwapsCouples(row2)) 2、分发糖果问题描述：老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：（1）每个孩子至少分配到 1 个糖果；（2）相邻的孩子中，评分高的孩子必须获得更多的糖果。那么这样下来，老师至少需要准备多少颗糖果呢？示例 1: 输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。示例 2: 输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 分发糖果，先从左边遍历，比左边分数高，则糖果为左边的糖果加1，比左边的小即仍为1，再从右边遍历，如果左边分数更高但是右边糖果数多时，说明没有符合分数高的糖果多的原则，则等于糖果数等于右边的加1. 12345678910111213141516171819def distributeCandy(scores): if len(scores)&lt;=1: return len(scores) candy=[1 for i in range(len(scores))]#candy[i]记录第i个人该分的糖果 for i in range(1,len(scores)): #从左向右遍历，当右边的分数高时，candy[i]=candy[i-1]+1 if scores[i]&gt;scores[i-1]: candy[i]=candy[i-1]+1 for i in range(len(scores)-2,-1,-1): #从右到左遍历，当左边分数高且右边的糖果多时，重新记录candy[i]=candy[i+1]+1 if scores[i]&gt;scores[i+1] and candy[i]&lt;=candy[i+1]: candy[i]=candy[i+1]+1 return sum(candy)scores1=[1,0,2]print(distributeCandy(scores1))scores1=[1,2,2]print(distributeCandy(scores1)) 3、跳跃游戏问题描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明: 假设你总是可以到达数组的最后一个位置。 3.从1遍历，每次加上该点跳跃的求出所能到达的最远距离reach，n表示跳的次数+1，当最远距离reach大于最远点时，说明可以到达，返回n 123456789101112def jump(nums): leng,reach,n=len(nums),0,0#leng为数组的长度，reach为到达的最远距离，n为跳跃的最小次数 for i in range(leng): #对数组依次遍历，当i&lt;=reach时，重新记录所能跳跃的最远点reach，n+1 if i&lt;=reach: reach=max(reach,i+nums[i]) n+=1 if reach&gt;=leng-1:#当reach大于等于最远点时，返回n return nnums=[2,3,1,1,4]print(jump(nums)) 4、编程实现单源最短路径Dijkstra算法，并回答如果将图中所有边的权重+1，所得到的最短路径是否仍为原最短路径，为什么？ Dijkstra算法，单源最短路径每次寻找路径中最短的点u，用松弛操作一一遍历出发点s到该点u加上到其他点v的距离与出发点s到点v的距离，由于对每个点都遍历了Q中的所有点，就相当于对s到v的每条路径都进行了遍历找到最近的距离，这样就可以找到Q里面剩下的v到s的最短距离。将图中所有边的权重+1，所得到的最短路径不是原最短路径，因为到最短路径的边数可能很多，只不过每条边都很短，比其他路径长的路径距离更短，但加上1即加上路径的边数，这样原来的最短路径就可能比别的路径长度更长。 1234567891011121314151617181920212223242526272829303132333435363738394041def Dijkstra(G,s): numVertex = len(G)#邻接矩阵的长度即点的个数 Q=[]#记录尚未找到最短路径各个结点 D = &#123;&#125; #记录s到各点的最短路径 precursorNode = &#123;&#125; #表示每个结点最短路径的前驱结点 for i in range(numVertex):#初始化Q，D，precursorNode Q.append(i) D[i] = 2**32 - 1 precursorNode[i] = &#x27;null&#x27; D[s] = 0 #s到s的距离为0 while(Q):#当Q未完全遍历完时 u=extract_min_queue(Q,D)#首先找到剩下的点中到s路径最短的点 for v in range(numVertex):#v遍历所有的点，经过多次松弛可以对每条路径都进行遍历从而找到各个点的最短路径 if G[u][v] == 0: # G[u][v] == 0说明点u与点v不可到达 continue realx(D,G,precursorNode,u,v)#当u与v有路径到达时，对（u，v）进行松弛操作 print (&#x27;distance:&#x27;, D)#输出各个点的最短路径 print (&#x27;precursorNode:&#x27;, precursorNode)#输出各个点最短路径的前驱结点 def extract_min_queue(Q,D):#提取Q中最短路径的点 min_dist = 2**32 - 1#最短路径长度 min_index = None#最短路径的点 for vertex in Q:#在尚未找到最短路径的结点中找到路径最短的点，并记录min_dist，min_index if D[vertex] &lt; min_dist: min_dist = D[vertex] min_index = vertex Q.remove(min_index)#当找到最短路径的点后从Q中删除这个点 return min_index#返回最短路径的点def realx(D,G,precursorNode,u,v):#松弛(u,v)可以更新s到v的最短路径与前驱结点 if D[v] &gt; D[u] + G[u][v]:#如果（s，v）的距离大于（s，u）的距离加上（u，v）的距离则更新D[v]与前驱结点 D[v] = D[u] + G[u][v] precursorNode[v] = uG = [[0,3,0,0,5], [0,0,6,0,2], [0,0,0,2,0], [3,0,7,0,0], [0,1,4,6,0]]Dijkstra(G, 0) 证明题：请证明利用贪心算法构造的霍夫曼编码的正确性。首先知道霍夫曼编码有贪心选择和最优子结构心智，那么用反证法，假设利用贪心算法得到的霍夫曼编码不是最优编码，设利用贪心算法得到的编码树为T1，就存在最优编码树T2满足B（T1）&gt;B(T2)，那么将T2与T1其中一个不同的子节点x与x在T1上的位置的结点y对换，有贪心算法知x&lt;y，而对换后的树设为T3，易知B（T2）&gt;B(T3)&gt;&#x3D;B(T1),所以不存在其他的最优霍夫曼树，即由贪心算法构造的霍夫曼树为最佳树，也证明了利用贪心算法构造的霍夫曼编码的正确性 四、实验总结 （根据实验写出一些心得或分析等） 本次实验让我更加理解了贪心算法以及单源最短路径的算法与霍夫曼树的构造，让我在面对一些问题时有了新的思考方法。","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:20:54.483Z","path":"wiki/计算机基础知识/算法笔记/图的着色问题，0-1背包问题，单词必须按照字母顺序，所有学生中的已知的朋友圈总数，计算矩阵中所有池塘的大小/","text":"一、实验目的及要求 1、世界地图上相邻国家需要用不同的颜色标注以示区别，但最多只需要选取四种颜色即可。请编程实现图的着色问题。2、编程实现0-1背包问题，至少两种算法。3、给定一个二维网格和一个单词，找出该单词是否存在于网格中。说明：单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。示例：board &#x3D;[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]] ，给定 word &#x3D; “ABCCED”, 返回 true， 给定 word &#x3D; “SEE”, 返回 true， 给定 word &#x3D; “ABCB”, 返回 false。 4、班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] &#x3D; 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。示例1：输入: [[1,1,0], [1,1,0], [0,0,1]] 输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。示例2：输入: [[1,1,0], [1,1,1], [0,1,1]] 输出: 1 说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 5、你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。示例：输入：[[0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1]] 输出： [1,2,4] 三、实验内容及结果（包括实验过程、实验数据、实验结果及分析，实验代码另外单独附页）1、世界地图上相邻国家需要用不同的颜色标注以示区别，但最多只需要选取四种颜色即可。请编程实现图的着色问题。 使用回溯法，有1,2,3,4四种颜色，而地图如关系矩阵所示。从第一个位置颜色为1，接着依次往下遍历，使用与相邻的不同的颜色，如果这样下去无法满足4种颜色填色，则说明之前填色有误，回溯到之前一个位置，如果该位置4种颜色都不行，则继续回溯直到满足条件。当关系矩阵M如图中所示时，地图的各个位置颜色如输出所示。 123456789101112131415161718192021222324252627282930313233343536def FourColorLabel(M):#回溯法地图四色 Num=len(M) Color=[-1 for i in range(Num)] n=m=1 #染色第一个区域，先设置为1 while m&lt;=Num: while n&lt;=4 and m&lt;=Num: flag=True for k in range(m-1): if M[m-1][k]==1 and Color[k]==n:#如果与第m-1个点接触且颜色相同则回溯 flag=False n+=1 break if flag:#flag为true,则涂色 Color[m-1]=n; m+=1 n=1 if n&gt;4: #颜色使用超过4种，说明之前涂色有问题，回溯 m-=1 n=Color[m-1]+1 return Color M=[ [0,1,0,0,0,0,1], [1,0,1,1,1,1,1], [0,1,0,1,0,0,0], [0,1,1,0,1,0,0], [0,1,0,1,0,1,0], [0,1,0,0,1,0,1], [1,1,0,0,0,1,0] ]#关系矩阵，M[i][j]为1则表示i与j相邻，为0则表示不相邻for i in FourColorLabel(M):print(i) 2、编程实现0-1背包问题，至少两种算法。 使用了2种算法，第一种是动态规划法，使用数组c记录最大价值，c[i][j]表示前i个物体放入容量为j 包的最大价值，c[i-1][j] 表示前i个物体放入容量为j 包的最大价值 ，c[i-1][j-w[i]] 表示前i-1个物体放入容量为j-w[i] 包的最大价值，而c[i][j]到第i个物品时有放入和不放入2种选择，取这2选择的最大值，这样利用动态规划算法可以求出c[i][j]所有的值，能求出最大价值，然后利用show函数输出选择的物品。第二种方法为回溯法，利用全局变量bestV最大价值currW当前背包重量currV当前背包价值bestx最优选择物品，每次回溯有选并记录当前值与不选往后遍历两种选择，遍历到最后一个物品时与bestV比较。 1234567891011121314151617181920212223242526272829303132333435363738#n：物品件数；c:最大承重为c的背包；w:各个物品的重量；v:各个物品的价值#w[i]：第i个物体的重量 #p[i]：第i个物体的价值 #c[i][j]：前i个物体放入容量为j 包的最大价值 #c[i-1][j]：前i个物体放入容量为j 包的最大价值 #c[i-1][j-w[i]]：前i-1个物体放入容量为j-w[i] 包的最大价值def knapsack(n,c,w,p):#动态规划算法求出最大价值 res=[[-1 for j in range(c+1)]for i in range(n+1)] for j in range(c+1): #第0行全部赋值为0，物品编号从1开始.为了下面赋值方便 res[0][j]=0 for i in range(1,n+1): for j in range(1,c+1): res[i][j]=res[i-1][j] #生成了n*c有效矩阵，以下公式w[i-1],p[i-1]代表从第一个元素w[0],p[0]开始取。 if(j&gt;=w[i-1]) and res[i-1][j-w[i-1]]+p[i-1]&gt;res[i][j]: res[i][j]=res[i-1][j-w[i-1]]+p[i-1] return resdef show(n,c,w,res):#输出最大价值和选择的物品 print(&#x27;最大价值为:&#x27;,res[n][c]) x=[False for i in range(n)] j=c for i in range(1,n+1): if res[i][j]&gt;res[i-1][j]:#res[i][j]&gt;res[i-1][j]则表示第i个物品放入背包 x[i-1]=True j-=w[i-1] print (&quot;选择的物品为:&quot;,end=&quot; &quot;) for i in range(n): if x[i]: print(&#x27;第&#x27;,i+1,&#x27;个&#x27;,end=&quot; &quot;)if __name__==&#x27;__main__&#x27;: n=5 c=10 weight=[2,2,6,5,4] price=[6,3,5,4,6] res=knapsack(n,c,weight,price) show(n,c,weight,res) 1234567891011121314151617181920212223242526272829bestV = 0 # 最大价值currW = 0 # 当前背包重量currV = 0 # 当前背包价值bestx = None # 最优解def backtrack(i):#深度优先策略搜索回溯法实现01背包,i表示从回溯到第i个物品 global bestV,bestx,currV,currW,x#全局变量使不同深度的遍历时记录相同 if i&gt;= n:#遍历i到最后一个物品时，比较当前背包重量与最大背包重量，与最优解 if bestV&lt;currV: bestV = currV bestx = x[:] else:#当i小于n时 if currW+w[i]&lt;=c:#如果选择第i个物品后重量小于最大值，则记录选择第i个物品后的值 x[i]=1 currW += w[i] currV += v[i] backtrack(i+1) currW -= w[i] currV -= v[i] x[i]=0#记录后将第i个物品设置为不选，对第i+1个物品进行选择 backtrack(i+1)n=5c=10w=[2,2,6,5,4]v=[6,3,5,4,6]x=[False for i in range(n)]backtrack(0)print(bestV)print(bestx) 3、给定一个二维网格和一个单词，找出该单词是否存在于网格中。说明：单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。示例：board &#x3D;[ [‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]] ，给定 word &#x3D; “ABCCED”, 返回 true， 给定 word &#x3D; “SEE”, 返回 true， 给定 word &#x3D; “ABCB”, 返回 false。 本题利用回溯法解决单词搜索问题，首先directions为四个方向，而从左上角开始，依次改变开始位置，依次往四个方向上在网格中遍历，且用mark记录是否已遍历，如果找不到，则回溯重新遍历，只要有一次开始位置使回溯返回结果为true即返回true。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): # 定义上下左右四个行走方向 directs = [(0, 1), (0, -1), (1, 0), (-1, 0)] def exist(self, board, word): m = len(board)#m表示二维矩阵宽 if m == 0: return False n = len(board[0])#n表示二维矩阵场 mark = [[0 for _ in range(n)] for _ in range(m)]#mark[i][j]记录是否遍历过,1表示已遍历，0表示没有 for i in range(len(board)): for j in range(len(board[0])):#每次从board[i][j]开始遍历 if board[i][j] == word[0]: # 将该元素标记为已使用 mark[i][j] = 1 if self.backtrack(i, j, mark, board, word[1:]) == True:#只要有一次返回true则函数返回true return True else: # 回溯 mark[i][j] = 0 return False def backtrack(self, i, j, mark, board, word):#从board[i][j]开始遍历，mark[i][j]记录是否遍历过，board为二维数组,word为单词 if len(word) == 0: return True for direct in self.directs:#每次都按上，下，右，左遍历 cur_i = i + direct[0] cur_j = j + direct[1] if cur_i &gt;= 0 and cur_i &lt; len(board) and cur_j &gt;= 0 and cur_j &lt; len(board[0]) and board[cur_i][cur_j] == word[0]:#保证board[cur_i][cur_j]不越界且等于word[0] if mark[cur_i][cur_j] == 1:# 如果是已经使用过的元素，忽略 continue mark[cur_i][cur_j] = 1# 将该元素标记为已使用 if self.backtrack(cur_i, cur_j, mark, board, word[1:]) == True: return True else: # 不满足条件则回溯 mark[cur_i][cur_j] = 0 return Falseif __name__ == &#x27;__main__&#x27;: board = [ [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;E&#x27;], [&#x27;S&#x27;, &#x27;F&#x27;, &#x27;C&#x27;, &#x27;S&#x27;], [&#x27;A&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;E&#x27;] ] solution = Solution() word = &quot;ABCCED&quot; res = solution.exist(board, word) print(res) 4、班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] &#x3D; 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。示例1：输入: [[1,1,0], [1,1,0], [0,0,1]] 输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。示例2：输入: [[1,1,0], [1,1,1], [0,1,1]] 输出: 1 说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 使用宽度优先遍历搜索算法，依次遍历，当该点能够到达其他点即为朋友时，使他们的queue设为同1值，且res+1即朋友圈数+1,且将遍历的点踢出点集。 1234567891011121314151617181920def findCircleNum(M): N, visited, res = len(M), set(), 0 for i in range(N):#宽度优先搜索算法 if i not in visited:#当第i个未被访问时 queue = [i] while queue:#while将所有从第i个人能够达到的人遍历完 p = queue.pop(0) if p not in visited: visited.add(p)#从i能够到达的点加入visited queue += [k for k, num in enumerate(M[p]) if num and k not in visited] #queue加入通过enumerate(M[p])遍历的所能达到的未被遍历的点 res += 1#一次遍历完，res+1 return resM=[[1,1,0], [1,1,0], [0,0,1]]print(findCircleNum(M)) 5、你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。示例：输入：[[0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1]] 输出： [1,2,4] 该题也利用宽度优先遍历算法，当找到一个高度为0时，向垂直、水平或对角连接八个方向依次遍历，且对遍历过的点设置已访问，当8个方向都没有高度为0时，记下这个池塘的大小，然后从其他高度为0的点继续遍历记下大小，最后返回从小到大排序后的结果。 1234567891011121314151617181920212223242526272829303132333435363738class Solution: def pondSizes(self,land): areas = []# 水域面积存储数组 visit = [[0 for _ in range(len(land[0]))] for _ in range(len(land))]# 记录访问数组 steps = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]] #垂直、水平或对角连接八个方向 def bfs(x, y):#宽度优先搜索算法 area = 1 q = [[x, y]] visit[x][y] = 1 while q:#一次遍历出q的8个方向上所有的水域点 p = q.pop(0)#判断p=q[0]是否为水域 for i in steps:#对8个方向依次遍历是否存在水域 dx, dy = p[0] + i[0], p[1] + i[1] if 0 &lt;= dx &lt; len(land) and 0 &lt;= dy &lt; len(land[0]) and land[dx][dy] == 0 and visit[dx][dy] == 0: #判断是否在土地内 q.append([dx, dy])#每次当8个方向的点在土地上时，就加入q中 area += 1 visit[dx][dy] = 1 areas.append(area)#当q旁的所有满足条件的点遍历完后计入areas中 for i in range(len(land)): for j in range(len(land[0])): if land[i][j] == 0 and visit[i][j] == 0:#当land[i][j]为水域时且未被访问时就从该点宽度优先搜索 bfs(i, j) return sorted(areas)#返回从小到大排序后的结果if __name__ == &#x27;__main__&#x27;: solution = Solution() land=[ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1]] sizes=solution.pondSizes(land) print(sizes) 四、实验总结 （根据实验写出一些心得或分析等）这次实验让我更加体会了回溯法与深度宽度遍历算法，虽然算法很好理解，但在代码编写时感觉有些困难，对许多细节方面有所不足。","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:20:15.163Z","path":"wiki/计算机基础知识/算法笔记/递归+回溯法/","text":"1、假设A、B、C、D、E各城市间路费如下表所列，左起一列是起点，上面一行是终点，即从A到B的旅费是7，从B到A时6。某人想从一个城市出发游览各城市一遍，在回到出发地，而所用的旅费最少。请编写一程序，求出从各地出发回到出发地的所有最佳路线。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class work1 &#123; static int N=5; int Max=Integer.MAX_VALUE; char[] City=new char[]&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;; int map[][]=&#123;&#123;Max,7,3,10,15&#125;,&#123;6,Max,5,13,12&#125;,&#123;4,8,Max,5,10&#125;,&#123;9,11,6,Max,11&#125;,&#123;17,14,9,8,Max&#125;&#125;; int[] visited=new int[N]; //该城市是否访问 int[] visit=new int[N];; //记录第i次去的城市 int[] road=new int[N];; //路线 int cost; //费用 int start;//起点城市 int c; //输出行程 void print()&#123; System.out.print(&quot;从城市&quot;+City[start]+&quot;出发的最短行程为：&quot;); for(int j=0;j&lt;N;j++) System.out.print(City[road[j]]+&quot;-&gt;&quot;); System.out.print(City[start]); System.out.println(&quot;费用为：&quot;+cost); &#125; //初始化 void init()&#123; cost=Max; c=0; for(int i=0;i&lt;N;i++)&#123; visited[i]=0; visit[i]=-1; &#125; &#125; void Travel(int n)&#123; if(n==N)&#123; //全部城市旅游完 if(c+map[visit[n-1]][start]&lt;cost)&#123; //返回起点且总费用最少 for(int j=0; j&lt;n; j++) road[j]=visit[j]; cost=c+map[visit[n-1]][start]; return; &#125; &#125; else&#123; for(int i=0;i&lt;N;i++)&#123; if(visited[i]==0&amp;&amp;c+map[visit[n-1]][i]&lt;cost) &#123; visit[n]=i; visited[visit[n]]=1; c+=map[visit[n-1]][i]; Travel(n+1);//搜索下一个城市 c-=map[visit[n-1]][i]; //返回，删除节点 visited[visit[n]]=0; &#125; &#125; &#125;&#125; public static void main(String[] args) &#123; work1 work=new work1(); for(int i=0;i&lt;N;i++)&#123; work.init(); work.start=i; work.visit[0]=i;//设置出发点 work.visited[work.start]=1; work.Travel(1); work.print(); &#125; &#125;&#125; 2、一块土地上，农民可以种水稻、大豆、燕麦或牧草这四种作物。一年的收益不仅与当年种什么有关，还与去年种什么有关。它们之间的关系如下表。如果农民作一个五年生产计划，已知第一年种植之前种的是牧草。问各年应种什么，使收益最大？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class work4 &#123; static int N=5; String[] X=new String[]&#123;&quot;水稻&quot;,&quot;大豆&quot;,&quot;燕麦&quot;,&quot;牧草&quot;&#125;; int map[][]=&#123;&#123;3,2,4,1&#125;,&#123;15,1,17,7&#125;,&#123;9,4,6,5&#125;,&#123;11,1,4,3&#125;&#125;; int[] visit=new int[N+1];; //记录第i次暂时种的作物 int[] Crops=new int[N+1];; //记录最大值时每年种的作物 int money; //收益 int temp; void print()&#123; for(int j=1;j&lt;N+1;j++) System.out.print(&quot;第&quot;+j+&quot;年种&quot;+X[Crops[j]]+&quot;-&gt;&quot;); System.out.println(&quot;收货为：&quot;+money); &#125; void init()&#123;//初始化 money=0; temp=0; for(int i=0;i&lt;N;i++)&#123; visit[i]=-1; &#125;&#125; void crop(int n)&#123; if(n==N) for(int i=0;i&lt;4;i++)&#123; if(temp+map[visit[N-1]][i]&gt;money)&#123; for(int j=0; j&lt;n; j++) Crops[j]=visit[j]; money=temp+map[visit[n-1]][i]; return; &#125; &#125; else&#123; for(int i=0;i&lt;4;i++)&#123; visit[n]=i; temp+=map[visit[n-1]][i]; crop(n+1);//下一年 temp-=map[visit[n-1]][i]; //返回，删除节点 &#125; &#125;&#125; public static void main(String[] args) &#123; work4 work=new work4(); work.init(); work.visit[0]=3;//设置出发点 work.crop(1); work.print(); &#125;&#125; 二、代码思路总结一下回溯法的关键，首先需要一个temp函数来记录目前的花费或收益，最后输出的变量result；对于像第一题这种遍历过后不用重复遍历的，需要用visited[]来记录当前结点是否被访问过，若被访问过则不再访问，而第2题可重复遍历则不用使用visited[]记录；此外还必须使用visit[]记录当前访问的结点路径，这是类似temp来暂存访问路径的数组，然后在有一个最后输出的数组road[]。之后有一个递归函数，在函数中更新temp，visited[]与visit[]，且递归函数一定要有递归退出条件，如这两道题中的n&#x3D;&#x3D;N判断是否递归退出，在退出时判断temp与result，如果当前的temp较大，则把visit[]与temp赋值给road[]与result，这样重复递归遍历多次，最后递归完成的result则为所求的最值。","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"LeetCode409.最长回文串","date":"2023-02-15T02:20:08.835Z","path":"wiki/计算机基础知识/算法笔记/LeetCode409. 最长回文串/","text":"解题思路桶装法，字母出现偶数次一定可以计入总长度，再用count记录所有奇数余1次数，最后用长度减去count+1，因为所有的余1只能留下一个当中心 代码123456789101112131415class Solution &#123; public int longestPalindrome(String s) &#123; // 找出可以构成最长回文串的长度 int[] arr = new int[128]; for(char c : s.toCharArray()) &#123; arr[c]++; &#125; int count = 0; for (int i : arr) &#123; count += (i % 2);//比如有5个a，可以取4个a形成回文串，count记录所有奇数余1次数，最后只能加1次 &#125; return count == 0 ? s.length() : (s.length() - count + 1); &#125;&#125;//s.toCharArray","tags":[{"name":"算法","slug":"算法","permalink":"https://pistachiout.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://pistachiout.github.io/tags/Java/"}],"categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://pistachiout.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"LeetCode459.重复的子字符串","date":"2023-02-15T02:20:00.787Z","path":"wiki/计算机基础知识/算法笔记/LeetCode459. 重复的子字符串/","text":"## 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。** 法一：KMP算法使用123456789101112131415161718192021222324252627class Solution &#123; public boolean repeatedSubstringPattern(String s)&#123; int[] next = new int[s.length()]; getNext(next,s); //最后一位最长相等前后缀为0，说明没有可重复的子串 if(next[s.length() -1] == 0)&#123; return false; &#125;else&#123; //若最后一位最长相等前后缀不为0，s-最长相等前后缀的长度为可重复的子串，若可以被s整除则可一直循环此子串 return s.length() % (s.length() - next[s.length() -1]) == 0; &#125; &#125; //next数组--求最长相等前后缀 public void getNext(int[] next, String s)&#123; int j = 0; next[0] = 0; for (int i = 1; i &lt; s.length(); i++) &#123; while(j &gt; 0 &amp;&amp; s.charAt(i) != s.charAt(j))&#123; j = next[j-1]; &#125; if(s.charAt(i) == s.charAt(j))&#123; j++; &#125; next[i] = j; &#125; &#125;&#125; 法二：暴力枚举求解双循环，i从1到n&#x2F;2表示子串长度，j与j-i在i的循环内每次从i到n如ababab，i&#x3D;2时，令j&#x3D;i，j与j-i同步向后遍历，若出现不同，则返回false。 123456789101112131415161718192021class Solution &#123; public boolean repeatedSubstringPattern(String s) &#123; int n = s.length(); for (int i = 1; i * 2 &lt;= n; ++i) &#123;//双循环，i从1到n/2表示子串长度，j与j-i在i的循环内每次从i到n //如ababab，i=2时，令j=i，j与j-i同步向后遍历，若出现不同，则返回false。 if (n % i == 0) &#123; boolean match = true; for (int j = i; j &lt; n; ++j) &#123; if (s.charAt(j) != s.charAt(j - i)) &#123; match = false; break; &#125; &#125; if (match) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://pistachiout.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://pistachiout.github.io/tags/Java/"}],"categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"https://pistachiout.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:19:53.677Z","path":"wiki/计算机基础知识/算法笔记/LeetCode461. 汉明距离/","text":"两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。 1.x ^ y异或，用f(x)&#x3D;x &amp; (x−1)）次数求二进制中1的个数，那么 f(x) 恰为x删去其二进制表示中最右侧的1的结果。class Solution { public int hammingDistance(int x, int y) { int s &#x3D; x ^ y, ret &#x3D; 0; while (s !&#x3D; 0) { s &amp;&#x3D; s - 1;&#x2F;&#x2F;f(x)&#x3D;x &amp; (x−1)），那么 f(x) 恰为x删去其二进制表示中最右侧的1的结果。 ret++; } return ret; }} 2.x^y异或，Integer.bitCount记录1的个数class Solution { public int hammingDistance(int x, int y) { return Integer.bitCount(x ^ y); }}","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T02:19:26.779Z","path":"wiki/软件项目/Android项目/Android图片，视频，音乐选择播放器/","text":"1、设计目的为了更加深入的了解Android开发，我最初是打算设计是建立一个相册或视频相关的多媒体的应用，但一次偶然的机会我看到了在github中一个框架，该框架中定义了许多有关图片和视频相关操作的方法，而且能够获取到手机本地的文件，而不像之前的应用需要导入到drawable中或在网上获取，于是本次课程设计我决定利用githubhttps://github.com/LuckSiege/PictureSelector的开源框架做一个能够查看手机后台存储数据的应用，这样方便的找出手机中存储在各个位置的图片音乐视频等，比如手机拍摄的图片，本地下载的视频，或者本地下载的音乐等，在选择时进行预览方便选择，类似于手机相册。 2、功能描述 预览查看手机存储的照片，视频和音频，可以通过应用找到手机中存储的各类型照片，视频和音频，包括png，jpg，jpeg等格式 单选或多选手机本地存储的照片，音频和视频，将选择的照片视频音频返回到首页显示 拍照，录像或录音，将结果返回到首页展示 在首页播放选择的照片视频和音频 3、详细设计3.1 系统业务逻辑业务逻辑流程图 3.2 系统功能模块设计 3.3 系统界面设计 首页：显示自己选择的文件。 操作选项页面，在首页点击后进入操作选择页面，可以选择是添加照片和视频还是音频，亦或者是拍照。 本地文件展示页面：将手机本地的文件（图片，视频，音频）以类似手机相册的方式显示，可以进行选择和预览 文件预览页面：点击想要选择的文件，会预览文件 4、程序实现首先由于我用了第三方的集成框架，所以首先要利用gradle导入allprojects { repositories { jcenter() maven { url ‘https://jitpack.io‘ } }}然后建立layout中的xml文件，首先首页利用RecyclerView来便于将选择的图片进行排列，在利用相对布局和imageview以及库中的layout将图片视频等展示出来。在MainActivity中，利用getviewbyid获取到layout中的ui控件，new一个GridImageAdapter来存放选择的文件，然后判断利用库中集成的函数判断存放的文件的类型，利用switch函数利用集成的不同方法来打开各自对应的文件。 而想要获取到手机本地的文件，还要申请到写的权限 然后给ui控件设计点击相应监听器，利用控件的getid判断响应事件，在每个对应的事件中利用库中的函数将手机本地的相册显示并进行相关的操作。 5.运行结果 选择相册： 左边是我的应用的界面，右边是模拟器中自带的图库的界面，可以看到该应用找到了该模拟器中包括图片的所有文件夹，也获取到了手机本地保存的所有图片和视频。 可以点击图片进行预览，也可以左右滑动选择不同的相册。 选择的图片会返回首页进行展示，在首页也能进入查看页面 当选择音频时，显示本地的所有音频，并在点击后能进行播放 在选择视频后也能进行播放和选择到首页还能够进行录视频，拍照，录音。 6、总结 本次实验我用到了github中的开源库，其中有许多没有在课堂中学过的知识，比如文件操作权限的获取，开源库的导入，对于录像，拍照，录视频等不同拍摄的实现过程。但也有一些学过的 知识获得了加深，比如layout的页面设计中如何将图片排列整齐，如何学习使用RecyclerView；在为控件添加监听事件时利用view的getid和switch来给不同的控件添加事件；利用adapter适配器来放入照片和视频等不同的文件，并在adapter中为每个图片，视频等添加各自的点击响应事件，来完成在首页选择文件的查看。 这个系统也有许多可以改进的地方，比如在导入库和进行使用时出现很多问题，其中解决了一些问题，但也有一些没有解决，如在开源库中还有可以对图片进行裁剪旋转的功能，但在使用时却会关闭应用，并且在日志中也没有显示报错信息，最后没有解决，于是只有放弃这个功能；在进行选择时无法显示文件的名字，图片可以直接看，但视频和音频则必须要打开播放才能确定文件名字。 源码地址https://github.com/1105358600/AndroidPVASelector","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:19:18.515Z","path":"wiki/软件项目/Android项目/Android 数据库编程SQLite实现学生信息管理应用/","text":"Android 数据库编程SQLite一、实验内容1. 构建应用界面布局（1）新建一个安卓工程，在默认的layout主界面中添加一个列表(ListView)，列表绑定一个SimpleAdapter关联学生信息（学号、姓名）。（2）为ListView添加上下文菜单，菜单中包含两个选项（修改学生，删除学生），分别对应学生信息的修改和删除操作。为每个选项添加点击事件完成相应的操作，其中点击修改学生时启动“updateStu”Activity组件。（3）在ListView下方添加一个按钮(Button)，内容为“添加学生”，为按钮添加点击事件，单击按钮是启动“addStu”Activity组件。（4）为“updateStu”和“addStu”Activity组件构建对应的layout界面stuinfo.xml，添加对应的文本框和输出框显示某一个学生的信息（学号、姓名、性别、电话），添加确认按钮(Button)。注意：当由“addStu”Activity启动此界面时，相关输入内容为空白，当由“updateStu”Activity启动此界面时，相关输入内容为该学生的原始信息。 2. 利用SQLite构建数据库交互组件（1）新建一个DpHelper类继承SQLiteOpenHelper，通过构建方法启动数据库连接。构建createtable()方法完成建表操作，在数据库中建立一个学生信息表：（2）构建insert(String id, String name, String sex, String phone)方法实现插入记录操作，构建 delete(String id)方法实现删除记录操作，构建update(String id, String name, String sex, String phone)方法实现更新记录操作，构建select(String id)方法实现查询某一记录操作，构建selectAll()方法实现查询所有记录操作。 3. 实现学生信息管理应用（1）完善相关代码，实现学生信息管理应用的基本功能。包括： 学生信息列表：进入应用程序后，在ListView中自动加载所有已有学生的信息（学号，姓名）。 添加学生：单击“添加学生”按钮，打开相应的界面stuinfo.xml填写新学生信息，单击“确认”按钮后完成 添加学生操作。要求程序能够识别用户输入完整性（学号、姓名为必填项），如果新学生学号与现有学生相同，应提示更换学号。添加完成后返回主界面，同时更新ListView的内容。 删除学生：根据ListView长按位置得到要删除的学生的学号信息，完成删除操作，删除后更新ListView的内容。 修改学生：根据ListView长按位置得到要修改的学生的相关信息，打开相应的界面stuinfo.xml，将学生原始信息自动填入对应的输入框中，点击确认按钮后完成更新学生信息操作。要求程序能够识别用户输入完整性（学号、姓名为必填项），如果新学生学号与现有学生相同，应提示更换学号。修改完成后返回主界面，同时更新ListView的内容。 （2）测试相关功能，添加若干条学生信息（3条以上），再进行信息修改、删除操作的测试。 二：演示截图数据库：没有填入数据时，显示学生，姓名，性别，手机： 插入学生数据： 插入数据后： 单击某行进行学生信息修改： 长按提示是否删除，确认后删除： 如果添加的学号重复：提示学号重复 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;@dimen/item_no_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;@string/no&quot;/&gt; &lt;TextView android:layout_width=&quot;@dimen/item_name_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;@string/name&quot;/&gt; &lt;TextView android:layout_width=&quot;@dimen/item_name_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;性别:&quot;/&gt; &lt;TextView android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; android:text=&quot;@string/phone&quot;/&gt; &lt;/LinearLayout&gt; &lt;ListView android:id=&quot;@+id/lv_contact&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;/ListView&gt; &lt;Button android:id=&quot;@+id/btn_add&quot; android:layout_width=&quot;411dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom&quot; android:layout_marginTop=&quot;@dimen/margin_fix&quot; android:background=&quot;@color/btn_blue&quot; android:text=&quot;@string/add&quot; android:textSize=&quot;@dimen/btn_add_size&quot; /&gt;&lt;/LinearLayout&gt; 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;@dimen/item_no_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:id=&quot;@+id/contact_no&quot; android:textSize=&quot;@dimen/item_font_size&quot;/&gt; &lt;TextView android:layout_width=&quot;@dimen/item_name_width&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:id=&quot;@+id/contact_name&quot; android:textSize=&quot;@dimen/item_font_size&quot;/&gt; &lt;TextView android:id=&quot;@+id/contact_sex&quot; android:layout_width=&quot;90dp&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; /&gt; &lt;TextView android:id=&quot;@+id/contact_phonenumber&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;left&quot; android:textSize=&quot;@dimen/item_font_size&quot; /&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.wsine.west.exp7.DetailActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:id=&quot;@+id/detail_title&quot; android:textSize=&quot;@dimen/title_size&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/no&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_no&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/name&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_name&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;性别:&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_sex&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/phone&quot; android:textSize=&quot;@dimen/label_size&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;EditText android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/Et_phone&quot; android:textSize=&quot;@dimen/label_size&quot;/&gt; &lt;/LinearLayout&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;@dimen/margin_fix&quot; android:layout_gravity=&quot;center&quot; android:id=&quot;@+id/btn_confirm&quot; android:textSize=&quot;@dimen/btn_add_size&quot; android:text=&quot;@string/confirm&quot; android:background=&quot;@color/btn_blue&quot;/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.wsine.west.exp7;/** * Created by West on 2015/11/25. */public class Contact &#123; private int id; private String no; private String sex; private String name; private String phoneNumber; public Contact(String no, String name, String sex, String phoneNumber) &#123; this.no = no; this.sex = sex; this.name = name; this.phoneNumber = phoneNumber; &#125; public Contact(int id, String no, String name, String sex, String phoneNumber) &#123; this.id = id; this.no = no; this.sex = sex; this.name = name; this.phoneNumber = phoneNumber; &#125; public Contact() &#123;&#125; public Contact(String _name, String _phoneNumber) &#123; this.name = _name; this.phoneNumber = _phoneNumber; &#125; public Contact(String _no, String _name, String _phoneNumber) &#123; this.no = _no; this.name = _name; this.phoneNumber = _phoneNumber; &#125; public String getNo() &#123; return no; &#125; public void setNo(String _no) &#123; this.no = _no; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String _name) &#123; this.name = _name; &#125; public String getPhoneNumber() &#123; return phoneNumber; &#125; public void setPhoneNumber(String _phoneNumber) &#123; this.phoneNumber = _phoneNumber; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package com.wsine.west.exp7;import android.content.Context;import android.view.View;import android.view.ViewGroup;import android.widget.SimpleAdapter;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * Created by West on 2015/11/25. */public class MySimpleAdapter extends SimpleAdapter &#123; private ArrayList&lt;Map&lt;String, String&gt;&gt; mData; public ArrayList&lt;Map&lt;String, String&gt;&gt; getmData() &#123; return mData; &#125; public MySimpleAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, int resource, String[] from, int[] to) &#123; super(context, data, resource, from, to); this.mData = (ArrayList&lt;Map&lt;String, String&gt;&gt;)data; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; final int mPosition = position; return super.getView(position, convertView, parent); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.wsine.west.exp7;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import android.widget.Toast;import static android.widget.Toast.LENGTH_SHORT;/** * Created by West on 2015/11/25. */public class MyDatabaseHelper extends SQLiteOpenHelper &#123; private static final String DB_NAME = &quot;Contacts.db&quot;; private static final String TABLE_NAME = &quot;Contacts&quot;; private static final int DB_VERSION = 1; public MyDatabaseHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; String CREATE_TABLE = &quot;create table &quot; + TABLE_NAME + &quot; (_id integer primary key autoincrement, &quot; + &quot;_no text not null, &quot; + &quot;_name text not null, &quot; + &quot;_sex text,&quot; + &quot;_pnumber text);&quot;; db.execSQL(CREATE_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; String DROP_TABLE = &quot;DROP TABLE IF exists &quot; + TABLE_NAME; db.execSQL(DROP_TABLE); onCreate(db); &#125; public long insert(Contact entity) &#123; SQLiteDatabase db = getWritableDatabase(); ContentValues values = new ContentValues(); values.put(&quot;_no&quot;, entity.getNo()); values.put(&quot;_name&quot;, entity.getName()); values.put(&quot;_sex&quot;, entity.getSex()); values.put(&quot;_pnumber&quot;, entity.getPhoneNumber()); long id = db.insert(TABLE_NAME, null, values); db.close(); return id; &#125; public int update(Contact entity,String oldNo) &#123; SQLiteDatabase db = getWritableDatabase(); String whereClause = &quot;_no = ?&quot;; String[] whereArgs = &#123; oldNo&#125;; ContentValues values = new ContentValues(); values.put(&quot;_no&quot;, entity.getNo()); values.put(&quot;_name&quot;, entity.getName()); values.put(&quot;_sex&quot;, entity.getSex()); values.put(&quot;_pnumber&quot;, entity.getPhoneNumber()); int rows = db.update(TABLE_NAME, values, whereClause, whereArgs); db.close(); return rows; &#125; public int delete(Contact entity) &#123; SQLiteDatabase db = getWritableDatabase(); String whereClause = &quot;_no = ?&quot;; String[] whereArgs = &#123; entity.getNo() &#125;; int rows = db.delete(TABLE_NAME, whereClause, whereArgs); db.close(); return rows; &#125; public Cursor query() &#123; SQLiteDatabase db = getReadableDatabase(); return db.query(TABLE_NAME, null, null, null, null, null, null); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196package com.wsine.west.exp7;import android.app.AlertDialog;import android.content.DialogInterface;import android.content.Intent;import android.database.Cursor;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.AdapterView;import android.widget.Button;import android.widget.ListView;import android.widget.Toast;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.List;import java.util.Map;public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper myDatabaseHelper = new MyDatabaseHelper(MainActivity.this); private List&lt;Map&lt;String, String&gt;&gt; dataList = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MySimpleAdapter mySimpleAdapter=updateListView(); final ArrayList&lt;Map&lt;String, String&gt;&gt; mData=mySimpleAdapter.getmData(); Button btnAdd = (Button)this.findViewById(R.id.btn_add); btnAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(MainActivity.this, DetailActivity.class); Bundle bundle = new Bundle(); int i=-1; for (Map&lt;String, String&gt; m : mData)&#123; i++; Collection&lt;String&gt; valueCollection = m.values(); final int size = valueCollection.size(); List&lt;String&gt; valueList = new ArrayList&lt;String&gt;(valueCollection); String[] valueArray = new String[size]; m.values().toArray(valueArray); bundle.putString(&quot;No&quot;+i, valueArray[3]); &#125; bundle.putBoolean(&quot;AddorNot&quot;, true); intent.putExtras(bundle); int requestCode = 1; startActivityForResult(intent, requestCode); &#125; &#125;); ListView lv = (ListView)this.findViewById(R.id.lv_contact); lv.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; ListView listView = (ListView) parent; HashMap&lt;String, String&gt; map = (HashMap&lt;String, String&gt;)listView.getItemAtPosition(position); Intent intent = new Intent(MainActivity.this, DetailActivity.class); Bundle bundle = new Bundle(); bundle.putBoolean(&quot;AddorNot&quot;, false); int i=-1; for (Map&lt;String, String&gt; m : mData)&#123; i++; Collection&lt;String&gt; valueCollection = m.values(); final int size = valueCollection.size(); List&lt;String&gt; valueList = new ArrayList&lt;String&gt;(valueCollection); String[] valueArray = new String[size]; m.values().toArray(valueArray); bundle.putString(&quot;No&quot;+i, valueArray[3]); &#125; bundle.putString(&quot;oldNo&quot;, map.get(&quot;no&quot;)); bundle.putString(&quot;oldName&quot;, map.get(&quot;name&quot;)); bundle.putString(&quot;oldSex&quot;, map.get(&quot;sex&quot;)); bundle.putString(&quot;oldPNumber&quot;, map.get(&quot;pnumber&quot;)); intent.putExtras(bundle); int requestCode = 2; startActivityForResult(intent, requestCode); &#125; &#125;); lv.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() &#123; @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; ListView listView = (ListView) parent; final HashMap&lt;String, String&gt; map = (HashMap&lt;String, String&gt;)listView.getItemAtPosition(position); AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setMessage(&quot;确认删除吗？&quot;); builder.setTitle(&quot;提示&quot;); builder.setPositiveButton(&quot;确认&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; try &#123; myDatabaseHelper.delete(new Contact(map.get(&quot;no&quot;), map.get(&quot;name&quot;), map.get(&quot;sex&quot;),map.get(&quot;pnumber&quot;))); updateListView(); &#125; catch (Exception e) &#123; Log.d(&quot;Hint&quot;, &quot;Remove failed!&quot;); &#125; &#125; &#125;); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; // nothing to do &#125; &#125;); builder.show(); return true; &#125; &#125;); &#125; private void setData(List&lt;Map&lt;String, String&gt;&gt; mDataList) &#123; Map&lt;String, String&gt; mData; Cursor c = myDatabaseHelper.query(); while (c.moveToNext()) &#123; mData = new HashMap&lt;String, String&gt;(); mData.put(&quot;no&quot;, c.getString(c.getColumnIndex(&quot;_no&quot;))); mData.put(&quot;name&quot;, c.getString(c.getColumnIndex(&quot;_name&quot;))); mData.put(&quot;sex&quot;, c.getString(c.getColumnIndex(&quot;_sex&quot;))); mData.put(&quot;pnumber&quot;, c.getString(c.getColumnIndex(&quot;_pnumber&quot;))); mDataList.add(mData); &#125; &#125; private MySimpleAdapter updateListView() &#123; dataList.clear(); setData(dataList); MySimpleAdapter mySimpleAdapter = new MySimpleAdapter(this, dataList, R.layout.contact_item, new String[] &#123; &quot;no&quot;, &quot;name&quot;,&quot;sex&quot;, &quot;pnumber&quot; &#125;, new int[] &#123; R.id.contact_no, R.id.contact_name,R.id.contact_sex, R.id.contact_phonenumber &#125;); ListView lv = (ListView)this.findViewById(R.id.lv_contact); lv.setAdapter(mySimpleAdapter); return mySimpleAdapter; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; Log.d(&quot;Hint&quot;, &quot;requestCode = &quot; + requestCode); Log.d(&quot;Hint&quot;, &quot;resultCode = &quot; + resultCode); if (resultCode == 0) return; String oldNo= data.getStringExtra(&quot;_oldNo&quot;); String newNo = data.getStringExtra(&quot;_newNo&quot;); String newName = data.getStringExtra(&quot;_newName&quot;); String newSex = data.getStringExtra(&quot;_newSex&quot;); String newPNumber = data.getStringExtra(&quot;_newPNumber&quot;); switch (requestCode) &#123; case 1: myDatabaseHelper.insert(new Contact(newNo, newName,newSex, newPNumber)); break; case 2: int i=myDatabaseHelper.update(new Contact(newNo, newName,newSex, newPNumber),oldNo); Toast.makeText(this,&quot;&quot;+i+&quot;个修改成功&quot;, Toast.LENGTH_SHORT).show(); break; default: break; &#125; updateListView(); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.wsine.west.exp7;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.KeyEvent;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;public class DetailActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.stu_info); TextView tvTitle = (TextView)this.findViewById(R.id.detail_title); final EditText edtNo = (EditText)this.findViewById(R.id.Et_no); final EditText edtName = (EditText)this.findViewById(R.id.Et_name); final EditText edtSex = (EditText)this.findViewById(R.id.Et_sex); final EditText edtPNumber = (EditText)this.findViewById(R.id.Et_phone); final Bundle bundle = getIntent().getExtras(); final boolean addOrNot = bundle.getBoolean(&quot;AddorNot&quot;); final int[] data=bundle.getIntArray(&quot;data&quot;); if (addOrNot) &#123; tvTitle.setText(getResources().getString(R.string.titleAdd)); edtNo.setText(&quot;&quot;); edtName.setText(&quot;&quot;); edtSex.setText(&quot;&quot;); edtPNumber.setText(&quot;&quot;); &#125; else &#123; tvTitle.setText(getResources().getString(R.string.titleModify)); edtNo.setText(bundle.getString(&quot;oldNo&quot;)); edtName.setText(bundle.getString(&quot;oldName&quot;)); edtSex.setText(bundle.getString(&quot;oldSex&quot;)); edtPNumber.setText(bundle.getString(&quot;oldPNumber&quot;)); &#125; Button btnConfirm = (Button)this.findViewById(R.id.btn_confirm); btnConfirm.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String newNo = edtNo.getText().toString(); String newName = edtName.getText().toString(); String newSex = edtSex.getText().toString(); String newPNumber = edtPNumber.getText().toString(); Intent intent = new Intent(); intent.putExtra(&quot;_oldNo&quot;,bundle.getString(&quot;oldNo&quot;)); intent.putExtra(&quot;_newNo&quot;, newNo); intent.putExtra(&quot;_newName&quot;, newName); intent.putExtra(&quot;_newSex&quot;, newSex); intent.putExtra(&quot;_newPNumber&quot;, newPNumber); for(int i=0;bundle.getString(&quot;No&quot;+i)!=null;i++) &#123; System.out.println(&quot;第&quot;+i+&quot;行&quot;); System.out.println(bundle.getString(&quot;No&quot;+i)); System.out.println(newNo); if (newNo.isEmpty() || newPNumber.isEmpty() || newName.isEmpty()) &#123; Toast.makeText(getApplicationContext(), getResources().getString(R.string.msgWarning),Toast.LENGTH_SHORT).show(); return; &#125; else if(newNo.equals(bundle.getString(&quot;No&quot;+i))&amp;&amp;!newNo.equals(bundle.getString(&quot;oldNo&quot;))) &#123; Toast.makeText(getApplicationContext(), getResources().getString(R.string.msgWarning2),Toast.LENGTH_SHORT).show(); return; &#125; &#125; int resultCode = 0; if (addOrNot) resultCode = 1; else resultCode = 2; DetailActivity.this.setResult(resultCode, intent); DetailActivity.this.finish(); &#125; &#125;); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if(keyCode == KeyEvent.KEYCODE_BACK) &#123; int resultCode = 0; DetailActivity.this.setResult(resultCode); DetailActivity.this.finish(); &#125; return true; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_detail, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 123456789101112131415161718192021&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Exp7&lt;/string&gt; &lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt; &lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt; &lt;string name=&quot;title_activity_detail&quot;&gt;DetailActivity&lt;/string&gt; &lt;string name=&quot;add&quot;&gt;Add&lt;/string&gt; &lt;string name=&quot;no&quot;&gt;学号:&lt;/string&gt; &lt;string name=&quot;name&quot;&gt;姓名:&lt;/string&gt; &lt;string name=&quot;phone&quot;&gt;手机:&lt;/string&gt; &lt;string name=&quot;confirm&quot;&gt;确定&lt;/string&gt; &lt;string name=&quot;titleAdd&quot;&gt;添加联系人&lt;/string&gt; &lt;string name=&quot;titleModify&quot;&gt;修改联系人&lt;/string&gt; &lt;string name=&quot;msgWarning&quot;&gt;您输入的内容为空&lt;/string&gt; &lt;string name=&quot;msgWarning2&quot;&gt;你输入的学号重复&lt;/string&gt;&lt;/resources&gt; 源码下载：https://download.csdn.net/download/qq_45808700&#x2F;19525532","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:19:11.860Z","path":"wiki/软件项目/Android项目/Android多线程与异步操作实现图片自动轮播/","text":"一、实验内容1.利用Thread和Handler实现异步操作；2.利用AsyncTast实现异步操作； 1. 利用Thread和Handler实现异步操作（1）新建一个安卓工程，在默认的layout主界面中添加一个按钮(Button)，一个图片显示控件（ImageView）。（2）将实验四资源中的所有图片导入到工程的drawable目录下。（3）参考下面的代码构建图片资源列表和计数器变量。（4）为按钮添加点击事件，当点击按钮时，启动一个新线程(传入一个handler)，并每隔100毫秒发送一条空信息，信息的what标识为0x123。（5）定义一个handler用于接受线程的信息，并在handleMessage方法中处理信息，参考下列代码循环更新ImageView中的内容，实现动画效果。（6）测试上述功能。 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginTop=&quot;200dp&quot; android:text=&quot;Button&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;300px&quot; android:layout_height=&quot;300px&quot; android:scaleType=&quot;fitXY&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789package com.example.myapplication8;public class images &#123; public final static int imgids[]=new int[]&#123;//图片资源列表 R.drawable.p1,R.drawable.p2,R.drawable.p3,R.drawable.p4, R.drawable.p5,R.drawable.p6,R.drawable.p7 &#125;;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.example.myapplication8;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import androidx.annotation.NonNull;import androidx.viewpager.widget.PagerAdapter;public class ViewPagerAdapter extends PagerAdapter &#123; private Context context; private LayoutInflater layoutInflater; private int[] datas; public ViewPagerAdapter(Context context,int[] datas) &#123; this.context=context; this.datas=datas; layoutInflater=LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return datas.length; &#125; @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) &#123; return view==object; &#125; @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) &#123; container.removeView((View) object); &#125; @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) &#123; View layout=layoutInflater.inflate(R.layout.viewpager_item,null); ImageView iv= layout.findViewById(R.id.imageView); iv.setImageResource(datas[position]); container.addView(layout); return layout; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.example.myapplication8;import androidx.annotation.NonNull;import androidx.appcompat.app.AppCompatActivity;import androidx.viewpager.widget.ViewPager;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.ImageView;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class MainActivity extends AppCompatActivity &#123; private int[] imgids= com.example.myapplication8.images.imgids; private ImageView imageView; public Button btn; int imgstart=0; private ScheduledExecutorService scheduledExecutorService; private Handler handler =new Handler() &#123; @Override public void handleMessage(@NonNull Message msg) &#123; switch (msg.what) &#123; case 0x123: imageView.setImageResource(imgids[imgstart++%7]); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView=findViewById(R.id.imageView1); &#125; @Override protected void onStart() &#123; super.onStart(); btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; handler.sendEmptyMessage(0x123); &#125; &#125;, 0, 100, TimeUnit.MILLISECONDS); &#125; &#125;); &#125; @Override protected void onStop() &#123; super.onStop(); if (scheduledExecutorService != null) &#123; scheduledExecutorService.shutdown(); &#125; &#125;&#125; 实现过程即通过 scheduledExecutorService的scheduleAtFixedRate（）来利用hander的sendEmptyMessage（）方法传递what标识符，然后在handleMessage（）中switch判断标识符，并修改imageView的图片。 2. 利用AsyncTast实现异步操作（1）新建另一个安卓工程，在默认的layout主界面中添加一个按钮(Button)，一个图片显示控件（ImageView）。（2）参考课堂教授的方法，使用AsyncTast实现类似的动画效果。（3）测试上述功能，比较两种方法在代码构造上的优劣。 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginTop=&quot;200dp&quot; android:text=&quot;Button&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:scaleType=&quot;fitXY&quot; tools:ignore=&quot;MissingConstraints&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.os.AsyncTask;import android.os.Bundle;import android.text.PrecomputedText;import android.view.View;import android.widget.Button;import android.widget.ImageView;public class MainActivity extends AppCompatActivity &#123; private int[] imgids= &#123;//图片资源列表 R.drawable.p1,R.drawable.p2,R.drawable.p3,R.drawable.p4, R.drawable.p5,R.drawable.p6,R.drawable.p7 &#125;;; private ImageView imageView; public Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView=findViewById(R.id.imageView1); btn=findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Task task=new Task(); task.execute(); &#125; &#125;); &#125; class Task extends AsyncTask&lt;Void,Integer,Boolean&gt; &#123; int imgstart; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Boolean doInBackground(Void... params)&#123; try &#123; while(true) &#123; Thread.sleep(100); imgstart++; imgstart=imgstart%7; publishProgress(imgstart); if(imgstart==8) &#123; break; &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return true; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); imageView.setImageResource(imgids[values[0]]); &#125; @Override protected void onPostExecute(Boolean bollean) &#123; super.onPostExecute(bollean); &#125; &#125;&#125; 四： 实验总结：在本实验中，我对多线程与异步操作的实现有了基本了解，并知道了2种线程的实现方法，即利用handle与 scheduledExecutorService和继承AsyncTask的方法，我认为这两种方法都比较好用，但AsyncTask虽然结构比较清晰，但要注意参数配置，还必须在onProgressUpdate（）中才能对Android的UI进行更新，容易出错，而handle利用时虽然代码比较复杂，但实验实现时不易出错。","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:19:05.364Z","path":"wiki/软件项目/Android项目/Android使用Service组件实现简单的音乐播放器/","text":"一、实验内容 构建应用界面布局（1）新建一个安卓工程，在默认的layout界面中添加一个按钮(button)，如下图所示：2）构建相应的java代码，添加按钮的响应事件，跳转至另一个界面musicplayer.xml，对应的activity名称为musicPlayer.java，在其界面中添加三个imagebutton，分别对应播放器的播放、退出（后台播放）、退出（停止播放）操作，如下图所示： 构建Service组件（1）新建一个MusicService类继承Service，通过重写onStartCommand()、onDestroy()方法实现对MediaPlayer播放器的控制。 实现简单的音乐播放器（1）完善musicPlayer.java中的代码，通过startService方法启动MusicService。并实现各个按钮的功能。其中：播放按钮：点击按钮开始播放音乐（播放固定音乐文件for-love.mp3，请事先将文件导入到项目的asset或者raw目录内），再次点击按钮暂停播放。退出（后台播放）：点击按钮退出musicplayer界面（回到初始界面），但此时后台仍在播放音乐。退出（停止播放）：点击按钮退出musicplayer界面（回到初始界面），同时停止播放音乐。 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/start&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;19dp&quot; android:layout_marginLeft=&quot;19dp&quot; android:layout_marginTop=&quot;23dp&quot; android:text=&quot;打开播放器&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.musicplayer&quot;&gt; &lt;ImageButton android:id=&quot;@+id/btn_play&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;4dp&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;16dp&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:srcCompat=&quot;@android:drawable/ic_media_play&quot; /&gt; &lt;ImageButton android:id=&quot;@+id/btn_return&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintStart_toEndOf=&quot;@+id/btn_play&quot; app:layout_constraintTop_toTopOf=&quot;@+id/btn_play&quot; app:srcCompat=&quot;@android:drawable/ic_menu_revert&quot; /&gt; &lt;ImageButton android:id=&quot;@+id/btn_stop&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;10dp&quot; android:layout_marginLeft=&quot;10dp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/btn_return&quot; app:layout_constraintStart_toEndOf=&quot;@+id/btn_return&quot; app:srcCompat=&quot;@android:drawable/ic_lock_power_off&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425package com.example.myapplication7;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button bt = findViewById(R.id.start); bt.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent =new Intent(MainActivity.this,musicplayer.class); startActivity(intent); &#125; &#125;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.example.myapplication7;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.ImageButton;import android.widget.Toast;public class musicplayer extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.musicplayer); final Intent intent =new Intent(musicplayer.this,MusicService.class); ImageButton btn_play=(ImageButton) findViewById(R.id.btn_play); btn_play.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if( MusicService.isplay==false) &#123;startService(intent); Toast.makeText(getApplicationContext(), &quot;正在播放&quot;, Toast.LENGTH_LONG).show(); &#125; else &#123;stopService(intent); Toast.makeText(getApplicationContext(), &quot;暂停播放&quot;, Toast.LENGTH_LONG).show();&#125; &#125;&#125;); ImageButton btn_return=(ImageButton) findViewById(R.id.btn_return); btn_return.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if( MusicService.isplay==true) &#123; Intent intent2 = new Intent( musicplayer.this,MainActivity.class); startActivity(intent2); Toast.makeText(getApplicationContext(), &quot;正在播放&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;&#125;); ImageButton btn_stop=(ImageButton) findViewById(R.id.btn_stop); btn_stop.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if( MusicService.isplay==true) &#123;stopService(intent); Intent intent1 = new Intent( musicplayer.this,MainActivity.class); startActivity(intent1); Toast.makeText(getApplicationContext(), &quot;停止播放&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;&#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.myapplication7;import android.app.Service;import android.content.Intent;import android.media.MediaPlayer;import android.os.IBinder;public class MusicService extends Service &#123; static boolean isplay; MediaPlayer player; public MusicService() &#123; &#125; @Override public void onCreate() &#123; player = MediaPlayer.create(this,R.raw.for_love); super.onCreate(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if(!player.isPlaying()) &#123;player.start(); isplay=player.isPlaying(); &#125; return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; player.stop(); isplay=player.isPlaying(); player.release(); super.onDestroy(); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); &#125;&#125; MusicService：通过重写OnCreate（），onDestroy(),onStartCommand()实现后台service的music播放 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.myapplication7&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.MyApplication7&quot;&gt; &lt;service android:name=&quot;.MusicService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/service&gt; &lt;activity android:name=&quot;.musicplayer&quot; /&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:18:58.555Z","path":"wiki/软件项目/Android项目/Android UI控件的使用/","text":"Android UI控件的使用一、实验目的1.掌握Android基本布局的使用方法；2.掌握常用Android UI控件的使用方法；3.创建相应的Android应用程序实现各类控件的功能； 二、实验要求1.掌握线性布局(Linearlayout)和相对布局(Relativelayout)的使用方法；2.掌握文本框（TextView）、按钮（Button）、EditText（可编辑文本）和CheckBox（复选框）控件的使用方法；3.掌握下拉列表（Spinner）控件的使用方法；4.掌握列表（ListView）控件的使用方法；5.掌握进度条（ProgressBar）控件的使用方法；6.掌握缩放按钮（ZoomButton&amp;ZoomControl）控件的使用方法；7.独立完成实验内容，完成实验报告。 三、实验内容1. 掌握线性布局(linearlayout)和相对布局(relativelayout)的使用方法（1）新建一个安卓工程，在默认的layout界面中设置布局为线性布局水平，在布局中添加5个按钮控件和一个线性布局垂直控件，其布局如下图所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:showDividers=&quot;middle&quot; android:dividerPadding=&quot;10dp&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;2&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;2&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;2&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;Button android:layout_width=&quot;0dp&quot; android:layout_height=&quot;fill_parent&quot; android:layout_weight=&quot;3&quot; android:text=&quot;Button&quot; app:backgroundTint=&quot;#757171&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; （2）其中水平线性布局中的两个按钮和垂直线性布局的高度比例为：1:1:2，垂直线性布局内三个按钮的宽度比例为：2:2:3。（3）新建一个相对布局界面，在其中添加5个ImageView控件，使用相对布局属性使其形成如下图所示的梅花型图案（其中中间控件位于界面居中位置），各个控件所使用的图片资源见实验资源文件，需要先导入到工程项目的drawable中再使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity2&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_marginEnd=&quot;56dp&quot; android:layout_marginRight=&quot;56dp&quot; android:layout_marginBottom=&quot;100dp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toEndOf=&quot;@+id/imageView7&quot; app:layout_constraintTop_toTopOf=&quot;@+id/imageView2&quot; app:srcCompat=&quot;@drawable/child&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginTop=&quot;187dp&quot; android:layout_marginEnd=&quot;100dp&quot; android:layout_marginRight=&quot;100dp&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/imageView7&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/imageView&quot; app:layout_constraintStart_toStartOf=&quot;@+id/imageView4&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:srcCompat=&quot;@drawable/arancia_fruit&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView3&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;0dp&quot; android:layout_marginStart=&quot;100dp&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_marginEnd=&quot;100dp&quot; android:layout_marginRight=&quot;100dp&quot; android:layout_marginBottom=&quot;244dp&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/imageView&quot; app:layout_constraintStart_toStartOf=&quot;@+id/imageView4&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView7&quot; app:srcCompat=&quot;@drawable/dress2&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView4&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;100dp&quot; android:layout_marginStart=&quot;55dp&quot; android:layout_marginLeft=&quot;55dp&quot; android:layout_marginTop=&quot;100dp&quot; android:layout_marginBottom=&quot;100dp&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/imageView3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/imageView7&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;@+id/imageView2&quot; app:srcCompat=&quot;@drawable/fitness_ball&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView7&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_centerInParent=&quot;true&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/imageView3&quot; app:layout_constraintEnd_toStartOf=&quot;@+id/imageView&quot; app:layout_constraintStart_toEndOf=&quot;@+id/imageView4&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/imageView2&quot; app:srcCompat=&quot;@android:mipmap/sym_def_app_icon&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 2. 掌握文本框（TextView）、按钮（Button）、EditText（可编辑文本）和CheckBox（复选框）控件的使用方法（1）新建一个安卓工程，在默认的layout界面中分别添加一个文本框（TextView）、按钮（Button）和EditText（可编辑文本）控件。（2）TextView包含了一段提示文字，作为另一个控件的搭配说明，Button则是相应点击事件，可以将Button理解为可以点击的TextView，而EditText则用于接受用户的输入。（3）程序初始化时给TextView设置默认值，在按钮被点击后会出现的响应，使得文本框内容发生改变（改变后的内容将包含在EditText中输入的信息）。（4）请编写代码实现：点击提交按钮后，打开一个新的界面，并在其中显示输入的信息。（5）在新的界面中再添加一个CheckBox（复选框）控件（复选框应有3个以上可选择项，内容不限）和一个Button（按钮）控件。请编写代码实现：当点击按钮时，关闭当前界面并将复选框选择的内容信息返回至第一个界面并显示。 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;16dp&quot; android:layout_marginLeft=&quot;16dp&quot; android:layout_marginBottom=&quot;18dp&quot; android:text=&quot;选择内容&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/button&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;4dp&quot; android:layout_marginLeft=&quot;4dp&quot; android:layout_marginTop=&quot;93dp&quot; android:text=&quot;复选框页面&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity2&quot;&gt; &lt;Button android:id=&quot;@+id/but&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;57dp&quot; android:layout_marginLeft=&quot;57dp&quot; android:layout_marginTop=&quot;42dp&quot; android:text=&quot;返回&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/checkBox3&quot; /&gt; &lt;CheckBox android:id=&quot;@+id/checkBox1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;2dp&quot; android:layout_marginLeft=&quot;2dp&quot; android:text=&quot;高兴&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/checkBox2&quot; app:layout_constraintStart_toStartOf=&quot;@+id/checkBox2&quot; /&gt; &lt;CheckBox android:id=&quot;@+id/checkBox2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;68dp&quot; android:layout_marginLeft=&quot;68dp&quot; android:layout_marginTop=&quot;205dp&quot; android:text=&quot;伤心&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;CheckBox android:id=&quot;@+id/checkBox3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;46dp&quot; android:text=&quot;平静&quot; app:layout_constraintStart_toStartOf=&quot;@+id/checkBox2&quot; app:layout_constraintTop_toTopOf=&quot;@+id/checkBox2&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.myapplication;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this,MainActivity2.class); startActivityForResult(intent,0x11); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); TextView textView=(TextView) findViewById(R.id.textView2); if (requestCode==0x11 &amp;&amp; resultCode==0x11)&#123; Bundle bundle =data.getExtras(); String string= bundle.getString(&quot;check&quot;); textView.setText(string); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.myapplication;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.List;public class MainActivity2 extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Button button = (Button) findViewById(R.id.but); // 初始化控件 CheckBox checkBox1, checkBox2, checkBox3; List&lt;CheckBox&gt; checkBoxList = new ArrayList&lt;CheckBox&gt;(); checkBox1 = (CheckBox) findViewById(R.id.checkBox1); checkBox2 = (CheckBox) findViewById(R.id.checkBox2); checkBox3 = (CheckBox) findViewById(R.id.checkBox3); // 将所有的checkbox放到一个集合中 checkBoxList.add(checkBox1); checkBoxList.add(checkBox2); checkBoxList.add(checkBox3); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = getIntent(); Bundle bundle = new Bundle(); StringBuffer sb = new StringBuffer(); //遍历集合中的checkBox,判断是否选择，获取选中的文本 for (CheckBox checkbox : checkBoxList) &#123; if (checkbox.isChecked())&#123; sb.append(checkbox.getText().toString() + &quot; &quot;); &#125; &#125; String s = sb.toString(); if (sb!=null &amp;&amp; &quot;&quot;.equals(sb.toString()))&#123; Toast.makeText(getApplicationContext(), &quot;请至少选择一个&quot;, Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(getApplicationContext(), sb.toString(), Toast.LENGTH_SHORT).show(); &#125; bundle.putCharSequence(&quot;check&quot;,s); intent.putExtras(bundle); setResult(0x11,intent); finish(); &#125; &#125;); &#125;&#125; 3. 掌握下拉列表（Spinner）控件的使用方法（1）ArrayAdapter可称为数组适配器，是Spinner和ListView中最简单的一种适配器，它将一个数组和列表控件之间建立连接，可以将数组里定义的内容一一对应的显示在列表中。（2）新建一个安卓工程，在默认的layout界面中添加两个文本框（TextView）控件，一个用于显示提示信息“请选择：”，另一个用于显示下拉列表选择的结果信息。添加一个下拉列表（Spinner）控件。（3）在工程项目res&#x2F;values下的string.xml中添加一个stringarray,名称为citys，内容为城市列表信息，如下： （4）使用下列代码实现下拉列表功能。程序初始化时，为下拉列表定义一个适配器ArrayAdapter，为下拉列表赋值，列表选项从citys中获取。下拉列表从适配器中读取值，调用下拉列表赋值、响应函数。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;39dp&quot; android:text=&quot;TextView&quot; app:layout_constraintEnd_toEndOf=&quot;@+id/textView2&quot; app:layout_constraintStart_toStartOf=&quot;@+id/textView2&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;61dp&quot; android:layout_marginLeft=&quot;61dp&quot; android:layout_marginBottom=&quot;40dp&quot; android:text=&quot;TextView&quot; app:layout_constraintBottom_toTopOf=&quot;@+id/spinner&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt; &lt;Spinner android:id=&quot;@+id/spinner&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;168dp&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 1234567891011&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;My Application3&lt;/string&gt; &lt;string-array name=&quot;cities&quot;&gt; &lt;item&gt;--请选择--&lt;/item&gt; &lt;item&gt;北京&lt;/item&gt; &lt;item&gt;上海&lt;/item&gt; &lt;item&gt;成都&lt;/item&gt; &lt;item&gt;南京&lt;/item&gt; &lt;item&gt;香港&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.myapplication3;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Spinner;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; TextView tv1; TextView tv2; Spinner sp; View.OnClickListener ocl = null; ArrayAdapter&lt;CharSequence&gt; adapter; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; //class super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv1 = (TextView)findViewById(R.id.textView); tv2 = (TextView)findViewById(R.id.textView2); sp = (Spinner)findViewById(R.id.spinner); tv1.setText(&quot;请选择&quot;); sp.setPrompt(&quot;选择项&quot;);//为列表项设置标题 spinner_set();//调用下拉列表赋值、响应函数 &#125; private void spinner_set()&#123; //将下拉列表的值先传给适配器 adapter = ArrayAdapter.createFromResource(this, R.array.cities, android.R.layout.simple_spinner_item); //适配器获得值 adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); //下拉列表从适配器中读取值 sp.setAdapter(adapter); //下拉列表选定值后响应 sp.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; // TODO Auto-generated method stub if(arg2 != 0)&#123; tv2.setText(&quot;您选择的是：&quot; + adapter.getItem(arg2)); &#125; else&#123; tv2.setText(&quot;您还没有选择!&quot;); &#125; &#125; public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; // TODO Auto-generated method stub tv2.setText(&quot;您还没有选择!&quot;); &#125; &#125;); &#125; &#125; 4.掌握列表（ListView）控件的使用方法（1）ListView控件也通过ArrayAdapter建立与数据的连接，可以将数组里定义的内容一一对应的显示在ListView中，每一项一般只有一个TextView，即一行只能显示一个数组Item调用toString()方法生成的一行字符串。（2）新建一个安卓工程项目，实现列表控件的基本功能：（3）删除lv.setOnItemClickListener相关语句内容，再次运行程序，观察其效果有何变化。思考OnItemSelectedListener和OnItemClickListener的区别。 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.myapplication4;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ListView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView lv = new ListView(this); lv.setAdapter(new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1,getData())); setContentView(lv); lv.setOnItemClickListener(new AdapterView.OnItemClickListener()&#123; public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; setTitle(&quot;您点击的是：&quot; + arg0.getItemAtPosition(arg2).toString()); &#125; &#125;); lv.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener()&#123; public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; setTitle(&quot;您选择的是：&quot; + arg0.getItemAtPosition(arg2).toString()); &#125; public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; &#125; &#125;); &#125; List&lt;String&gt; getData()&#123; List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(&quot;北京&quot;); l.add(&quot;上海&quot;); l.add(&quot;成都&quot;); l.add(&quot;香港&quot;); l.add(&quot;南京&quot;); return l; &#125; &#125; 5.掌握进度条（ProgressBar）控件的使用方法（1）进度条可以为用户呈现操作的进度。一般进度条的长度用来显示进度信息，工作完成量的百分比，同时还可以加入次要进度条显示次要进度信息，比如用主要进度条显示流媒体的播放进度，用次要进度条显示缓冲进度。一个进度条也可不确定其进度。在不确定模式下，进度条显示循环动画。这种模式常用于应用程序使用任务的长度是未知的。（2）进度条相关的重要方法包括：getMax()：返回这个进度条的范围的上限getProgress()：返回进度getSecondaryProgress()：返回次要进度incrementProgressBy(int diff)：指定增加的进度isIndeterminate()：指示进度条是否在不确定模式下setIndeterminate(boolean indeterminate)：设置不确定模式下setVisibility(int v)：设置该进度条是否可视（3）新建一个安卓项目工程，将初始界面的布局改为线性布局（水平），添加五个进度条，其中前三个分别为圆形进度条（小、中、大），第四个为静止条形进度条（进度为50%），第五个为动态条形进度条（初始进度为50%，次要进度为80%），并可通过两个按钮对第五个进度条的进度进行增加和减少操作。相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:layout_editor_absoluteX=&quot;192dp&quot; tools:layout_editor_absoluteY=&quot;308dp&quot;&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar1&quot; style=&quot;?android:attr/progressBarStyleSmallTitle&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar3&quot; style=&quot;?android:attr/progressBarStyleLarge&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar4&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;250dip&quot; android:layout_height=&quot;wrap_content&quot; android:max=&quot;100&quot; android:progress=&quot;50&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progressBar5&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:layout_width=&quot;250dip&quot; android:layout_height=&quot;wrap_content&quot; android:max=&quot;100&quot; android:progress=&quot;50&quot; android:secondaryProgress=&quot;80&quot; android:layout_marginTop=&quot;20dp&quot; /&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;增加&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;减少&quot; /&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.myapplication5;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.Window;import android.widget.Button;import android.widget.ProgressBar;public class MainActivity extends AppCompatActivity &#123; ProgressBar pb1,pb2,pb3,pb4,pb5; View.OnClickListener ocl1 = null; View.OnClickListener ocl2 = null; Button bt1; Button bt2; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);//设置应用程序窗体显示状态 setContentView(R.layout.activity_main); setProgressBarIndeterminateVisibility(true);//设置窗体显示状态为真，表示一个程序正在运行 pb5 = (ProgressBar)findViewById(R.id.progressBar5); bt1 = (Button)findViewById(R.id.button); bt2 = (Button)findViewById(R.id.button2); ocl1 = new View.OnClickListener()&#123; public void onClick(View v)&#123; pb5.setProgress((int)(pb5.getProgress()*1.2)); //进度条显示为当前长度的1.2倍 &#125; &#125;; ocl2 = new View.OnClickListener()&#123; public void onClick(View v)&#123; pb5.setProgress((int)(pb5.getProgress()*0.8)); //进度条显示为当前长度的0.8倍 &#125; &#125;; bt1.setOnClickListener(ocl1);//按钮绑定响应操作 bt2.setOnClickListener(ocl2); &#125; &#125; 6.掌握缩放按钮（ZoomButton&amp;ZoomControl）控件的使用方法（1）ZoomControls是一个包含放大、缩小按钮的控件。而ZoomButton是您自己定义的缩放按钮，它允许你定义多个这样的按钮，它显示的只能是图片，没有Text属性。（2）新建一个安卓工程项目，添加一个TextView控件用来显示要进行缩放的文本，添加一个ZoomControls控件用来完成缩放。相关代码如下： 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:layout_editor_absoluteX=&quot;163dp&quot; tools:layout_editor_absoluteY=&quot;306dp&quot;&gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;979dp&quot; android:layout_height=&quot;207dp&quot; android:text=&quot;我是放大了还是缩小了&quot; /&gt; &lt;ZoomControls android:id=&quot;@+id/myZoomController&quot; android:layout_width=&quot;211dp&quot; android:layout_height=&quot;99dp&quot; android:gravity=&quot;center_horizontal&quot; /&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 123456789101112131415161718192021222324252627282930313233343536package com.example.myapplication6;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.TextView;import android.widget.ZoomControls;public class MainActivity extends AppCompatActivity &#123; TextView tv1; static float size1 = 20; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv1 = (TextView)findViewById(R.id.textView);//定义一个图片视图对象 ZoomControls zc = (ZoomControls)findViewById(R.id.myZoomController); zc.setOnZoomInClickListener(new View.OnClickListener()&#123;//设置ZoomControls的放大监听器 public void onClick(View v) &#123; size1 += 10; tv1.setText(&quot;ZoomControlsLarger&quot;); tv1.setTextSize(size1); &#125; &#125;); zc.setOnZoomOutClickListener(new View.OnClickListener()&#123;//设置ZoomControls的缩小监听器 public void onClick(View v) &#123; size1 -= 10; tv1.setText(&quot;ZoomControlsSmaller&quot;); tv1.setTextSize(size1); &#125; &#125;); &#125; &#125;","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:18:41.668Z","path":"wiki/计算机基础知识/编程语言/Java/MyBatis Plus学习笔记/","text":"MyBatis Plus国产的开源框架，基于 MyBatis在Mybatis-Plus中，内置了代码生成器，我们可以通过该工具，生成我们需要的代码，例如：entity层，controller层，mapper层，service层。如此一来，我么就可以节省编码的时间，优化开发。 MyBatis Plus 快速上手Spring Boot(2.3.0) + MyBatis Plus（国产的开源框架，并没有接入到 Spring 官方孵化器中） 1、创建 Maven 工程 2、pom.xml 引入 MyBatis Plus 的依赖mybatis-plus-boot-starter 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt;&lt;/dependency&gt; 3、创建实体类 12345678910package com.mybatisplus.entity;import lombok.Data;@Datapublic class User &#123; private Integer id; private String name; private Integer age;&#125; 4、创建 Mapper 接口，继承 BaseMapper，不用自己写代码 12345678package com.mybatisplus.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.mybatisplus.entity.User;public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; 5、application.yml 123456789spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: rootmybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 6、启动类main需要添加 @MapperScan(扫描”mapper所在的包”)，否则无法加载 Mppaer bean。 123456789101112131415package com.southwind.mybatisplus;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.southwind.mybatisplus.mapper&quot;)public class MybatisplusApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MybatisplusApplication.class, args); &#125;&#125; 7、测试 123456789101112131415161718package com.southwind.mybatisplus.mapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass UserMapperTest &#123; @Autowired private UserMapper mapper; @Test void test()&#123; mapper.selectList(null).forEach(System.out::println); &#125;&#125; 常用注解 @TableName映射数据库的表名 123456789101112package com.southwind.mybatisplus.entity;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;@Data@TableName(value = &quot;user&quot;)public class Account &#123; private Integer id; private String name; private Integer age;&#125; @TableId设置主键映射，value 映射主键字段名 type 设置主键的生成策略，如雪花算法或自增等 1234567891011121314AUTO(0),NONE(1),INPUT(2),ASSIGN_ID(3),ASSIGN_UUID(4),/** @deprecated */@DeprecatedID_WORKER(3),/** @deprecated */@DeprecatedID_WORKER_STR(3),/** @deprecated */@DeprecatedUUID(4); 值 描述 AUTO 数据库自增 NONE MP set 主键，雪花算法实现 INPUT 开发者手动赋值 ASSIGN_ID MP 分配 ID，Long、Integer、String ASSIGN_UUID 分配 UUID，Strinig INPUT 如果开发者没有手动赋值，则数据库通过自增的方式给主键赋值，如果开发者手动赋值，则存入该值。 AUTO 默认就是数据库自增，开发者无需赋值。 ASSIGN_ID MP 自动赋值，雪花算法。 ASSIGN_UUID 主键的数据类型必须是 String，自动生成 UUID 进行赋值 @TableField映射非主键字段，value 映射字段名 exist 表示是否为数据库字段 false，如果实体类中的成员变量在数据库中没有对应的字段，则可以使用 exist，VO、DTO select 表示是否查询该字段 fill 表示是否自动填充，将对象存入数据库的时候，由 MyBatis Plus 自动给某些字段赋值，create_time、update_time 1、给表添加 create_time、update_time 字段 2、实体类中添加成员变量 12345678910111213141516171819202122232425package com.southwind.mybatisplus.entity;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;import java.util.Date;@Data@TableName(value = &quot;user&quot;)public class User &#123; @TableId private String id; @TableField(value = &quot;name&quot;,select = false) private String title; private Integer age; @TableField(exist = false) private String gender;//在数据库中没有该字段 @TableField(fill = FieldFill.INSERT) private Date createTime;//自动导入创建时间 @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime;//自动导入更新时间&#125; 3、创建自动填充处理器，需要实现MetaObjectHandler ，然后重写insertFill()与updateFill()。 123456789101112131415161718192021package com.southwind.mybatisplus.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;createTime&quot;,new Date(),metaObject); this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject); &#125;&#125; @Version标记乐观锁 乐观锁：十分乐观，它总是认为不会出现问题，无论干什么都不去上锁！ 如果出现了问题，再去上锁。通过 version 字段来保证数据的安全性，当修改数据的时候，会以 version 作为条件，当条件成立的时候才会修改成功。 乐观锁实现机制：取出记录时，获取当前 version更新时，带上这个 version执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion如果 version 不对，就更新失败 1、数据库表添加 version 字段，默认值为 1 2、实体类添加 version 成员变量，并且添加 @Version 123@Versionprivate int version; 3、注册乐观锁配置类optimisticLockerInterceptor 123456789101112131415package com.southwind.mybatisplus.config;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MyBatisPlusConfig &#123; @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor()&#123; return new OptimisticLockerInterceptor(); &#125; &#125; 多线程测试乐观锁 1234567891011121314151617181920@Test void testOptimisticLocker2()&#123; //多线程操作乐观锁 //线程1操作，此时 version = 1 User user = userMapper.selectById(4L); user.setName(&quot;66666&quot;); user.setAge(100); //线程2抢占执行 User user2 = userMapper.selectById(4L); user2.setName(&quot;88888&quot;); user2.setAge(200); int i2 = userMapper.updateById(user2); //执行完成后 version 变为 2 System.out.println(i2); //线程1 继续执行，但是此时发现version = 2，无法满足 version = 1 的要求，无法进行覆盖 //如果没有乐观锁,线程 1 会进行覆盖线程 2 的修改 int i = userMapper.updateById(user); System.out.println(i); &#125; @EnumValue实现枚举 方法1、通用枚举类注解@EnumValue，将数据库字段映射成实体类的枚举类型成员变量 123456789101112131415package com.southwind.mybatisplus.enums;import com.baomidou.mybatisplus.annotation.EnumValue;public enum StatusEnum &#123; WORK(1,&quot;上班&quot;), REST(0,&quot;休息&quot;); StatusEnum(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125; @EnumValue private Integer code; private String msg;&#125; 1private StatusEnum status; application.yml 12type-enums-package: com.southwind.mybatisplus.enums @TableLogic映射逻辑删除 1、数据表添加 deleted 字段 2、实体类添加注解与对应字段 12@TableLogicprivate Integer deleted; 3、application.yml 添加配置 1234global-config: db-config: logic-not-delete-value: 0 logic-delete-value: 1 4.配置类 12345678@Configurationpublic class MybatisPlusConfig &#123; // 逻辑删除注入 3.0.5 @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125;&#125; MyBatis-Plus查询12345678910111213141516171819202122232425 mapper.selectList(null);//全部查询 QueryWrapper wrapper = new QueryWrapper(); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;,&quot;小红&quot;); map.put(&quot;age&quot;,3); wrapper.allEq(map);//等于 wrapper.gt(&quot;age&quot;,2);//大于 wrapper.ne(&quot;name&quot;,&quot;小红&quot;);//不等于 wrapper.ge(&quot;age&quot;,2);//大于等于//like &#x27;%小&#x27; wrapper.likeLeft(&quot;name&quot;,&quot;小&quot;);//like &#x27;小%&#x27; wrapper.likeRight(&quot;name&quot;,&quot;小&quot;);//inSQL wrapper.inSql(&quot;id&quot;,&quot;select id from user where id &lt; 10&quot;); wrapper.inSql(&quot;age&quot;,&quot;select age from user where age &gt; 3&quot;); wrapper.orderByDesc(&quot;age&quot;);//排序 wrapper.orderByAsc(&quot;age&quot;); wrapper.having(&quot;id &gt; 8&quot;);mapper.selectList(wrapper).forEach(System.out::println); 1234567891011121314151617 System.out.println(mapper.selectById(7)); mapper.selectBatchIds(Arrays.asList(7,8,9)).forEach(System.out::println); //Map 只能做等值判断，逻辑判断需要使用 Wrapper 来处理 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;id&quot;,7); mapper.selectByMap(map).forEach(System.out::println);QueryWrapper wrapper = new QueryWrapper();wrapper.eq(&quot;id&quot;,7); System.out.println(mapper.selectCount(wrapper)); //将查询的结果集封装到Map中 mapper.selectMaps(wrapper).forEach(System.out::println); System.out.println(&quot;-------------------&quot;); mapper.selectList(wrapper).forEach(System.out::println); 分页查询Page1.配置分页插件 12345@Beanpublic PaginationInterceptor mypaginationInterceptor() &#123; return new PaginationInterceptor();&#125; 2.直接使用page对象进行查询 1234567891011 //参数一 ： 当前页 //参数二 ： 页面大小 Page&lt;User&gt; page = new Page&lt;&gt;(2,2); Page&lt;User&gt; result = mapper.selectPage(page,null); System.out.println(result.getSize()); System.out.println(result.getTotal()); result.getRecords().forEach(System.out::println); Page&lt;Map&lt;String,Object&gt;&gt; page = new Page&lt;&gt;(1,2); mapper.selectMapsPage(page,null).getRecords().forEach(System.out::println); mapper.selectObjs(null).forEach(System.out::println);System.out.println(mapper.selectOne(wrapper)); 自定义 SQL（多表关联查询）123456789101112package com.southwind.mybatisplus.entity;import lombok.Data;@Datapublic class ProductVO &#123; private Integer category; private Integer count; private String description; private Integer userId; private String userName;&#125; 12345678910111213package com.southwind.mybatisplus.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.southwind.mybatisplus.entity.ProductVO;import com.southwind.mybatisplus.entity.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserMapper extends BaseMapper&lt;User&gt; &#123; @Select(&quot;select p.*,u.name userName from product p,user u where p.user_id = u.id and u.id = #&#123;id&#125;&quot;) List&lt;ProductVO&gt; productList(Integer id);&#125; 添加12345User user = new User();user.setTitle(&quot;小明&quot;);user.setAge(22);mapper.insert(user);System.out.println(user); 删除12345678mapper.deleteById(1); mapper.deleteBatchIds(Arrays.asList(7,8)); QueryWrapper wrapper = new QueryWrapper(); wrapper.eq(&quot;age&quot;,14); mapper.delete(wrapper);Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;id&quot;,10);mapper.deleteByMap(map); 修改12345User user = mapper.selectById(1);user.setTitle(&quot;小红&quot;);QueryWrapper wrapper = new QueryWrapper();wrapper.eq(&quot;age&quot;,22);mapper.update(user,wrapper); MyBatisPlus 自动生成根据数据表自动生成实体类、Mapper、Service、ServiceImpl、Controller 1、pom.xml 导入 MyBatis Plus Generator 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt; 模板引擎依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beet 2、代码生成程序（注意：一定不能导错包，要用mybatis-plus中的包） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.janson.generate;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.po.TableFill;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import java.util.ArrayList;import java.util.List;/** * @Author Janson * @Date 2022/3/15 8:33 * @Version 1.0 */public class CodeGenerate &#123; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath + &quot;/src/main/java&quot;); gc.setAuthor(&quot;Pistachiout&quot;); gc.setOpen(false); gc.setFileOverride(false); //是否覆盖 gc.setSwagger2(true); //实体属性 Swagger2 注解 mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/mybatisplus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;); // dsc.setSchemaName(&quot;public&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;11111&quot;); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;generate&quot;); pc.setParent(&quot;com&quot;); pc.setEntity(&quot;entity&quot;); pc.setMapper(&quot;mapper&quot;); pc.setController(&quot;controller&quot;); pc.setService(&quot;service&quot;); mpg.setPackageInfo(pc);/**/ // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); //strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;); strategy.setEntityLombokModel(true); //自动加上lombok strategy.setRestControllerStyle(true); // 公共父类 //strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;); // 写于父类中的公共字段 strategy.setSuperEntityColumns(&quot;id&quot;); //strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;)); strategy.setInclude(&quot;user&quot;); //设置映射表名 strategy.setLogicDeleteFieldName(&quot;deleted&quot;); // 逻辑删除 //自动填充 TableFill createTime = new TableFill(&quot;create_time&quot;, FieldFill.INSERT); TableFill updateTime = new TableFill(&quot;update_time&quot;, FieldFill.UPDATE); List&lt;TableFill&gt; fillList = new ArrayList(); fillList.add(createTime); fillList.add(updateTime); strategy.setTableFillList(fillList); //乐观锁 strategy.setVersionFieldName(&quot;version&quot;); //restful风格 strategy.setRestControllerStyle(true); //localhost:8080/hello_id_1 或者2 strategy.setControllerMappingHyphenStyle(true); //strategy.setTablePrefix(pc.getModuleName() + &quot;_&quot;); mpg.setStrategy(strategy); //mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); &#125;&#125; Spring Boot + MyBatis Plus 打包应用，直接发布 阿里云 上云","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T02:18:33.852Z","path":"wiki/计算机基础知识/编程语言/Java/IDEA常用快捷键总结/","text":"1. 根据psvm或者main快速生成主函数我们可以在类中输入psvm 或者main 然后IDEA会自动提示main(),敲击回车即可自动生成~ 2. 根据sout快速生成打印语句我们可以在方法中输入sout 然后IDEA会自动提示打印语句,敲击回车即可自动生成~ 3. 查找的快捷键按Ctrl + F表示在当前页面中查找 4. 万能键Alt+EnterAlt+Enter是一个特别常用且好用的“万能键” 比如我们可以在类中导入需要导的包 再比如我们可以在类中快速生成方法的返回值类型与变量名 如果代码中需要处理异常，我们还可以快速选择是抛出还是捕获 5. for循环的快捷键itar : 生成普通的for循环 iter : 生成高效for循环 itco : 生成遍历集合的for循环 6. Ctrl+N 搜索类这个快捷键一般用来搜索源码 7. Ctrl+Shift+N 强力搜索我们一般用这个快捷键查找自己所需的资源 8. Ctrl+H 查看类的继承关系注意：查看的时候需要先选中自己想看的类名哦 9. Alt+7 快速查看类的结构信息 10. Ctrl+R 文本替换 我们可以使用这个快捷键逐个&#x2F;全部替换文本 11.下面是总结的一些其他的快捷键Ctrl系列Ctrl + Y 删除光标所在行的所有内容，Ctrl+X也可以 Ctrl + D 快速向下复制当前行的内容Ctrl + W 递进式选中代码可以先选中光标所在的一部分代码，连续按这个快捷键会在原来的基础上继续扩展被选中的内容Ctrl + E 显示最近打开的文件记录列表Ctrl + G 在当前文件跳转到指定位置处Ctrl + Q 光标所在的变量 &#x2F; 类名 &#x2F; 方法名等上面（也可以在提示补充的时候按），显示文档内容Ctrl + U 前往当前光标所在的方法的父类的方法 &#x2F; 接口定义Ctrl + B 进入光标所在的方法&#x2F;变量的接口或是定义处，等效于 Ctrl + 左键单击（必备）Ctrl + O 选择可重写的方法Ctrl + I 选择可继承的方法Ctrl + &#x2F; 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）Ctrl + F1 在光标所在的错误代码处显示错误信息Ctrl + F3 调转到所选中的词的下一个引用位置Ctrl + F4 关闭当前编辑文件Ctrl + ­- 折叠代码Ctrl + + 展开代码Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + Enter 智能分隔行 Ctrl + Delete 删除光标后面的单词或是中文句Ctrl + BackSpace 删除光标前面的单词或是中文句 Ctrl + End 跳到文件尾Ctrl + Home 跳到文件头 Ctrl + [ 移动光标到当前所在代码的花括号开始位置Ctrl + ] 移动光标到当前所在代码的花括号结束位置Ctrl + 左方向键 光标跳转到当前单词 &#x2F; 中文句的左侧开头位置Ctrl + 右方向键 光标跳转到当前单词 &#x2F; 中文句的右侧开头位置Ctrl + 前方向键 等效于鼠标滚轮向前效果Ctrl + 后方向键 等效于鼠标滚轮向后效果 Alt系列Alt+Shift+向上 向上移动选中的代码 Alt + Insert 代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等 Alt + 左方向键 按左方向切换当前已打开的文件视图Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Shift系列Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留Shift + F6 对文件 &#x2F; 文件夹 重命名 Ctrl+Shift系列Ctrl + Shift + Alt + V 无格式黏贴Ctrl + Shift + Alt + N 前往指定的变量 &#x2F; 方法Ctrl + Shift + Alt + S 打开当前项目设置 Ctrl + Shift + ­ - 折叠所有代码Ctrl + Shift + ­ + 展开所有代码 Ctrl + Shift + F12 编辑器最大化 Ctrl+Alt系列Ctrl + Alt + S 打开设置Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化————————————————版权声明：本文为CSDN博主「程序媛 泡泡」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43884234/article/details/119991925","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T02:18:25.339Z","path":"wiki/计算机基础知识/编程语言/Java/IDEA web项目本地热部署/","text":"本地热部署是能够在项目运行中感知到特定文件代码的修改而使项目不重新启动就能生效。 使用热部署后：run 模式运行：当修改 jsp 文件时不需要重启 tomcatdebug 模式运行：修改类不需要重启服务器，重新编译之后直接刷新页面就会更新 1、SSM热部署，修改 Tomcat 配置设置File -&gt; Settings -&gt; Build,Execution,Deployment -&gt; Compiler -&gt; Build project automatically 2.Springboot热部署pom.xml引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 然后按crtl+F9 热部署Crtl+F9重新编译（页面修改及后台代码修改都可以）","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T02:18:18.163Z","path":"wiki/计算机基础知识/编程语言/Java/SSM项目上传云服务器/","text":"1.购买服务器阿里云新人免费领取网站腾讯云新人免费领取网站领取后在控制台进行操作，可以发现公网ip地址与重置密码，之后记住修改服务器安全组规则，打开8080端口 2.连接服务器开始菜单输入mstsc打开远程桌面连接输入ip地址，用户名Administrator与密码连接。 3.配置相应环境环境全套配置资源 首先一定要配置好jdk，Tomcat，MySQL，可以自己去官网下载，全部安装后点开控制面板，在系统高级设置中配置环境变量 变量名 变量值 JAVA_HOME jdk安装的路径 CLASSPATH Path %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin CATALINA_BASE tomcat的安装路径 CATALINA_HOME tomcat的安装路径 TOMCAT_HOME tomcat的安装路径 mysql数据库首先记得利用Navicat创建好 4.打开Tomcat打开cmd命令行窗口，cd进入Tomcat安装路径&#x2F;bin，运行startup.bat。在网页输入ip:8080检测 5.上传SSM项目从idea中利用Maven进行packge打包，打包后的war包先更改为ROOT名称，这样服务器首页就是该项目。","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T02:18:08.580Z","path":"wiki/计算机基础知识/编程语言/Java/Thymeleaf快速入门/","text":"1.什么是ThymeleafThymeleaf是一个XML&#x2F;XHTML&#x2F;HTML5模板引擎，可用于Web与非Web环境中的应用开发，它是一个开源的Java库。Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板，它的特点便是：开箱即用。 2.Springboot整合thymeleaf实现的步骤为： 创建一个sprinboot项目 添加thymeleaf的起步依赖 添加spring web的起步依赖 编写html 使用thymleaf的语法获取变量对应后台传递的值 编写controller 设置变量的值到model中 pom.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;​ &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springboot-thymeleaf&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;​ &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;/parent&gt;​ &lt;dependencies&gt; &lt;!--web起步依赖 Tomcat Springmvc 引赖Jar包 一个中心 三大组件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;​ &lt;!--thymeleaf配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建application.yml,并设置thymeleaf的缓存设置，设置为false。123spring: thymeleaf: cache: false 在resources中创建templates目录，在templates目录创建index.html,代码如下：123456789&lt;!doctype html&gt;&lt;html lang=&quot;ch&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title th:text=&quot;|lookroot-$&#123;title&#125;|&quot;&gt;默认的标题&lt;/title&gt; &lt;meta name=&quot;description&quot; th:content=&quot;$&#123;description&#125;&quot;&gt; &lt;meta name=&quot;keywords&quot; th:content=&quot;$&#123;keywords&#125;&quot;&gt;&lt;/head&gt;&lt;/html&gt; &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;这句声明使用thymeleaf标签&lt;title th:text=&quot;$&#123;title&#125;&quot;&gt;默认的标题&lt;/title&gt;这句使用 th:text&#x3D;”${变量名}” 表示 使用thymeleaf获取文本数据，类似于EL表达式。 &lt;title th:text=&quot;|lookroot-$&#123;title&#125;|&quot;&gt;默认的标题&lt;/title&gt;假如我们的 th:text 标签里面需要拼接字符串${title}可以使用||来包裹 创建controller用于测试后台 设置数据到model中。12345678910@Controllerpublic class IndexController &#123; @GetMapping(&quot;/index&quot;)public String index(Model model) &#123; model.addAttribute(&quot;title&quot;, &quot;传递的标题&quot;); model.addAttribute(&quot;description&quot;, &quot;传递的描述&quot;); model.addAttribute(&quot;keywords&quot;, &quot;传递的关键字&quot;); return &quot;index&quot;;&#125;&#125; Thymeleaf常用语法 渲染对象创建一个基本对象UserVO 123456789@Datapublic class UserVO &#123; private String username; private Integer age; private Integer sex; private Boolean isVip; private Date createTime; private List&lt;String&gt; tags;&#125; 新建一个方法basic，将user对象传输到页面中 1234567891011@GetMapping(&quot;/basicTrain&quot;)public String basic(Model model) &#123; UserVO userVO = new UserVO(); userVO.setAge(21); userVO.setSex(1); userVO.setCreateTime(new Date()); userVO.setTags(Arrays.asList(&quot;Java&quot;, &quot;PHP&quot;, &quot;Node&quot;)); userVO.setUsername(&quot;lookroot&quot;); model.addAttribute(&quot;user&quot;, userVO); return &quot;basic&quot;;&#125; 新建basic.html，此时如果我们想渲染User这个对象的信息我们可以这样 1234&lt;div&gt; &lt;h2 th:text=&quot;$&#123;user.getUsername()&#125;&quot;&gt;&lt;/h2&gt; &lt;p th:text=&quot;$&#123;user.getAge()&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt; 也可以将User定义为临时变量，接着使用*{xxx}就能取到值了 1234&lt;div th:object=&quot;$&#123;user&#125;&quot;&gt; &lt;h2 th:text=&quot;*&#123;username&#125;&quot;&gt;&lt;/h2&gt; &lt;p th:text=&quot;*&#123;age&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt; 还可以不使用get的方式，直接使用属性名 1&lt;h2 th:text=&quot;$&#123;user.username&#125;&quot; &gt;&lt;/h2&gt; th:if使用th:if通过布尔值决定这个元素是否渲染 1&lt;p th:if=&quot;$&#123;user.isVip&#125;&quot;&gt;会员&lt;/p&gt; th:each使用th:each可以迭代循环出数据，前面我们User对象里面的tags是一个数组，我们来渲染一下 1234&lt;ul&gt; &lt;li th:each=&quot;tag:$&#123;user.getTags()&#125;&quot; th:text=&quot;$&#123;tag&#125;&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 状态变量在th:each属性中定义，并且包含以下数据： 当前的迭代索引，从0开始。这是index属性。. 从1开始的当前迭代索引。这是count属性。 迭代变量中元素的总数。这是size财产。每次迭代的iter变量。这是current财产。当前迭代是偶数还是奇数。这些是even&#x2F;odd布尔属性。当前迭代是否是第一个。这是first布尔属性。当前迭代是否为最后一次。这是last布尔属性 th:switch使用th:switch选择语句 12345&lt;div th:switch=&quot;$&#123;user.getSex()&#125;&quot;&gt; &lt;p th:case=&quot;&#x27;1&#x27;&quot;&gt;男&lt;/p&gt; &lt;p th:case=&quot;&#x27;2&#x27;&quot;&gt;女&lt;/p&gt; &lt;p th:case=&quot;*&quot;&gt;默认&lt;/p&gt;&lt;/div&gt; url如果在springboot中需要引入static目录下的静态资源可以使用@{xxx}的方式 1&lt;link th:href=&quot;@&#123;/app.css&#125;&quot; rel=&quot;stylesheet&quot;&gt; JavaScript动态渲染1234&lt;script th:inline=&quot;javascript&quot;&gt; const user = /*[[$&#123;user&#125;]]*/ &#123;&#125;; console.log(user);&lt;/script&gt; 同理css也是可以的 12345&lt;style th:inline=&quot;css&quot;&gt; .main\\ elems &#123; text-align: /*[[$&#123;align&#125;]]*/ left; &#125;&lt;/style&gt; Thymeleaf碎片（组件）th:fragment新建一个component.html,一个文件里面可以写多个碎片，使用th:fragment来定义 1234567&lt;footer th:fragment=&quot;com1&quot;&gt; this is com1&lt;/footer&gt;&lt;footer id=&quot;com2&quot;&gt; this is com2&lt;/footer&gt; 使用碎片主要有两种方式replace和insert,在index.html中编写 1234&lt;!--replace--&gt;&lt;div th:replace=&quot;~&#123;component::com1&#125;&quot;&gt;&lt;/div&gt;&lt;!--insert--&gt;&lt;div th:insert=&quot;~&#123;component::com1&#125;&quot;&gt;&lt;/div&gt; 这两种方式的区别就是，replace会将新标签完全替换原本的标签，也就是说原本写th:replace属性的标签就不会渲染出来，insert是往这个地方插入标签 直接通过选择器使用对于碎片，甚至可以不定义，我们再次添加一个 碎片 123&lt;footer id=&quot;com2&quot;&gt; this is com2&lt;/footer&gt; 然后使用它 1&lt;div th:insert=&quot;~&#123;component::#com2&#125;&quot;&gt;&lt;/div&gt; 注释类型在碎片里面，我们是可以使用控制传递的数据的，比如上面的User对象，但是开发工具在component.html页面中可能不能识别到User对象，我们可以打一个注释 12&lt;!--/*@thymesVar id=&quot;user&quot; type=&quot;cn.lookroot.loop.thymeleafdemo.vo.UserVO&quot;*/--&gt;&lt;div th:text=&quot;$&#123;user.getUsername()&#125;&quot;&gt;&lt;/div&gt; 组件传递参数组件也是可以传递数据的 123&lt;div th:fragment=&quot;com3(message)&quot;&gt; &lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt; 使用的时候 1&lt;div th:insert=&quot;~&#123;component::com3(&#x27;传递数据&#x27;)&#125;&quot;&gt;&lt;/div&gt; 局部替换组件我们使用一个组件的时候，想要局部替换掉这个组件里面的部分内容该怎么做呢？通过传递参数的方式传递一个组件过来，并把这个组件替换原本的一部分 123&lt;div th:fragment=&quot;com4(message)&quot;&gt; &lt;p th:replace=&quot;$&#123;message&#125;&quot;&gt;原本的message&lt;/p&gt;&lt;/div&gt; 使用的时候 123&lt;div th:insert=&quot;~&#123;component::com4(~&#123;::#message&#125;)&#125;&quot;&gt; &lt;p id=&quot;message&quot;&gt;替换的message&lt;/p&gt;&lt;/div&gt; 基本对象ctx：上下文对象1234$&#123;#ctx.request&#125;$&#123;#ctx.response&#125;$&#123;#ctx.session&#125;$&#123;#ctx.servletContext&#125; 请求&#x2F;会话属性123$&#123;session.xxx&#125; $&#123;application.xxx&#125; $&#123;#request.getAttribute(&#x27;xxx&#x27;)&#125; 工具类在thymeleaf里面是可以直接使用一些Java的函数的，并且你可以通过传递参数的方式把一些自己写的方法传递给页面，在里面调用也是可以的 #dates#calendars#strings#numbers#objects#bools#arrays#lists#sets#maps#aggregates 以日期格式化来举例 12&lt;!--日期格式化--&gt;&lt;p th:text=&quot;$&#123;#dates.format(user.createTime,&#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;&gt;&lt;/p&gt;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T02:18:00.904Z","path":"wiki/计算机基础知识/编程语言/Java/Shiro快速入门/","text":"1.ShiroShiro 是一款主流的 Java 安全框架，它不依赖任何容器，可以独立运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证（身份认证也就是登录）、授权、会话管理、加密等操作,用来解决安全管理的系统化框架。 2.Shiro 核心组件权限安全管理 在一个系统中是必不可少的部分，也是决定系统安全质量的关键所在，一个系统的强大全靠权限安全模块支撑。说起权限，之不难想到 RBAC（Role-Based Access Control，基于角色的访问控制） 这个权限模型，权限就是功能的意思，而 RBAC 简单的说就是由 用户、角色、权限 组成的，一个用户可以拥有若干角色，每一个角色也可以拥有若干权限，给用户赋予角色，给角色赋予权限。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。 1、UsernamePasswordToken，Shiro 用来封装用户登录信息，使用用户的登录信息来创建令牌 Token。 2、SecurityManager，Shiro 的核心部分，负责安全认证和授权。 3、Subject，Shiro 的一个抽象概念，包含了用户信息。 4、Realm，开发者自定义的模块，根据项目的需求，验证和授权的逻辑全部写在 Realm 中。 5、AuthenticationInfo，用户的角色信息集合，认证时使用。 6、AuthorzationInfo，角色的权限信息集合，授权时使用。 7、DefaultWebSecurityManager，安全管理器，开发者自定义的 Realm 需要注入到 DefaultWebSecurityManager 进行管理才能生效。 8、ShiroFilterFactoryBean，过滤器工厂，Shiro 的基本运行机制是开发者定制规则，Shiro 去执行，具体的执行操作就是由 ShiroFilterFactoryBean 创建的一个个 Filter 对象来完成。 3.Spring Boot 整合 Shiro编写认证和授权规则： 认证过滤器 anon：无需认证。 authc：必须认证。 authcBasic：需要通过 HTTPBasic 认证。 user：不一定通过认证，只要曾经被 Shiro 记录即可，比如：记住我。 授权过滤器 perms：必须拥有某个权限才能访问。 role：必须拥有某个角色才能访问。 port：请求的端口必须是指定值才可以。 rest：请求必须基于 RESTful，POST、PUT、GET、DELETE。 ssl：必须是安全的 URL 请求，协议 HTTPS。 创建 3 个页面，main.html、manage.html、administrator.html，访问权限如下： 1、必须登录才能访问 main.html 2、当前用户必须拥有 manage 授权才能访问 manage.html 3、当前用户必须拥有 administrator 角色才能访问 administrator.html 1、创建 Spring Boot 应用，集成 Shiro 及相关组件，pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、自定义 Shiro 过滤器 123456789101112131415161718192021222324252627282930313233343536373839public class AccoutRealm extends AuthorizingRealm &#123; @Autowired private AccountService accountService; /** * 授权 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; //获取当前登录的用户信息 Subject subject = SecurityUtils.getSubject(); Account account = (Account) subject.getPrincipal(); //设置角色 Set&lt;String&gt; roles = new HashSet&lt;&gt;(); roles.add(account.getRole()); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roles); //设置权限 info.addStringPermission(account.getPerms()); return info; &#125; /** * 认证 * @param authenticationToken * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; Account account = accountService.findByUsername(token.getUsername()); if(account != null)&#123; return new SimpleAuthenticationInfo(account,account.getPassword(),getName()); &#125; return null; &#125;&#125; 3、配置类 123456789101112131415161718192021222324252627282930313233343536@Configurationpublic class ShiroConfig &#123; @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(securityManager); //权限设置 Map&lt;String,String&gt; map = new Hashtable&lt;&gt;(); map.put(&quot;/main&quot;,&quot;authc&quot;); map.put(&quot;/manage&quot;,&quot;perms[manage]&quot;); map.put(&quot;/administrator&quot;,&quot;roles[administrator]&quot;); factoryBean.setFilterChainDefinitionMap(map); //设置登录页面 factoryBean.setLoginUrl(&quot;/login&quot;); //设置未授权页面 factoryBean.setUnauthorizedUrl(&quot;/unauth&quot;); return factoryBean; &#125; @Bean public DefaultWebSecurityManager securityManager(@Qualifier(&quot;accoutRealm&quot;) AccoutRealm accoutRealm)&#123; DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(accoutRealm); return manager; &#125; @Bean public AccoutRealm accoutRealm()&#123; return new AccoutRealm(); &#125; @Bean public ShiroDialect shiroDialect()&#123; return new ShiroDialect(); &#125;&#125; 4.Shiro 整合 Thymeleaf1、pom.xml 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 2、配置类添加 ShiroDialect 1234@Beanpublic ShiroDialect shiroDialect()&#123; return new ShiroDialect();&#125; 3、index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot; xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;#&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;index&lt;/h1&gt; &lt;div th:if=&quot;$&#123;session.account != null&#125;&quot;&gt; &lt;span th:text=&quot;$&#123;session.account.username&#125;+&#x27;欢迎回来！&#x27;&quot;&gt;&lt;/span&gt;&lt;a href=&quot;/logout&quot;&gt;退出&lt;/a&gt; &lt;/div&gt; &lt;a href=&quot;/main&quot;&gt;main&lt;/a&gt; &lt;br/&gt; &lt;div shiro:hasPermission=&quot;manage&quot;&gt; &lt;a href=&quot;manage&quot;&gt;manage&lt;/a&gt; &lt;br/&gt; &lt;/div&gt; &lt;div shiro:hasRole=&quot;administrator&quot;&gt; &lt;a href=&quot;/administrator&quot;&gt;administrator&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;=&quot;/main&quot;&gt;main&lt;/a&gt; &lt;br/&gt; &lt;div shiro:hasPermission=&quot;manage&quot;&gt; &lt;a href=&quot;manage&quot;&gt;manage&lt;/a&gt; &lt;br/&gt; &lt;/div&gt; &lt;div shiro:hasRole=&quot;administrator&quot;&gt; &lt;a href=&quot;/administrator&quot;&gt;administrator&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T02:17:45.428Z","path":"wiki/软件项目/JavaWeb项目/基于SSM框架的网上购物送货系统/","text":"基于SSM框架的网上购物送货系统系统开发平台：Tomcat8.0 + JDK1.8 + Windows10 开发语言：JavaEE JAR包管理：Maven3.6.1 前端：jQuery html5&#x2F;css3 后台 核心架构：SpringBoot Web框架：SpringMVC 持久层框架：Mybatis 模板引擎：Thymeleaf 数据库：Mysql 1.系统参与角色：管理者、购物者、送货员。 管理者：负责管理商品，提供商品信息，处理订单事务，系统的日常维护，控制超市状态。 购物者：在线注册账户，更新个人信息，管理账户，搜索浏览商品，管理购物车，支付订单，申请退款，留言以及售后评价。 送货员：注册成为送货员，更新个人信息，查看订单信息。 2.系统应用场景 活动泳道图之管理者在现实应用中，管理员可以通过管理员界面进行登录，然后管理商品，账号等信息。也可以设置超市公告，查看销售情况和订单信息等2.活动泳道图之购物者在现实应用中，购物者可以通过顾客界面进行登录，然后查看商品并对其进行各项操作，包括加入购物车和购买支付等，也可以管理自身信息，留言3.活动泳道图之送货员在现实应用中，送货员可以通过送货员界面进行登录，然后管理自身信息，也可以查看订单信息并操作 3.1需求模型1.购物者业务流程图2.管理员业务流程图3.送货员业务流程图4.订单管理业务流程图 3.2功能模型 3.3用例模型 4.系统截图用户页面 送货员页面 管理员页面 5.难点实现2.支付宝支付实现! 2.服务器的搭建服务器搭建教程：https://blog.csdn.net/qq_35206244&#x2F;article&#x2F;details&#x2F;83184173https://blog.csdn.net/Aidiying/article/details/84442638为了实现用户的远程操作，我们把项目部署到了云服务器上，云服务器可以节省经济成本，又节约了大量时间。我们项目用的是腾讯云服务器。 3.销量图表为了方便管理员进货，我们利用图表来帮助管理员了解商城销售商品的数量以及占比，利用ECharts来将后台的销量数据可视化，以便于直观显示销量占比 4.订单号设置随机数保证一定的并发性在购物时，会根据购物时间来生成订单号，为了避免多人同时购买商品时订单号重复使系统出现问题，我们利用ordernum++来生成不重复的订单号，保证一定程度的并发性。 5.定时调用轮转实现图片轮换 6.按序排列 6.源码地址：https://github.com/1105358600/MailSystem","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:17:34.404Z","path":"wiki/软件项目/JavaWeb项目/基于ssm的在线提问、回答系统/","text":"名称：在线提问、回答系统功能要求： 非登陆用户可以看其他人的问答，按最后一个回答时间的倒序排列 登陆用户可以发布、终结自己的问题。 对于未终结的问题，登陆用户可以发布、修改、删除自己的回答。 不分板块。 普通人可申请注册，管理员同意后算作注册成功；管理员可将现有用户拉黑，管理员不能删除用户。 被拉黑用户的问题、回答对其他人不可见。 管理员可以屏蔽掉某个问题或者回答，也可取消屏蔽。 被屏蔽的问题或回答对其他人不可见；提问人或回答人自己可见。 被屏蔽的问题或者回答，提问人或回答人不能改、删。 用例图：OOA类图： 源代码：https://github.com/1105358600/Qusetion_Answer","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:16:35.197Z","path":"wiki/软件项目/Linux项目/Ubuntu编制模拟一个简单的进程管理子系统，由进程建立模块、进程撤消模块、进程控制表组成，并包括进程切换和调度模块/","text":"一、进程管理子系统在Ubuntu下编制一个程序，模拟实现一个简单的进程管理子系统，它由进程建立模块、进程撤消模块、进程控制表组成，并包括进程切换和调度模块。 【设计要求1】该子系统接收新进程建立请求的方式是循环显示“请输入新命令行”，然后根据用户键入内容启动相应进程，其后不等待子进程结束，马上显示下一个“请输入新命令行”如此循环往复。当建立进程时，相应读写进程控制表，然后借助底层环境OS中象fork和exec这样的函数将新进程投入运行（这与底层环境的实际OS不同，实际OS将新进程投入运行时要布置现场，最后时程序技术器寄存器）。进程撤消时，利用底层OS的wait( )从子进程回到本子系统，相应修改PCB。比较该子系统与实际系统中的相应功能的异同与差距，尤其在现场保存与恢复方面的比较。 【设计要求2】在上题的基础上，进一步模拟实现进程切换。希望能实现时间片满或接到sleep调用（或信号时）进行进程切换（选择其一即可）。若要实现时间片，假设时间片为1秒钟，设定底层环境OS每个1秒向该系统发一个信号，本子系统将本子系统的进程切换和调度模块设定为该信号的处理程序。或者每当接到子进程发出的的sleep调用（或信号）时进行进程切换，这里子进程发出的sleep调用（或信号）代表实际系统中可能发生的sleep( )调用、等待某一时间发生等情况，进程调度采用简单的FIFO算法。 【设计要求3】编制一个进程调度算法模块。进程调度是处理机管理的核心内容。本设计要求用编写和调试一个简单的进程调度程序。通过设计本项目可以加深理解有关进程控制块、进程队列的概念，并体会和了解最高优先数优先的调度算法（即把处理机分配给优先数最高的进程）和先来先服务算法的具体实施办法。(1) 进程调度算法：采用最高优先数优先的调度算法（即把处理机分配给优先数最高的进程）和先来先服务算法。 (2) 每个进程有一个进程控制块（PCB）表示。进程控制块可以包含如下信息：进程名、优先数、到达时间、需要运行时间、已用CPU时间、进程状态等等。(3) 进程的优先数及需要的运行时间可以事先人为地指定（也可以由随机数产生）。进程的到达时间为进程输入的时间。进程的运行时间以时间片为单位进行计算。(4) 每个进程的状态可以是就绪W（Wait）、运行R（Run）、或完成F（Finish）三种状态之一。(5) 就绪进程获得CPU后都只能运行一个时间片。用已占用CPU时间加1来表示。如果运行一个时间片后，进程的已占用CPU时间已达到所需要的运行时间，则撤消该进程，如果运行一个时间片后进程的已占用CPU时间还未达所需要的运行时间，也就是进程还需要继续运行，此时应将进程的优先数减1（即降低一级），然后把它插入就绪队列等待CPU。(6) 每进行一次调度程序都打印一次运行进程、就绪队列、以及各个进程的PCB，以便进行检查。(7) 重复以上过程，直到所要进程都完成为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; //进程类class pcb&#123;public: //构造函数 pcb(char Name[20], int Rank, int Needtime) &#123; strcpy(name, Name); state = &quot;Wait&quot;; rank = Rank; needtime = Needtime; runtime = 0; next = NULL; &#125; char name[20]; string state; int rank; int needtime; int runtime; pcb* next;&#125;;pcb *ready = NULL, *now = NULL;//输出进程void output(pcb *point)&#123; cout &lt;&lt; &quot;.............................................................................&quot;; cout &lt;&lt; &quot;\\n 进程名称 \\t 进程状态 \\t 优先级 \\t 所需时间 \\t 已运行时间&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| &quot; &lt;&lt; point-&gt;name ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;state ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;rank ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;needtime; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;runtime &lt;&lt; endl; cout &lt;&lt; &quot;.............................................................................&quot; &lt;&lt; endl;&#125; //进程依次排序void sort(pcb *point)&#123; if (ready == NULL)//若链表为空 &#123; ready = point; &#125; else &#123; pcb *point1 = ready, *point2 = ready-&gt;next; if (point-&gt;rank &gt; point1-&gt;rank)//若为优先等级最高，放在队首 &#123; point-&gt;next = ready; ready = point; &#125; else &#123; while (point2 != NULL)//遍历链表，直到找到合适位置 &#123; if (point-&gt;rank &gt; point2-&gt;rank) &#123; point1-&gt;next = point; point-&gt;next = point2; break; &#125; point1 = point2; point2 = point2-&gt;next; &#125; if (point2 == NULL)//若为优先等级最低，放在队尾 &#123; point1-&gt;next = point; &#125; &#125; &#125;&#125; //进程结束函数，打印已完成进程，释放内存void finish(pcb *point)&#123; point-&gt;state = &quot;Finish&quot;; cout &lt;&lt; &quot;******************************** 进程&quot; &lt;&lt; point-&gt;name &lt;&lt; &quot;已经完成 ********************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n 进程名称 \\t 进程状态 \\t 优先级 \\t 所需时间 \\t 已运行时间&quot; &lt;&lt; endl; cout &lt;&lt; &quot;| &quot; &lt;&lt; point-&gt;name ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;state ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;rank ; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;needtime; cout &lt;&lt; &quot; | &quot; &lt;&lt; point-&gt;runtime &lt;&lt; endl; delete(point); point = NULL;&#125; //运行一个单位时间void running()&#123; now = ready; ready = ready-&gt;next; now-&gt;next = NULL; now-&gt;state = &quot;Run&quot;; now-&gt;rank--; now-&gt;runtime++; if (now-&gt;needtime == now-&gt;runtime) &#123; //若当前进程执行完毕 finish(now); now = NULL; &#125; else &#123; //若当前进程没有执行完毕 cout &lt;&lt; &quot;*************************** 当前正在运行的进程是 *************************** &quot; &lt;&lt; endl; output(now); &#125; //打印就绪队列 cout &lt;&lt; &quot;*************************** 当前就绪队列状态为 *************************** &quot; &lt;&lt; endl; pcb *point = ready; while (point != NULL) &#123; output(point); point = point-&gt;next; &#125; //把没执行完的进程重新放入队列 if (now != NULL) &#123; now-&gt;state = &quot;Wait&quot;; sort(now); &#125;&#125; int main()&#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int t; cout&lt;&lt;&quot;**** 输入进程数目：&quot;; cin &gt;&gt; t; cout &lt;&lt; endl; //进程信息输入 for (int i = 1; i &lt;= t; i++) &#123; pcb *temp; char name[20];int rank;int needtime; cout &lt;&lt; &quot;**** 请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个进程的信息 ****&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请输入该进程的名字：&quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;请输入该进程的优先等级:&quot;; cin &gt;&gt; rank; cout &lt;&lt; &quot;请输入该进程需要的运行时间:&quot;; cin &gt;&gt; needtime; temp = new pcb(name, rank, needtime); sort(temp); temp = NULL; cout &lt;&lt; endl; &#125; //打印执行前的就绪队列 cout &lt;&lt; &quot;*************************** 执行前就绪队列排序 *****************************&quot; &lt;&lt; endl; pcb *point = ready; while (point != NULL) &#123; output(point); point = point-&gt;next; &#125; cout &lt;&lt; &quot;*************************** 程序准备正式开始执行 *****************************&quot; &lt;&lt; endl; //程序开始执行 char ch; while (now != NULL || ready != NULL) &#123; //一次运行一个单位时间 cout &lt;&lt; &quot;\\n\\n 按任一键继续......&quot; &lt;&lt; endl; ch = getchar(); running(); cout &lt;&lt; endl; &#125; //所有进程完成 cout &lt;&lt; &quot;*************************** 所有进程均已执行完成 ***************************&quot; &lt;&lt; endl; return 0;&#125; 二、进程管理子系统截图","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Linux项目","slug":"软件项目/Linux项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Linux%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:16:23.325Z","path":"wiki/软件项目/Linux项目/UNIX简单文件系统的实现/","text":"1.1设计目的和内容要求1. 设计目的 通过具体的文件存储空间的管理、文件的物理结构、目录结构和文件操作的实现，加深对文件系统内部数据结构、功能以及实现过程的理解。 2．内容要求(1)在内存中开辟一个虚拟磁盘空间作为文件存储分区，在其上实现一个简单的基于多级目录的单用户单任务系统中的文件系统。在退出该文件系统的使用时，应将该虚拟文件系统以一个文件的方式保存到磁盘上，以便下次可以再将它恢复到内存的虚拟磁盘空间中。(2)文件存储空间的分配可采用显式链接分配或其他的办法。(3)文件目录结构采用多级目录结构。为了简单起可以通过目录项实现对文件的读和写的保护。见，可以不使用索引结点，其中的每个目录项应包含文件名、物理地址、长度等信息，还(4)要求提供以下操作命令： my_format：对文件存储器进行格式化，即按照文件系统的结构对虚拟磁盘空间进行布局，并在其上创建根目录以及用于管理文件存储空间等的数据结构。 my_mkdir：用于创建子目录。 my_rmdir：用于删除子目录。 my_ls：用于显示目录中的内容。 my_cd：用于更改当前目录。 my_create：用于创建文件。 my_open：用于打开文件。 my_close：用于关闭文件。 my_write：用于写文件。 my_read：用于读文件。 my_rm：用于删除文件。 List item my_exitsys：用于退出文件系统。 1.2 预备知识1．打开文件函数open()（1）格式：fd&#x3D;open(name, rwmode[,pmode]);（2）功能：打开一个已存在的文件。 2．关闭文件函数close()（1）格式：status&#x3D;close(fd);（2）功能：用来关闭先前open()打开的一个文件。此动作会让缓冲区内的数据写入文件中，并释放系统所提供的文件资源。 3．读文件函数read()（1）格式：n&#x3D; read( fd,buffer,size )；（2）功能：对文件的读操作。（3）输入参数说明：n是一次读操作的返回字节数； buffer：是指向读缓冲区的指针；size： 本次读文件时请求读的字节数； 4. 写文件函数write()（1）格式：n&#x3D; write( fd,buffer,size )；（2）功能：将数据写到二进制文件中。（3）输入参数说明：n是一次写操作的返回字节数； buffer：是指向写缓冲区的指针；size： 本次写文件时请求写的字节数； 5. 定位文件函数lseek()（1）格式：newpos&#x3D;lseek( fd, offset, origin )；（2）功能： 改变文件指针所处的位置。（3）输入参数说明：newpos是一个长整数返回值，若lseek调用成功则返回文件指针的新位置，若调用失败则返回-1； fd是被打开文件的描述符offset：位移量，以字节为单位；origin：初始位置，是确定文件指针偏移量的基准点，有三个常量：SEEK_CUR：读写指针当前位置；SEEK_SET：文件开头；SEEK_END：文件末尾。 1.3实例系统的设计与实现1.3.1 数据结构设计1．需要包含的头文件 （1）#include &lt;stdio.h&gt;（2）#include &lt;malloc.h&gt;（3）#include &lt;string.h&gt;（4）#include &lt;time.h&gt; 2．定义的常量（1）#define BLOCKSIZE 1024 磁盘块大小（2）#define SIZE 1024000 虚拟磁盘空间大小（3）#define END 65535 文件结束标志（4）#define FREE 0 盘块空闲标志（5）#define ROOTBLOCKNUM 2 根目录区所占盘块总数（6）#define MAXOPENFILE 10 最多同时打开文件个数 3．数据结构（1）文件控制块FCB用于记录文件的描述和控制信息，每个文件设置一个FCB，它也是文件的目录项的内容。 typedef struct FCB &#x2F;&#x2F;仿照FAT16设置的{ char filename[8]; &#x2F;&#x2F;文件名 char exname[3];&#x2F;&#x2F;文件扩展名 unsigned char attribute;&#x2F;&#x2F;文件属性字段：为简单起见，我们只为文件设置了两种属性：&#x2F;&#x2F;值为0时表示目录文件，值为1时表示数据文件 unsigned short time;&#x2F;&#x2F;文件创建时间 unsigned short data;&#x2F;&#x2F;文件创建日期 unsigned short first;&#x2F;&#x2F;文件起始盘块号 unsigned long length;&#x2F;&#x2F;文件长度（字节数） char free；&#x2F;&#x2F;表示目录项是否为空，若值为0，表示空，值为1，表示已分配}fcb; （2）文件分配表FAT 在本实例中，文件分配表有两个作用：一是记录磁盘上每个文件所占据的磁盘块的块号；二是记录磁盘上哪些块已经分配出去了，哪些块是空闲的，即起到了位示图的作用。若FAT中某个表项的值为FREE，则表示该表项所对应的磁盘块是空闲的；若某个表项的值为END，则表示所对应的磁盘块是某文件的最后一个磁盘块；若某个表项的值是其他值，则该值表示某文件的下一个磁盘块的块号。为了提高系统的可靠性，本实例中设置了两张FAT表，它们互为备份，每个FAT占据两个磁盘块。typedef struct FAT{ unsigned short id;}fat; （3）用户打开文件表USEROPEN 当打开一个文件时，必须将文件的目录项中的所有内容全部复制到内存中，同时还要记录有关文件操作的动态信息，如读写指针的值等。在本实例中实现的是一个用于单用户单任务系统的文件系统，为简单起见，我们把用户文件描述符表和内存FCB表合在一起，称为用户打开文件表，表项数目为10，即一个用户最多可同时打开10个文件。然后用一个数组来描述，则数组下标即某个打开文件的描述符。另外，我们在用户打开文件表中还设置了一个字段“char dir[80]”，用来记录每个打开文件所在的目录名，以方便用户打开不同目录下具有相同文件名的不同文件。typedef struct USEROPEN{ char filename[8]; &#x2F;&#x2F;文件名 char exname[3];&#x2F;&#x2F;文件扩展名 unsigned char attribute;&#x2F;&#x2F;文件属性：值为0时表示目录文件，值为1时表示数据文件 unsigned short time;&#x2F;&#x2F;文件创建时间 unsigned short data;&#x2F;&#x2F;文件创建日期 unsigned short first;&#x2F;&#x2F;文件起始盘块号 unsigned long length;&#x2F;&#x2F;文件长度（对数据文件是字节数，对目录文件可以是目录项个数） char free；&#x2F;&#x2F;表示目录项是否为空，若值为0，表示空，值为1，表示已分配 &#x2F;&#x2F;前面内容是文件的FCB中的内容。 &#x2F;&#x2F; 下面设置的dirno和diroff记录了相应打开文件的目录项在父目录文件中的位置，&#x2F;&#x2F;这样如果该文件的fcb被修改了，则要写回父目录文件时比较方便 int dirno; &#x2F;&#x2F;相应打开文件的目录项在父目录文件中的盘块号 int diroff；&#x2F;&#x2F; 相应打开文件的目录项在父目录文件的dirno盘块中的目录项序号 char dir[MAXOPENFILE][80]; &#x2F;&#x2F;相应打开文件所在的目录名，这样方便快速检查出&#x2F;&#x2F;指定文件是否已经打开 int count; &#x2F;&#x2F;读写指针在文件中的位置 char fcbstate; &#x2F;&#x2F;是否修改了文件的FCB的内容，如果修改了置为1，否则为0char topenfile; &#x2F;&#x2F;表示该用户打开表项是否为空，若值为0，表示为空，否则表示已&#x2F;&#x2F;被某打开文件占据}useropen; （4）引导块BLOCK0 在引导块中主要存放逻辑磁盘的相关描述信息，比如磁盘块大小、磁盘块数量、文件分配表、根目录区、数据区在磁盘上的起始位置等。如果是引导盘，还要存放操作系统的引导信息。本实例是在内存的虚拟磁盘中创建一个文件系统，因此所包含的内容比较少，只有磁盘块大小、磁盘块数量、数据区开始位置、根目录文件开始位置等。typedef struct BLOCK0 &#x2F;&#x2F;引导块内容{&#x2F;&#x2F;存储一些描述信息，如磁盘块大小、磁盘块数量、最多打开文件数等、 char information[200]; unsigned short root; &#x2F;&#x2F;根目录文件的起始盘块号 unsigned char *startblock; &#x2F;&#x2F;虚拟磁盘上数据区开始位置 }block0; 4．全局变量定义 （1）unsigned char *myvhard： 指向虚拟磁盘的起始地址（2）useropen openfilelist[MAXOPENFILE]： 用户打开文件表数组（3）useropen ptrcurdir： 指向用户打开文件表中的当前目录所在打开文件表项的位置；（4）char currentdir[80]： 记录当前目录的目录名（包括目录的路径）（5）unsigned char startp： 记录虚拟磁盘上数据区开始位置 5．虚拟磁盘空间布局 由于真正的磁盘操作需要涉及到设备的驱动程序，所以本实例是在内存中申请一块空间作为虚拟磁盘使用，我们的文件系统就建立在这个虚拟磁盘上。虚拟磁盘一共划分成1000个磁盘块，每个块1024个字节，其布局格式是模仿FAT文件系统设计的，其中引导块占一个盘块，两张FAT各占2个盘块，剩下的空间全部是数据区，在对虚拟磁盘进行格式化的时候，将把数据区第1块（即虚拟磁盘的第6块）分配给根目录文件。 当然，也可以仿照FAT16文件系统，设置根目录区，其位置紧跟第2张FAT后面，大小也是固定的，这个思路相对要简单一点，请同学们自己去实现。 1.3.2 实例主要命令及函数设计1．系统主函数main()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：void main()（4）功能：系统主函数（5）输入：无（6）输出：无（7）函数需完成的工作：① 对前面定义的全局变量进行初始化；② 调用startsys()进入文件系统；③ 列出文件系统提供的各项功能及命令调用格式；④ 显示命令行提示符，等待用户输入命令；⑤ 将用户输入的命令保存到一个buf中；⑥ 对buf中的内容进行命令解析，并调用相应的函数执行用户键入的命令；⑦ 如果命令不是“my_exitsys”，则命令执行完毕后转④。 2. 进入文件系统函数startsys()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：void startsys()（4）功能：由main()函数调用，进入并初始化我们所建立的文件系统，以供用户使用。（5）输入：无 （6）输出：无。（7）函数需完成的工作：① 申请虚拟磁盘空间；② 使用c语言的库函数fopen()打开myfsys文件：若文件存在，则转③；若文件不存在，则创建之，转⑤③ 使用c语言的库函数fread()读入myfsys文件内容到用户空间中的一个缓冲区中，并判断其开始的8个字节内容是否为“10101010”（文件系统魔数），如果是，则转④；否则转⑤；④ 将上述缓冲区中的内容复制到内存中的虚拟磁盘空间中；转⑦⑤ 在屏幕上显示“myfsys文件系统不存在，现在开始创建文件系统”信息，并调用my_format()对①中申请到的虚拟磁盘空间进行格式化操作。转⑥；⑥ 将虚拟磁盘中的内容保存到myfsys文件中；转⑦⑦ 使用c语言的库函数fclose()关闭myfsys文件；⑧ 初始化用户打开文件表，将表项0分配给根目录文件使用，并填写根目录文件的相关信息，由于根目录没有上级目录，所以表项中的dirno和diroff分别置为5（根目录所在起始块号）和0；并将ptrcurdir指针指向该用户打开文件表项。⑨ 将当前目录设置为根目录。 3．磁盘格式化函数my_format()（1）对应命令：my_format（2）命令调用格式：my_format（3）函数设计格式：void my_format()（4）功能：对虚拟磁盘进行格式化，布局虚拟磁盘，建立根目录文件（或根目录区）。（5）输入：无 （6）输出：无。（7）函数需完成的工作：① 将虚拟磁盘第一个块作为引导块，开始的8个字节是文件系统的魔数，记为“10101010”；在之后写入文件系统的描述信息，如FAT表大小及位置、根目录大小及位置、盘块大小、盘块数量、数据区开始位置等信息；② 在引导块后建立两张完全一样的FAT表，用于记录文件所占据的磁盘块及管理虚拟磁盘块的分配，每个FAT占据两个磁盘块；对于每个FAT中，前面5个块设置为已分配，后面995个块设置为空闲；③ 在第二张FAT后创建根目录文件root，将数据区的第1块（即虚拟磁盘的第6块）分配给根目录文件，在该磁盘上创建两个特殊的目录项：“.”和“..”，其内容除了文件名不同之外，其他字段完全相同。 4．更改当前目录函数my_cd()（1）对应命令：my_cd（2）命令调用格式：my_cd dirname（3）函数设计格式：void my_cd(char *dirname)（4）功能：改变当前目录到指定的名为dirname的目录。（5）输入：dirname：新的当前目录的目录名； （6）输出：无（7）函数需完成的工作：① 调用my_open()打开指定目录名的父目录文件，并调用do_read()读入该父目录文件内容到内存中；② 在父目录文件中检查新的当前目录名是否存在，如果存在则转③，否则返回，并显示出错信息；③ 调用my_close()关闭①中打开的父目录文件；④ 调用my_close()关闭原当前目录文件；⑤ 如果新的当前目录文件没有打开，则打开该目录文件；并将ptrcurdir指向该打开文件表项；⑥ 设置当前目录为该目录。 5．创建子目录函数my_mkdir()（1）对应命令：my_mkdir（2）命令调用格式：my_ mkdir dirname（3）函数设计格式：void my_mkdir(char *dirname)（4）功能：在当前目录下创建名为dirname的子目录。（5）输入：dirname：新建目录的目录名。 （6）输出：无。（7）函数需完成的工作：① 调用do_read()读入当前目录文件内容到内存，检查当前目录下新建目录文件是否重名，若重名则返回，并显示错误信息；② 为新建子目录文件分配一个空闲打开文件表项，如果没有空闲表项则返回-1，并显示错误信息；③ 检查FAT是否有空闲的盘块，如有则为新建目录文件分配一个盘块，否则释放①中分配的打开文件表项，返回，并显示错误信息；④ 在当前目录中为新建目录文件寻找一个空闲的目录项或为其追加一个新的目录项;需修改当前目录文件的长度信息，并将当前目录文件的用户打开文件表项中的fcbstate置为1；⑤ 准备好新建目录文件的FCB的内容，文件的属性为目录文件，以覆盖写方式调用do_write()将其填写到对应的空目录项中；⑥ 在新建目录文件所分配到的磁盘块中建立两个特殊的目录项“.”和“..”目录项，方法是：首先在用户空间中准备好内容，然后以截断写或者覆盖写方式调用do_write()将其写到③中分配到的磁盘块中；⑦ 返回。 6．删除子目录函数rmdir()（1）对应命令：my_ rmdir（2）命令调用格式：my_ rmdir dirname（1）函数设计格式：void my_rmdir(char *dirname)（2）功能：在当前目录下删除名为dirname的子目录。（3）输入：dirname：欲删除目录的目录名。 （4）输出：无。（5）函数需完成的工作：① 调用do_read()读入当前目录文件内容到内存，检查当前目录下欲删除目录文件是否存在，若不存在则返回，并显示错误信息；② 检查欲删除目录文件是否为空（除了“.”和“..”外没有其他子目录和文件），可根据其目录项中记录的文件长度来判断，若不为空则返回，并显示错误信息；③ 检查该目录文件是否已经打开，若已打开则调用my_close()关闭掉；④ 回收该目录文件所占据的磁盘块，修改FAT；⑤ 从当前目录文件中清空该目录文件的目录项，且free字段置为0：以覆盖写方式调用do_write()来实现；⑥ 修改当前目录文件的用户打开表项中的长度信息，并将表项中的fcbstate置为1；⑦ 返回。 7．显示目录函数my_ls()（1）对应命令：my_ls（2）命令调用格式：my_ls（3）函数设计格式：void my_ls(void)（4）功能：显示当前目录的内容（子目录和文件信息）。（5）输入：无 （6）输出：无（7）函数需完成的工作：① 调用do_read()读出当前目录文件内容到内存；② 将读出的目录文件的信息按照一定的格式显示到屏幕上；③ 返回。 8．创建文件函数my_create()（1）对应命令：my_create（2）命令调用格式：my_create filename（3）函数设计格式：int my_create (char *filename)（4）功能：创建名为filename的新文件。（5）输入：filename：新建文件的文件名，可能包含路径。 （6）输出：若创建成功，返回该文件的文件描述符（文件打开表中的数组下标）；否则返回-1。（7）函数需完成的工作：① 为新文件分配一个空闲打开文件表项，如果没有空闲表项则返回-1，并显示错误信息；② 若新文件的父目录文件还没有打开，则调用my_open()打开；若打开失败，则释放①中为新建文件分配的空闲文件打开表项，返回-1，并显示错误信息；③ 调用do_read()读出该父目录文件内容到内存，检查该目录下新文件是否重名，若重名则释放①中分配的打开文件表项，并调用my_close()关闭②中打开的目录文件；然后返回-1，并显示错误信息；④ 检查FAT是否有空闲的盘块，如有则为新文件分配一个盘块，否则释放①中分配的打开文件表项，并调用my_close()关闭②中打开的目录文件；返回-1，并显示错误信息；⑤ 在父目录中为新文件寻找一个空闲的目录项或为其追加一个新的目录项;需修改该目录文件的长度信息，并将该目录文件的用户打开文件表项中的fcbstate置为1；⑥ 准备好新文件的FCB的内容，文件的属性为数据文件，长度为0，以覆盖写方式调用do_write()将其填写到⑤中分配到的空目录项中；⑦ 为新文件填写①中分配到的空闲打开文件表项，fcbstate字段值为0，读写指针值为0；⑧ 调用my_close()关闭②中打开的父目录文件；⑨ 将新文件的打开文件表项序号作为其文件描述符返回。 9．删除文件函数my_rm()（1）对应命令：my_rm（2）命令调用格式：my_rm filename（3）函数设计格式：void my_rm(char *filename)（4）功能：删除名为filename的文件。（5）输入：filename：欲删除文件的文件名，可能还包含路径。 （6）输出：无。（7）函数需完成的工作：① 若欲删除文件的父目录文件还没有打开，则调用my_open()打开；若打开失败，则返回，并显示错误信息；② 调用do_read()读出该父目录文件内容到内存，检查该目录下欲删除文件是否存在，若不存在则返回，并显示错误信息；③ 检查该文件是否已经打开，若已打开则关闭掉；④ 回收该文件所占据的磁盘块，修改FAT；⑤ 从文件的父目录文件中清空该文件的目录项，且free字段置为0：以覆盖写方式调用do_write()来实现；；⑥ 修改该父目录文件的用户打开文件表项中的长度信息，并将该表项中的fcbstate置为1；⑦ 返回。 10．打开文件函数my_open()（1）对应命令：my_open（2）命令调用格式：my_open filename（3）函数设计格式：int my_open(char *filename)（4）功能：打开当前目录下名为filename的文件。（5）输入：filename：欲打开文件的文件名 （6）输出：若打开成功，返回该文件的描述符（在用户打开文件表中表项序号）；否则返回-1。（7）函数需完成的工作：① 检查该文件是否已经打开，若已打开则返回-1，并显示错误信息；② 调用do_read()读出父目录文件的内容到内存，检查该目录下欲打开文件是否存在，若不存在则返回-1，并显示错误信息；③ 检查用户打开文件表中是否有空表项，若有则为欲打开文件分配一个空表项，若没有则返回-1，并显示错误信息；④ 为该文件填写空白用户打开文件表表项内容，读写指针置为0；⑤ 将该文件所分配到的空白用户打开文件表表项序号（数组下标）作为文件描述符fd返回。 11．关闭文件函数my_close()（1）对应命令：my_close（2）命令调用格式：my_close fd（3）函数设计格式：void my_close(int fd)（4）功能：关闭前面由my_open()打开的文件描述符为fd的文件。（5）输入：fd：文件描述符。 （6）输出：无。（7）函数需完成的工作：① 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1；② 检查用户打开文件表表项中的fcbstate字段的值，如果为1则需要将该文件的FCB的内容保存到虚拟磁盘上该文件的目录项中，方法是：打开该文件的父目录文件，以覆盖写方式调用do_write()将欲关闭文件的FCB写入父目录文件的相应盘块中；③ 回收该文件占据的用户打开文件表表项（进行清空操作），并将topenfile字段置为0；④ 返回。 12．写文件函数my_write()（1）对应命令：my_write（2）命令调用格式：my_write fd（3）函数设计格式：int my_write(int fd)（4）功能：将用户通过键盘输入的内容写到fd所指定的文件中。磁盘文件的读写操作都必须以完整的数据块为单位进行，在写操作时，先将数据写在缓冲区中，缓冲区的大小与磁盘块的大小相同，然后再将缓冲区中的数据一次性写到磁盘块中；读出时先将一个磁盘块中的内容读到缓冲区中，然后再传送到用户区。本实例为了简便起见，没有设置缓冲区管理，只是在读写文件时由用户使用malloc()申请一块空间作为缓冲区，读写操作结束后使用free()释放掉。写操作常有三种方式：截断写、覆盖写和追加写。截断写是放弃原来文件的内容，重新写文件；覆盖写是修改文件在当前读写指针所指的位置开始的部分内容；追加写是在原文件的最后添加新的内容。在本实例中，输入写文件命令后，系统会出现提示让用户选择其中的一种写方式，并将随后键盘输入的内容按照所选的方式写到文件中，键盘输入内容通过CTR+Z键（或其他设定的键）结束。（5）输入：fd： open()函数的返回值，文件的描述符； （6）输出：实际写入的字节数。（7）函数需完成的工作：① 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1，并显示出错信息；② 提示并等待用户输入写方式：（1：截断写；2：覆盖写；3：追加写）③ 如果用户要求的写方式是截断写，则释放文件除第一块外的其他磁盘空间内容（查找并修改FAT表），将内存用户打开文件表项中文件长度修改为0，将读写指针置为0并转④；如果用户要求的写方式是追加写，则修改文件的当前读写指针位置到文件的末尾，并转④；如果写方式是覆盖写，则直接转④；④ 提示用户：整个输入内容通过CTR+Z键（或其他设定的键）结束；用户可分多次输入写入内容，每次用回车结束；⑤ 等待用户从键盘输入文件内容，并将用户的本次输入内容保存到一临时变量text[]中，要求每次输入以回车结束，全部结束用CTR+Z键（或其他设定的键）；⑥ 调用do_write()函数将通过键盘键入的内容写到文件中。⑦ 如果do_write()函数的返回值为非负值，则将实际写入字节数增加do_write()函数返回值，否则显示出错信息，并转⑨；⑧ 如果text[]中最后一个字符不是结束字符CTR+Z，则转⑦继续进行写操作；否则转⑨；⑨ 如果当前读写指针位置大于用户打开文件表项中的文件长度，则修改打开文件表项中的文件长度信息，并将fcbstate置1；⑩ 返回实际写入的字节数。 13．实际写文件函数do_write()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：int my_write(int fd，char *text，int len，char wstyle)（4）功能：被写文件函数my_write()调用，用来将键盘输入的内容写到相应的文件中去。（5）输入：fd： open()函数的返回值，文件的描述符；text：指向要写入的内容的指针；len：本次要求写入字节数 wstyle：写方式（6）输出：实际写入的字节数。（7）函数需完成的工作：① 用malloc()申请1024B的内存空间作为读写磁盘的缓冲区buf，申请失败则返回-1，并显示出错信息；② 将读写指针转化为逻辑块块号和块内偏移off，并利用打开文件表表项中的首块号及FAT表的相关内容将逻辑块块号转换成对应的磁盘块块号blkno；如果找不到对应的磁盘块，则需要检索FAT为该逻辑块分配一新的磁盘块，并将对应的磁盘块块号blkno登记到FAT中，若分配失败，则返回-1，并显示出错信息；③ 如果是覆盖写，或者如果当前读写指针所对应的块内偏移off不等于0，则将块号为blkno的虚拟磁盘块全部1024B的内容读到缓冲区buf中；否则便用ASCII码0清空buf；④ 将text中未写入的内容暂存到缓冲区buff的第off字节开始的位置，直到缓冲区满，或者接收到结束字符CTR+Z为止；将本次写入字节数记录到tmplen中；⑤ 将buf中1024B的内容写入到块号为blkno的虚拟磁盘块中；⑥将当前读写指针修改为原来的值加上tmplen；并将本次实际写入的字节数增加tmplen；⑦ 如果tmplen小于len，则转②继续写入；否则转⑧；⑧ 返回本次实际写入的字节数。 14．读文件函数my_read()（1）对应命令：my_read（2）命令调用格式：my_read fd len（3）函数设计格式：int myread (int fd, int len)（4）功能：读出指定文件中从读写指针开始的长度为len的内容到用户空间中。（5）输入：fd： open()函数的返回值，文件的描述符；len: 要从文件中读出的字节数。 （6）输出：实际读出的字节数。（7）函数需完成的工作：① 定义一个字符型数组text[len]，用来接收用户从文件中读出的文件内容；② 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1，并显示出错信息；③ 调用do_read()将指定文件中的len字节内容读出到text[]中；④ 如果do_read()的返回值为负，则显示出错信息；否则将text[]中的内容显示到屏幕上；⑤ 返回。 15．实际读文件函数do_read()（1）对应命令：无（2）命令调用格式：无（3）函数设计格式：int do_read (int fd, int len,char *text)（4）功能：被my_read()调用，读出指定文件中从读写指针开始的长度为len的内容到用户空间的text中。（5）输入：fd： open()函数的返回值，文件的描述符；len: 要求从文件中读出的字节数。 text：指向存放读出数据的用户区地址（6）输出：实际读出的字节数。（7）函数需完成的工作：① 使用malloc()申请1024B空间作为缓冲区buf，申请失败则返回-1，并显示出错信息；② 将读写指针转化为逻辑块块号及块内偏移量off，利用打开文件表表项中的首块号查找FAT表，找到该逻辑块所在的磁盘块块号；将该磁盘块块号转化为虚拟磁盘上的内存位置；③ 将该内存位置开始的1024B（一个磁盘块）内容读入buf中；④ 比较buf中从偏移量off开始的剩余字节数是否大于等于应读写的字节数len，如果是，则将从off开始的buf中的len长度的内容读入到text[]中；否则，将从off开始的buf中的剩余内容读入到text[]中；⑤ 将读写指针增加④中已读字节数，将应读写的字节数len减去④中已读字节数，若len大于0，则转②；否则转⑥；⑥ 使用free()释放①中申请的buf。⑦ 返回实际读出的字节数。 16. 退出文件系统函数my_exitsys()（1）对应命令：my_exitsys（2）命令调用格式：my_ exitsys（1）函数设计格式：void my_exitsys()（2）功能：退出文件系统。（3）输入：无 （4）输出：无。（5）函数需完成的工作：① 使用C库函数fopen()打开磁盘上的myfsys文件；② 将虚拟磁盘空间中的所有内容保存到磁盘上的myfsys文件中；③ 使用c语言的库函数fclose()关闭myfsys文件；④ 撤销用户打开文件表，释放其内存空间⑤ 释放虚拟磁盘空间。 github代码地址https://github.com/1105358600/LunixFileSystem","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"Linux项目","slug":"软件项目/Linux项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Linux%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T02:15:54.236Z","path":"wiki/实用工具/使用nvm管理node版本，实现高版本与低版本node之间的转换/","text":"先清空本地安装的node.js版本1.按健win+R弹出窗口，键盘输入cmd,然后敲回车（或者鼠标直接点击电脑桌面最左下角的win窗口图标弹出，输入cmd再点击回车键） 然后进入命令控制行窗口，并输入where node查看之前本地安装的node的路径 2.找到上面找到的路径，将node.exe所在的父目录里面的所有东西都删除 3.为了彻底删除之前安装的node.js，鼠标点击电脑左面最左下角的win窗口图标弹出，输入“控制面板”再点击回车键进入，进入控制面板后，找到所安装的node.js并卸载。 安装nvm管理工具1.从官网下载安装包 https://github.com/coreybutler/nvm-windows/releases，下载红框里面的那个，下载后，直接进行安装 2.nvm安装完成后，检验是否安装成功，进入命令控制行窗口（进入方法见前面），输入命令nvm v查看，如果出现版本号，即安装成功（如果安装不成功，查看之前自己安装的node.js有没有删除彻底、安装nvm工过程有没有漏掉什么！）。 安装node.js版本(1) 输入命令行nvm ls anaillable查看可用的node.js版本号 (2) 输入命令行nvm install node版本号(例如：nvm install 12.17.0)即可安装对应版本以及自动安装对应的npm版本。安装完成后可以首先输入npm use+版本号（使用此命令行可以根据你自己的需要随意切换node.js版本运行），之后可分别输入命令行node -v和npm -v，检验node.js以及对应npm是否安装成功，如果可以显示版本号这说明安装成功。 (4) 输入命令行nvm ls查看你安装的所有node.js版本号，以及你当前所选择的node.js运行版本 (4) 如果想删除某node.js版本的话，输入命令行nvm install node版本号（例如：nvm use 12.17.0）即可删除对应版本总结：使用nvm来管理node.js的版本真的很方便，这样就可以根据自己的需要来回切换node.js版本！ 配置镜像在 nvm 的安装路径下，找到 settings.txt，设置node_mirro与npm_mirror为国内镜像地址。下载就飞快了~~ root: D:\\nvmpath: D:\\nodejsnode_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/","tags":[],"categories":[{"name":"实用工具","slug":"实用工具","permalink":"https://pistachiout.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"","date":"2023-02-15T02:15:28.460Z","path":"wiki/论文研究/Nginx高并发实现原理学习/","text":"目前，互联网已经得到了广泛的普及与应用，个人电脑和移动设备的发展,使得即时信息与娱乐服务变的更加方便精巧,基础用户的不断增加使得应用访问量变得巨大。为了提供安全可靠的服务,服务器端正在面临着越来越大的压力。传统的服务器多线程业务逻辑设计在大量用户访问时支撑并发连接的能力有限，不利于构建高性能服务器架构。Nginx 作为当下的高并发连接的负载均衡服务器因其极强的性能得到广泛的使用。本文主要对高并发Nginx进行详细的介绍，重点说明使用Nginx实现Web系统的高并发的原理。 一、Web系统高并发性（一）高并发概念高并发在外行人眼里似乎很高大上，但其实并不难理解，它指的就是我们通过各种设计使得系统能够在同一时间并行处理很多请求。一般来说高并发是一个结果导向的东西，现实中的例子也不少。常见的高并发场景有：双11时淘宝等系统处理大量购物者的购物请求、选课时的学校选课系统、春节时12306网站处理大量的购票请求、微博出现各种惊人热搜等，高并发的概念并不是突然出现的，而是随着业务的发展而产生的需求。高并发的业务场景出现了，随之而来的就是要支持这个高并发业务场景的架构——技术要为业务服务，业务倒逼技术发展，高并发是随着业务发展的。 （二）高并发指标接下来分析高并发的指标。高并发并不意味着仅仅只追求高性能。从宏观的角度来看，高并发系统有三个基本的设计目标，分别是高性能、高可用以及高可扩展性，而这三方面并不是孤立存在的，它们彼此之间是可以相互支撑的。 高性能：性能主要体现了系统的并行处理能力，在有限的硬件投入下，提高性能就意味着能节省成本。衡量软件性能包括了响应时间、TPS、服务器资源利用率等客观指标，也可以是用户的主观感受（从程序员、业务用户、终端用户&#x2F;客户不同的视角，可能会得出不同的结论）。 .高可用性：可用即表示一般情况下系统可以正常服务的时间，指系统具有较高的无故障运行能力，可用性 &#x3D; 平均故障时间 &#x2F; 系统总运行时间。一个全年无故障，能够正常服务；而另一个过不久就出线上事故、宕机，那么用户肯定会选择前者，另外，如果系统可用性过低，也一定会大大拖累业务。 高扩展：表示的是系统处理的扩展能力。在流量高峰时能否在短时间内完成扩容，更平稳地承接峰值流量，比如双11、微博各种惊人热搜等流量巨大时的扩展能力。面对突发流量，不可能临时改造架构，最快的方式就是增加机器来线性提高系统的处理能力。从高并发系统的整体架构角度来看，扩展的目标不仅仅是把服务设计成无状态就行了，因为当流量增加 10 倍，业务服务可以快速扩容 10 倍，但是数据库可能就成为了新的瓶颈。我们需要站在整体架构的角度，而不仅仅是业务服务器的角度来考虑系统的扩展性，所以说，数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等都是系统扩展时需要考虑的因素。我们要知道系统并发到了某一个量级之后，哪一个因素会成为我们的瓶颈点，从而针对性地进行扩展[1]。 （三）高并发架构实现的方法高并发的解决方案包括以下几种： · 流量优化： 防盗链处理（把一些恶意的请求拒之门外） · 前端优化：减少HTTP请求、添加异步请求、启用浏览器的缓存和文件压缩、CDN加速、建立独立的图片服务器； · 服务端优化：页面静态化处理、并发处理、队列处理； · . 数据库优化：数据库的缓存、分库分表、分区操作、读写分离、负载均衡； Web服务器优化：负载均衡。[3] 以上案例总而言之在方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能的提升。垂直维度可包括以下措施： 提升单机的硬件性能：通过增加内存、 CPU核数、存储容量、或者将磁盘 升级成SSD等堆硬件的方式来提升。 ·提升单机的软件性能：使用缓存减少IO次数，使用并发或者异步的方式增加吞吐量。 水平维度可包括以下措施： ·做好分层架构：这是横向扩展的前提，因为高并发系统往往业务复杂，通过分层处理可以简化复杂问题，更容易做到水平扩展。 ·各层进行水平扩展：无状态水平扩容，有状态做分片路由。 业务集群通常能设计成无状态的，而数据库和缓存往往是有状态的，因此需要设计分区键做好存储分片，当然也可以通过主从同步、读写分离的方案提升读性能。[2] 用一个比喻，你想要一个人打十个人，这时候就得想办法了。第一个办法就是努力锻炼自己，然后全副武装，这就是垂直扩展；第二个办法，你一看对面人多，你叫10多个兄弟，然后你们二十个打他们十个，这就是水平扩展；此外还有第三个不常用的办法，你找个门把住，每次就放一个大汉进来，打倒一个再放下一个，这个就是削峰限流的做法。从上面举的例子容易看出，垂直维度方案比较适合业务阶段早期和成本可接受的阶段，该方案是提升性能最简单直接的方式，但是受成本与硬件能力天花板的限制。而水平维度方案所带来的好处一般在业务发展的后期才能体现出来，但是没有垂直方案的天花板问题。一旦达到一定的业务阶段，水平维度是技术发展的必由之路。 本文主要从理论层面研究水平维度上利用Nginx在web服务器上来实现一定的高并发的原理。 二、Nginx实现高并发Nginx是一款是由程序设计师Igor Sysoev所开发的高性能的 Web和 反向代理服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器，以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。很多高知名度的网站都使用 Nginx，比如：Netflix，GitHub， SoundCloud， MaxCDN 等。[4]在高连接并发的情况下，Nginx是Apache服务器不错的替代品。Nginx的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。官方测试Nginx能够支撑5万并发链接，并且CPU、内存等资源消耗却非常低，运行非常稳定。Nginx的主要着眼点就是其高性能以及对物理计算资源的高密度利用，因此其采用了不同的架构模型。受启发于多种操作系统设计中基于“事件”的高级 处理机制，Nginx采用了模块化、事件驱动、异步、单线程及非阻塞的架构，并大量采用了多路复用及事件通知机制。在Nginx中，连接请求由为数不多的几个仅包含一个线程的进程worker以高效的回环(run-loop)机制进行处理，而每个worker可以并行处理数千个的并发连接及请求。[5] （一） Nginx实现高并发的整体架构Nginx 启动时，会生成两种类型的进程，一个是主进程 （master），一个或多个工作进程（worker），因此，Nginx 启动以后，查看操作系统的进程列表，我们就能看到至少有两个Nginx进程。master进程并不处理网络请求，主要负责调度和监控工作进程，接收外部的操作（信号），服务器实际处理网络请求及响应的是工作进程，在类 unix 系统上，Nginx可以配置多个工作进程，而每个工作进程都可以同时处理数以千计的网络请求，而工作进程包括核心和功能性模块，核心模块负责维持一个运行循环，执行网络请求处理的不同阶段的模块功能，也使得我们可以根据需要对功能模块进行适当的选择和修改，编译成具有特定功能的服务器。 （二） Nginx实现高并发的模块化设计高度模块化的设计是 Nginx 的架构基础。1.核心模块：Nginx 服务器正常运行必不可少的模块，提供错误日志记录、配置文件解析、事件驱动机制、进程管理等核心功能。2.标准 HTTP 模块提供 HTTP 协议解析相关的功能。3.可选HTTP模块主要用于 扩展 标准的 HTTP 功能，让 Nginx 能处理一些特殊的服务。4.邮件服务模块主要用于支持 Nginx 的 邮件服务。5.第三方模块是为了扩展 Nginx 服务器应用，完成开发者自定义功能。Nginx服务器被分解为多个模块 ，每个模块就是一个功能模块 ，只负责自身的功能，模块之间严格遵循 “高内聚，低耦合”的原则，这有利于高并发的实现。[6] （三） Nginx实现高并发的请求方式处理Nginx结合多进程机制和异步机制中的异步非阻塞方式。服务器每当收到一个客户端时，就有服务器主进程生成一个子进程出来和客户端建立连接进行交互，直到连接断开，该子进程就结束了。使用多进程的好处是各个进程之间相互独立，不需要加锁，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。其次，采用独立的进程，如果一个进程发生异常退出时，其它进程正常工作， master进程则很快启动新的工作进程，确保服务不会中断，从而将风险降到最低。每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求以后，调用 IO 进行处理，如果不能立即得到结果，就去处理其他请求（非阻塞），而客户端在此期间也无需等待响应，可以去处理其他事情（异步）当IO返回时，就会通知此工作进程，该进程得到通知，暂时挂起当前处理的事务去响应客户端请求。Nginx 的异步非阻塞工作方式正把当中的等待时间利用起来了。在需要等待的时候，这些进程就空闲出来待命了，因此表现为少数几个进程就解决了大量的并发问题。 （四） Nginx实现高并发的进程处理模型Nginx 在启动后，会有一个主进程和多个相互独立的工作进程，主进程负责接收来自外界的信号，向各工作进程发送信号，每个进程都有可能来处理这个连接。主进程能监控工作进程的运行状态，当工作进程由于异常情况退出后，会自动启动新的工作进程。每进来一个请求，会有一个工作进程去处理。但不是全程的处理，处理到可能发生阻塞的地方，比如向上游（后端）服务器转发请求，并等待请求返回。那么，这个处理的工作不会这么傻等着，他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有请求进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，工作才会来接手，这个请求才会接着往下走。由于web server的工作性质决定了每个请求的大部份生命都是在网络传输中，实际上花费在server机器上的时间片不多，这就是为什么几个进程就解决了高并发。每个工作进程都是独立的进程，不共享资源，不需要加锁。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，主进程则很快重新启动新的工作进程。而且 Nginx为了更好的利用多核特性，提供CPU亲缘性的绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换 带来 Cache 的失效对于每个请求，有且只有一个工作进程对其处理。[9] （五） Nginx实现高并发的反向代理与负载均衡反向代理方式是指以代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打 10086 一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx 就是性能非常好的反向代理服务器，用来做负载均衡。而什么是负载均衡呢？随着请求数的快速增长，单服务器已经无法承担大量用户的并发访问，这个时候，就需要建立服务器集群，来让多台服务器协同工作，提高整体项目的吞吐量和QPS。假设一台设备资源占有率已经饱和，而另一台服务器却只有零星几个请求处理，这显然是不合理的。我们期望多台服务器需要平均承担客户端发来的请求，使每台机器都充分利用。这时，我们就需要用到一种技术，叫做负载均衡。负载均衡是多台服务器组合为一个集群，其中每台机器可以单独运行，服务器之间地位相同，通过负载均衡技术，将客户端发来的请求平均分配到每台服务器中，使得项目的负载能够均衡的分布，每台服务器的资源使用量也基本相同。通过负载均衡技术，使得项目巨额访问量从单台服务器均匀的分摊到每台服务器上。[10][12]Nginx对外表现为服务器, 当接受到客户端的HTTP请求时, 并不产生响应, 但也不同于Squid等其他服务器直接转发, 而是会将用户发来的请求缓存一份, 然后再通过负载均衡算法将完整的请求缓存从它的上游集群服务器中选择合适的进行转发, 而上游服务器处理请求生成的响应会直接转发给Nginx, 此时Nginx会边接受边将响应转发给客户, 而不是完整地缓存到响应再一并转发。这正是Nginx作为反向代理服务器的优势所在。[15] Nginx负载均衡主要有三种策略。 轮循（默认）：Nginx根据请求次数，将每个请求均匀分配到每台服务器 最少连接：将请求分配给连接数最少的服务器。Nginx会统计哪些服务器的连接数最少。 ·IP Hash：绑定处理请求的服务器。第一次请求时，根据该客户端的IP算出一个HASH值，将请求分配到集群中的某一台服务器上。后面该客户端的所有请求，都将通过HASH算法，找到之前处理这台客户端请求的服务器，然后将请求交给它来处理。[16][18] 负载均衡对实现高并发有很大作用。一是转发功能按照一定的算法，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。二是故障移除：通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。第三，恢复添加：如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。 通过以上分析可以发现Nginx对比apache服务器的诸多优点。 Nginx 更主要是作为反向代理，而非Web服务器使用。 Nginx是事件驱动服务器，最适合做的就是这种 I&#x2F;O 密集型工作，如反向代理。因为进程在一个地方进行计算时，那么这个进程就不能处理其他事件了。 Nginx 只需要少量进程配合事件驱动，而不像 Apache 多进程模型那样大量的进程数。 Nginx处理静态文件效果也很好，那是因为读写文件和网络通信其实都是 I&#x2F;O操作，处理过程一样。 三、总结本文介绍了高并发的各种概念以及指标，接着说明了Nginx实现高并发的一些原理，并且对比apache服务器，就Nginx在实现高并发方面的诸多优点进行了分析说明。当然本文只是在原理上做了一些分析，在实际中，高并发没有具体的标准，业务场景不一样，执行复杂度不一样，单看并发量也没有意义，必须结合具体场景进行判断。举个例子，访问百度首页通常情况下都是鼠标点击一下就看到结果了，几乎感觉不到等待时间，且百度每秒处理的访问量也非常的大，而如果支付宝扫描二维码支付，通常需要等较久的时间，这就是业务场景上的差距。再比如配置上的不同，用高配物理机得出的数据和最老最低配的虚拟器上的出来的结果是无法比较的。总之，高并发的本质不是多大算高并发的一个数字，而是从架构上、设计上、编码上怎么来保证或者解决由并发引起的问题。高并发的实际要求以及实现远远不止以上说到的内容，Nginx的实现也有更多的方法，往往要根据处理的业务场景和实际的设备以及要求做出灵活应变。 参考文献[1]冰河 海量数据处理与大数据技术实战 北京大学出版社2020-08-01[2]李运华《从零开始学架构》 2021-01-23[3]张开涛 亿级流量网站架构核心技术 电子工业出版社2017年[4]吴宝花 基于Nginx的服务器集群负载均衡策略研究与优化[D].南昌大学,2020.[5]吴翰清 《白帽子讲Web安全 》2012年电子工业出版社[6]杜星. 轻量级Web服务器Nginx的理论与技术研究[D].南京邮电大学,2016.[7]吴陈. 基于Nginx的服务器集群负载均衡策略的研究与改进[D].华南理工大学,2020.[8]刘佳祎,崔建明,智春.基于Nginx服务器的动态负载均衡策略[J].桂林理工大学学报,2020,40(02):403-408.[9]张泽宇. VPPNGX：基于FD.io VPP的高性能Nginx实现[D].上海交通大学,2020.[10]刘茜. 一种基于Nginx负载均衡软件技术实现方法[A]. 天津市电子学会、天津市仪器仪表学会.第三十三届中国（天津）2019’IT、网络、信息技术、电子、仪器仪表创新学术会议论文集[C].天津市电子学会、天津市仪器仪表学会:天津市电子学会,2019:4.[11]刘金秀,陈怡华,谷长乐.基于Nginx的高可用Web系统的架构研究与设计[J].现代信息科技,2019,3(11):94-97.[12]林丽丽.使用高性能Web服务器Nginx实现开源负载均衡[J].大众科技,2010(07):37-38+27.[13]许诺.大数据下基于Nginx负载均衡的教务系统优化设计[J].信息技术与信息化,2021(06):191-193.[14]李刚.Nginx负载均衡技术在高校教务系统中的应用[J].辽宁师专学报(自然科学版),2020,22(03):19-22+32.[15]赵凯.一种基于Nginx反向代理机制的微服务负载均衡方法分析[J].无线互联科技,2020,17(16):140-141.[16]刘旻昊.Nginx服务器“秘籍”[J].中国传媒科技,2018(04):13-14.[17]马原龙. Nginx负载均衡技术研究[D].重庆邮电大学,2016.[18]王艳,陈卫卫.基于Nginx替代Apache在高并发WEB负载均衡系统中的应用[J].电子测试,2015(06):88-92.[19]Castien René F,Coppieters Michel W,Durge Tom S C,ScholtenPeeters Gwendolyne G M. High concurrent validity between digital and analogue algometers to measure pressure pain thresholds in healthy participants and people with migraine: a cross-sectional study.[J]. The journal of headache and pain,2021,22(1):[20]Wang Ling. Design and Implementation of Online Exam Platform Based on High-Concurrency Processing Mode[J]. International Journal of Computational and Engineering,2021,6(2):[21]赵俊哲. 网络流量高并发优化处理研究[D].南京邮电大学,2020.","tags":[],"categories":[{"name":"论文研究","slug":"论文研究","permalink":"https://pistachiout.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"}]},{"title":"","date":"2023-02-15T02:02:41.671Z","path":"wiki/计算机基础知识/编程语言/python/利用python爬取新型冠状肺炎疫情发生以来的实时数据，并进行可视化展示。/","text":"内容：利用python爬取新型冠状肺炎疫情发生以来的实时数据，并进行可视化展示。要求：数据源可自己选择，可视化的内容尽量丰富，除了简单的直方图、曲线图外，还可以有新增确诊&#x2F;疑似病例图、地理分布图、传播动态图等，具体功能自行设计。以Matplotlib为主，可利用Pyecharts等为补充。暂不要求页面部署及用户交互。 在这次实验中，我有了上次实验中学习python的经验，在了解这次实验是爬虫算法后，我就在b站看学习爬虫的视频，了解了爬取代码与正则表达式等内容，但在之后开始自己写爬虫后却发现并不像自己想象的那么简单，而且对于如何可视化也没有头绪，于是只好在网上查找新冠疫情爬取的代码，在查找代码的过程中我发现了一个很好的实时疫情网站，里面的数据规律明显很容易爬取，于是我借鉴代码写出了爬虫程序，并将数据放入到excel表中，但在可视化的过程中任然不知道怎么做，之后我学习了一点可视化的内容，但写出代码运行仍然有问题，考虑到时间问题之后放弃可视化。 四、实验总结 这次实验给了我很多启示，在刚开始看到实验内容时，我认为爬虫很难学习，但发现自己在网上看视频后发现爬虫不像想象的那么难学，代码并不是很复杂，关键是找到正则表达式，之后自己在写的过程中更是发现不同网站源代码的爬取难易度大不相同，在网上学习别人的代码也学习很多，对python的理解也多了很多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import requests,osimport reimport xlwt#写入excel库import time#格式化时间import json#字符串转字典file_path = &#x27;E:/新冠疫情/&#x27;if not os.path.exists(file_path): os.makedirs(file_path) print(&#x27;======数据文件夹不存在=======&#x27;) print(&#x27;======数据文件夹创建成功======&#x27;) print(&#x27;======创建目录为%s======&#x27;%(file_path))else: print(&#x27;======数据保存在目录：%s======&#x27; % (file_path))#检查并创建数据目录headers = &#123;&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1&#x27;&#125;response = requests.get(&#x27;https://ncov.dxy.cn/ncovh5/view/pneumonia?from=timeline&amp;isappinstalled=0&#x27;, headers=headers, timeout=3)# 请求页面response = str(response.content, &#x27;utf-8&#x27;)# 中文重新编码areas_type_dic_raw = re.findall(&#x27;try &#123; window.getAreaStat = (.*?)&#125;catch\\(e\\)&#x27;,response)areas_type_dic = json.loads(areas_type_dic_raw[0])#将json对象转变为python对象count = 2#数据写入行数记录newworkbook = xlwt.Workbook()worksheet = newworkbook.add_sheet(&#x27;all_data&#x27;)# 打开工作簿，创建工作表worksheet.write(1, 2, &#x27;省份名称&#x27;)worksheet.write(1, 3, &#x27;省份简称或城市名称&#x27;)worksheet.write(1, 4, &#x27;确诊人数&#x27;)worksheet.write(1, 5, &#x27;疑似人数&#x27;)worksheet.write(1, 6, &#x27;治愈人数&#x27;)worksheet.write(1, 7, &#x27;死亡人数&#x27;)worksheet.write(1, 8, &#x27;地区ID编码&#x27;)#写入数据列标签for province_data in areas_type_dic: provincename = province_data[&#x27;provinceName&#x27;] provinceshortName = province_data[&#x27;provinceShortName&#x27;] p_confirmedcount = province_data[&#x27;confirmedCount&#x27;] p_suspectedcount = province_data[&#x27;suspectedCount&#x27;] p_curedcount = province_data[&#x27;curedCount&#x27;] p_deadcount = province_data[&#x27;deadCount&#x27;] p_locationid = province_data[&#x27;locationId&#x27;] #用循环获取省级以及该省以下城市的数据 worksheet.write(count, 2, provincename) worksheet.write(count, 3, provinceshortName) worksheet.write(count, 4, p_confirmedcount) worksheet.write(count, 5, p_suspectedcount) worksheet.write(count, 6, p_curedcount) worksheet.write(count, 7, p_deadcount) worksheet.write(count, 8, p_locationid) #在工作表里写入省级数据 count += 1 #此处为写入行数累加，province部分循环 for citiy_data in province_data[&#x27;cities&#x27;]: cityname = citiy_data[&#x27;cityName&#x27;] c_confirmedcount = citiy_data[&#x27;confirmedCount&#x27;] c_suspectedcount = citiy_data[&#x27;suspectedCount&#x27;] c_curedcount = citiy_data[&#x27;curedCount&#x27;] c_deadcount = citiy_data[&#x27;deadCount&#x27;] c_locationid = citiy_data[&#x27;locationId&#x27;] #该部分获取某个省下某城市的数据 worksheet.write(count, 3, cityname) worksheet.write(count, 4, c_confirmedcount) worksheet.write(count, 5, c_suspectedcount) worksheet.write(count, 6, c_curedcount) worksheet.write(count, 7, c_deadcount) worksheet.write(count, 8, c_locationid) #该部分在工作表里写入某城市的数据 count += 1 #此处为写入行数累加，cities部分循环current_time = time.strftime(&quot;%Y-%m-%d-%H-%M-%S&quot;, time.localtime())newworkbook.save(&#x27;E:\\新冠疫情\\疫情实时爬取-%s.xls&#x27; % (current_time))print(&#x27;======数据爬取成功======&#x27;) 爬取结果：https://download.csdn.net/download/qq_45808700&#x2F;19598095?spm&#x3D;1001.2014.3001.5503","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"python","slug":"计算机基础知识/编程语言/python","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"}]},{"title":"","date":"2023-02-15T02:02:13.109Z","path":"wiki/计算机基础知识/算法笔记/用Python语言编程实现至少7种排序算法/","text":"一、实验目的及要求1、用Python语言编程实现二分搜索算法：已知不重复且已经按从小到大排好的m个整数的数组A[1..m]（设m&#x3D;2 k，k是一个确定的非负整数）。对于给定的整数c，要求寻找一个下标i，使得A[i]&#x3D;c；若找不到，则返回一个0。2、用Python语言编程实现至少7种排序算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110```cdef BinarySearch(Arr,c): if len(Arr)==0: return -1 left=0 right=len(Arr)-1 while right&gt;left mid=(left+right)//2 if Arr[mid]&lt;c: left=mid+1 elif Arr[mid]&gt;x: right=mid-1 else: return midreturn -1def bubbleSort(nums): for i in range(len(nums) - 1): # 遍历 len(nums)-1 次 for j in range(len(nums) - i - 1): # 已排好序的部分不用再次遍历 if nums[j] &gt; nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] # Python 交换两个数不用中间变量 return numsdef countingSort(nums): bucket = [0] * (max(nums) + 1) # 桶的个数 for num in nums: # 将元素值作为键值存储在桶中，记录其出现的次数 bucket[num] += 1 i = 0 # nums 的索引 for j in range(len(bucket)): while bucket[j] &gt; 0: nums[i] = j bucket[j] -= 1 i += 1 return numsdef shellSort(nums): step = len(nums) while True: step = int(step / 3 + 1)#增量序列依次减少 for n in range(step): #希尔排序即在每个分组内用插入排序，增量从1变为step for i in range(n + step, len(nums), step): temp=nums[i] j=i-step while j&gt;=n and temp&lt;nums[j]: nums[j+step]=nums[j] j=j-step nums[j+step]=temp print(nums) #插入排序 if step &lt;= 1: break def selectionSort(nums): for i in range(len(nums)-1):#遍历len（nums）-1次 minIndex=i #最小值的下表 for j in range(i+1,len(nums))#在i到len（nums）之间找到最小值 if nums[j]&lt;num&#123;minIndex] minIndex=j nums[i],nums[minIndex]=nums[minIndex],nums[i]# 把最小值放在i位置之后i+1 return numsdef quicksort(nums, ipos, epos): if epos - ipos &lt;= 1: return nums beg = ipos end = epos while ipos &lt; epos: while nums[ipos] &lt; nums[epos]: epos -= 1 nums[ipos], nums[epos] = nums[epos], nums[ipos] while nums[epos] &gt; nums[ipos]: ipos += 1 nums[ipos], nums[epos] = nums[epos], nums[ipos] quicksort(nums, beg, ipos) quicksort(nums, ipos + 1, end)def MergeSort(lists): if len(lists) &lt;= 1: return lists num = int( len(lists) / 2 ) left = MergeSort(lists[:num]) right = MergeSort(lists[num:]) return Merge(left, right)def Merge(left,right): r, l=0, 0 result=[] while l&lt;len(left) and r&lt;len(right): if left[l] &lt;= right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += list(left[l:]) result += list(right[r:]) return resultdef insertionSort(lst): if len(lst) == 1: return lst for i in range(1, len(lst)):#插入排序i从1开始到len-1 temp = lst[i] j = i - 1 #而j从0开始，从而对lit[0]也参与排序 while j &gt;= 0 and temp &lt; lst[j]: lst[j + 1] = lst[j]#将list[j]往后移 j -= 1 lst[j + 1] = temp#因为j=j-1，所以每次循环相当于新的j与temp换位置,直到排序完成（即相当于将list[i]大的数依次往后移使list[i]完成插入） print(lst) return lst``` .","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2023-02-15T01:58:28.039Z","path":"wiki/软件项目/JavaWeb项目/支付宝支付模拟demo/","text":"1.实验环境1.利用沙箱环境模拟支付宝支付的实验，首先配置沙箱环境，下载官方DEMO，环境配置，生成公钥和私钥的工具类，使用RSA签名验签工具生成公钥和私钥，配置环境运行。 2.支付流程图： 3.支付宝支付实现-代码：支付设置-商户方： 支付设置-支付宝服务端： 将订单整合修改成为账单向支付宝发送请求： 同步通知接口： 异步通知接口： 4.运行截图","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:58:17.536Z","path":"wiki/计算机基础知识/编程语言/Java/递归+回溯法/","text":"1、假设A、B、C、D、E各城市间路费如下表所列，左起一列是起点，上面一行是终点，即从A到B的旅费是7，从B到A时6。某人想从一个城市出发游览各城市一遍，在回到出发地，而所用的旅费最少。请编写一程序，求出从各地出发回到出发地的所有最佳路线。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class work1 &#123; static int N=5; int Max=Integer.MAX_VALUE; char[] City=new char[]&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;; int map[][]=&#123;&#123;Max,7,3,10,15&#125;,&#123;6,Max,5,13,12&#125;,&#123;4,8,Max,5,10&#125;,&#123;9,11,6,Max,11&#125;,&#123;17,14,9,8,Max&#125;&#125;; int[] visited=new int[N]; //该城市是否访问 int[] visit=new int[N];; //记录第i次去的城市 int[] road=new int[N];; //路线 int cost; //费用 int start;//起点城市 int c; //输出行程 void print()&#123; System.out.print(&quot;从城市&quot;+City[start]+&quot;出发的最短行程为：&quot;); for(int j=0;j&lt;N;j++) System.out.print(City[road[j]]+&quot;-&gt;&quot;); System.out.print(City[start]); System.out.println(&quot;费用为：&quot;+cost); &#125; //初始化 void init()&#123; cost=Max; c=0; for(int i=0;i&lt;N;i++)&#123; visited[i]=0; visit[i]=-1; &#125; &#125; void Travel(int n)&#123; if(n==N)&#123; //全部城市旅游完 if(c+map[visit[n-1]][start]&lt;cost)&#123; //返回起点且总费用最少 for(int j=0; j&lt;n; j++) road[j]=visit[j]; cost=c+map[visit[n-1]][start]; return; &#125; &#125; else&#123; for(int i=0;i&lt;N;i++)&#123; if(visited[i]==0&amp;&amp;c+map[visit[n-1]][i]&lt;cost) &#123; visit[n]=i; visited[visit[n]]=1; c+=map[visit[n-1]][i]; Travel(n+1);//搜索下一个城市 c-=map[visit[n-1]][i]; //返回，删除节点 visited[visit[n]]=0; &#125; &#125; &#125;&#125; public static void main(String[] args) &#123; work1 work=new work1(); for(int i=0;i&lt;N;i++)&#123; work.init(); work.start=i; work.visit[0]=i;//设置出发点 work.visited[work.start]=1; work.Travel(1); work.print(); &#125; &#125;&#125; 2、一块土地上，农民可以种水稻、大豆、燕麦或牧草这四种作物。一年的收益不仅与当年种什么有关，还与去年种什么有关。它们之间的关系如下表。如果农民作一个五年生产计划，已知第一年种植之前种的是牧草。问各年应种什么，使收益最大？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class work4 &#123; static int N=5; String[] X=new String[]&#123;&quot;水稻&quot;,&quot;大豆&quot;,&quot;燕麦&quot;,&quot;牧草&quot;&#125;; int map[][]=&#123;&#123;3,2,4,1&#125;,&#123;15,1,17,7&#125;,&#123;9,4,6,5&#125;,&#123;11,1,4,3&#125;&#125;; int[] visit=new int[N+1];; //记录第i次暂时种的作物 int[] Crops=new int[N+1];; //记录最大值时每年种的作物 int money; //收益 int temp; void print()&#123; for(int j=1;j&lt;N+1;j++) System.out.print(&quot;第&quot;+j+&quot;年种&quot;+X[Crops[j]]+&quot;-&gt;&quot;); System.out.println(&quot;收货为：&quot;+money); &#125; void init()&#123;//初始化 money=0; temp=0; for(int i=0;i&lt;N;i++)&#123; visit[i]=-1; &#125;&#125; void crop(int n)&#123; if(n==N) for(int i=0;i&lt;4;i++)&#123; if(temp+map[visit[N-1]][i]&gt;money)&#123; for(int j=0; j&lt;n; j++) Crops[j]=visit[j]; money=temp+map[visit[n-1]][i]; return; &#125; &#125; else&#123; for(int i=0;i&lt;4;i++)&#123; visit[n]=i; temp+=map[visit[n-1]][i]; crop(n+1);//下一年 temp-=map[visit[n-1]][i]; //返回，删除节点 &#125; &#125;&#125; public static void main(String[] args) &#123; work4 work=new work4(); work.init(); work.visit[0]=3;//设置出发点 work.crop(1); work.print(); &#125;&#125; 二、代码思路总结一下回溯法的关键，首先需要一个temp函数来记录目前的花费或收益，最后输出的变量result；对于像第一题这种遍历过后不用重复遍历的，需要用visited[]来记录当前结点是否被访问过，若被访问过则不再访问，而第2题可重复遍历则不用使用visited[]记录；此外还必须使用visit[]记录当前访问的结点路径，这是类似temp来暂存访问路径的数组，然后在有一个最后输出的数组road[]。之后有一个递归函数，在函数中更新temp，visited[]与visit[]，且递归函数一定要有递归退出条件，如这两道题中的n&#x3D;&#x3D;N判断是否递归退出，在退出时判断temp与result，如果当前的temp较大，则把visit[]与temp赋值给road[]与result，这样重复递归遍历多次，最后递归完成的result则为所求的最值。","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:58:06.328Z","path":"wiki/计算机基础知识/编程语言/Java/设计一个小英汉词典，其中英文单词的个数为30（单词可自己任选），从键盘输入单词，程序将单词的中文解释输出，若没有找到，则输出：not found in our dictionary！/","text":"设计一个小英汉词典，其中英文单词的个数为30（单词可自己任选），编程序，从键盘输入单词，程序将单词的中文解释输出，若没有找到，则输出：not found in our dictionary！12345678910111213141516171819202122232425//import java.io.*;import java.util.*;//import java.util.Scanner;public class UseOfDictionary &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String[] englishWords=new String[]&#123;&quot;computer&quot;,&quot;university&quot;,&quot;people&quot;,&quot;student&quot;,&quot;economics&quot;,&quot;me&quot;,&quot;our&quot;,&quot;so&quot;,&quot;import&quot;,&quot;implments&quot;,&quot;interface&quot;,&quot;final&quot;,&quot;public&quot;,&quot;dictionary&quot;,&quot;english&quot;,&quot;chinses&quot;,&quot;simple&quot;,&quot;social&quot;,&quot;why&quot;,&quot;difficult&quot;,&quot;simple&quot;,&quot;close&quot;,&quot;beautiful&quot;,&quot;omit&quot;,&quot;adequate&quot;,&quot;circumstance&quot;,&quot;abolish&quot;,&quot;vacant&quot;,&quot;reluctant&quot;,&quot;excessive&quot;&#125;; String[] chineseTranslation=new String[]&#123;&quot;n.计算机&quot;,&quot;n.综合性大学&quot;,&quot;n.人们、人民&quot;,&quot;n.大学生&quot;,&quot;n.经济学&quot;,&quot;n.我&quot;,&quot;n.我们的&quot;,&quot;n.所以&quot;,&quot;n.传入;引入&quot;,&quot;n.实施;执行;实现&quot;,&quot;与…连接;接合&quot;,&quot;最后的;&quot;,&quot;公众的&quot;,&quot;词典&quot;,&quot;英语&quot;,&quot;中文&quot;,&quot;简单的&quot;,&quot;社会的&quot;,&quot;为什么&quot;,&quot;困难的&quot;,&quot;简单的&quot;,&quot;近的&quot;,&quot;漂亮的&quot;,&quot;遗漏&quot;,&quot;充足的&quot;,&quot;情况&quot;,&quot;废除&quot;,&quot;空闲的&quot;,&quot;不情愿的&quot;,&quot;过多的&quot;&#125;; Map&lt;String,String&gt; dictionary=new TreeMap&lt;String,String&gt;(); for(int i=0;i&lt;englishWords.length;i++) dictionary.put(englishWords[i], chineseTranslation[i]); System.out.println(&quot;请从键盘上输入你想要翻译的单词：&quot;); Scanner input=new Scanner(System.in); String userword=input.next();//输入数据 if(dictionary.get(userword)!=null) &#123; System.out.println(dictionary.get(userword)); &#125; else System.out.println(&quot;not found in our dictionary！&quot;); &#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:56:46.577Z","path":"wiki/计算机基础知识/编程语言/Java/数组模拟实现一个50个字符串的堆栈，使用堆栈，将中缀算术表达式转换成后缀表达式。/","text":"1、用数组模拟实现一个50个字符串的堆栈，并使这个堆栈有如下方法和参数：myStack：数组名，使用时不能直接对这个数组进行存取操作，存取操作都通过pop()和push()完成。实现pop(): 弹出实现push()：压入实现isFull()：是否已满实现isEmpty()：是否为空实现length()：已有多少元素 12345678910111213141516171819202122232425262728293031323334353637383940public class StackImiate &#123; public int maxSize; public char[] a; public int top; StackImiate(int maxSize) &#123; this.maxSize=maxSize; a=new char[maxSize]; top=-1; &#125; public void push(char str) &#123; a[++top]=str; &#125; public char pop() &#123; return a[top--]; &#125; public boolean isEmpty() &#123; return(top==-1); &#125; public boolean isFull() &#123; return(top==maxSize); &#125; public int length() &#123;return top+1;&#125; public char peek() &#123; return a[top]; &#125; public char peekN(int n) &#123; //System.out.println(a[n]); return a[n]; &#125; public void displayStack(String s) &#123; System.out.print(s); System.out.print(&quot; Stack (bottom--&gt;top): &quot;); for(int j=0;j&lt;maxSize;j++) &#123; System.out.print(peekN(j)+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 2、使用堆栈，将中缀算术表达式转换成后缀表达式。A、表达式中只有＋、－、×，&#x2F;，％，（，）六种运算符B、变量名为以英文字母开头的字母数字串C、表达式中可以出现不带符号的常数D、适当判断表达式中的语法错误E、不计算结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class InToPost &#123; public static void main(String[] args) &#123; String strResult=new String(); String Input=&quot;a+b*c+(d*e+f)*g&quot;; strResult=strResult+doTrans(Input); System.out.println(); System.out.println(strResult); &#125; public static StringBuffer doTrans(String Input) &#123;//返回strResult的函数 StackImiate str=new StackImiate(50); StringBuffer strResultTemp=new StringBuffer(); for (int i = 0; i &lt;Input.length(); i++) &#123; char ch = Input.charAt(i); str.displayStack(&quot;Get &quot; + ch + &quot; &quot;); switch (ch) &#123; case &#x27;+&#x27;: case &#x27;-&#x27;: gotOper(ch, 1,str,strResultTemp); break; case &#x27;*&#x27;: case &#x27;/&#x27;: case &#x27;%&#x27;: gotOper(ch, 2,str,strResultTemp); break; case &#x27;(&#x27;: str.push(ch); break; case &#x27;)&#x27;: gotParen(ch,str,strResultTemp); break; default: strResultTemp =strResultTemp.append(ch); break; &#125; &#125; while (!str.isEmpty()) &#123; str.displayStack(&quot;out &quot;); strResultTemp = strResultTemp.append(str.pop()); &#125; str.displayStack(&quot;End &quot;); return strResultTemp; &#125; public static void gotParen(char ch,StackImiate str,StringBuffer strResultTemp) &#123;//对括号进行处理的函数 while (!str.isEmpty()) &#123; char chx = (char) str.pop(); if (chx == &#x27;(&#x27;) &#123; break; &#125; else &#123; strResultTemp =strResultTemp.append(chx); &#125; &#125; &#125; private static void gotOper(char ch, int i,StackImiate str,StringBuffer strResultTemp) &#123;//对运算符的优先级处理 // TODO Auto-generated method stub while (!str.isEmpty()) &#123; char opTop = (char) str.pop(); if (opTop == &#x27;(&#x27;) &#123; str.push(&#x27;(&#x27;); break; &#125; else &#123; int k; if (opTop == &#x27;+&#x27; || opTop == &#x27;-&#x27;) &#123; k = 1; &#125; else &#123; k = 2; &#125; if (k &lt; i) &#123; str.push(opTop); break; &#125; else &#123; strResultTemp = strResultTemp.append(opTop); &#125; &#125; &#125; str.push(ch); &#125; &#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:56:36.824Z","path":"wiki/计算机基础知识/编程语言/Java/泛型集合类中的链表类随机产生100个有序整数（单词）的链表/","text":"选择泛型集合类中的链表类用此类：a、随机产生100个整数（范围自定）的链表，在生成的过程中从小到大排列，然后输出；b、随机产生100个6个英文字母的单词的链表，在生成的过程中从小到大排列，然后用链表方式输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;import java.util.LinkedList;import java.util.Random;public class CollectionsSort_IntAndStr &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub link100Int(); link100String(); &#125; public static void link100Int() &#123; LinkedList&lt;Integer&gt; linkInt=new LinkedList&lt;Integer&gt;(); Random random=new Random(); for(int i=0;i&lt;100;i++) &#123; linkInt.add(random.nextInt(1001));//random.nextInt(n)产生随机值【0，n） &#125; Collections.sort(linkInt);//Collections.sort排序 System.out.println(&quot;整数排序后&quot;); for(int i=0;i&lt;100;i++) &#123; System.out.print(linkInt.get(i)+&quot; &quot;); if((i+1)%10==0) System.out.println(); &#125; &#125; public static void link100String() &#123; LinkedList&lt;String&gt; linkStr=new LinkedList&lt;String&gt;(); for(int i=0;i&lt;100;i++) &#123;StringBuffer StrB=new StringBuffer(); for(int j=0;j&lt;6;j++) &#123; StrB.append((char)(&#x27;a&#x27;+(Math.random()*26))); &#125; linkStr.add(StrB.toString()); &#125; Collections.sort(linkStr);//Collections.sort排序 System.out.println(&quot;String排序后&quot;); for(int i=0;i&lt;100;i++) &#123; System.out.print(linkStr.get(i)+&quot; &quot;); if((i+1)%10==0) System.out.println(); &#125; &#125; &#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:55:43.695Z","path":"wiki/计算机基础知识/编程语言/Java/用Java I0 api将SomeData.txt其中的所有数据读出，计算出每一行的后4列数据的平均值，存放到新文件AvgSomeData.txt文件中 (1)/","text":"查看文本文件SomeData.txt中的数据并分析其格式，用Java I0 api将其中的所有数据读出，计算出每一行的后4列数据的平均值，存放到新文件AvgSomeData.txt文件中，存放时每一行前面要加上行号（行号占3位，右对齐），平均值放到行末并左对齐。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;import java.io.*;public class FIleStream &#123; public static void main(String[] args) &#123; FileReader inReader; FileWriter outWriter; try&#123; inReader=new FileReader(&quot;D:\\\\Documents\\\\SomeData.txt&quot;); outWriter=new FileWriter(&quot;D:\\\\Documents\\\\SomeData2.txt&quot;); //inReader. &#125; catch (IOException e) &#123; System.out.println(&quot;File can&#x27;t be found or File creates error.&quot;); return; &#125; BufferedReader in=new BufferedReader(inReader);//??????????????????????? BufferedWriter out=new BufferedWriter(outWriter);//???????????????????????? String str; int lineNo=0; //inStream.read try&#123; while ((str=in.readLine())!=null) &#123; System.out.print(str); String[] splits=str.split(&quot;\\t&quot;); System.out.println(&quot; &quot;+(int)(Double.parseDouble(splits[3])+Double.parseDouble(splits[4])+Double.parseDouble(splits[5])+Double.parseDouble(splits[6]))/4); out.write(String.format(&quot;%1$03d&quot;, lineNo++)+&quot; &quot;+str+&quot;\\t&quot;+(int)(Double.parseDouble(splits[3])+Double.parseDouble(splits[4])+Double.parseDouble(splits[5])+Double.parseDouble(splits[6]))/4+&quot;\\r\\n&quot;); &#125; in.close(); out.close(); inReader.close(); outWriter.close(); &#125;catch(IOException e) &#123; System.out.println(&quot;\\nIO Errors.&quot;); return; &#125; System.out.println(&quot;\\n\\n\\nDone!&quot;); &#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:54:52.801Z","path":"wiki/计算机基础知识/编程语言/Java/输入一个文件系统的子目录，编程序将其中的所有内容的名字输出/","text":"输入一个文件系统的子目录，编程序将其中的所有内容的名字输出到console上，要求：a、使用泛型的动态数组作为工具；b、使用课本193页的File对象及其方法；c、将此子目录下的所有子目录（可能有很多层）及其中的所有文件的文件名输出；d、输出目录名和文件名时，用前缀空格显示出层次关系； 12345678910111213141516171819202122232425import java.util.*;import java.io.*;import java.io.*;public class OutputFiles &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ArrayList&lt;File&gt; files=new ArrayList&lt;File&gt;(); File myFile=new File(&quot;D:\\\\Documents\\\\FileRecv\\\\学习&quot;); files.add(myFile); for(int i=0;i&lt;files.size();i++) &#123; if(files.get(i).isDirectory()) &#123;File[] ListFiles=files.get(i).listFiles(); for(int j=0;j&lt;ListFiles.length;j++) &#123;files.add(ListFiles[j]); &#125; &#125; &#125; for(int i=0;i&lt;files.size();i++) &#123; System.out.println(files.get(i).getName()); &#125;&#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:54:39.055Z","path":"wiki/计算机基础知识/编程语言/Java/设计一个randomValue值的比较器，生成一副牌后用此比较器洗牌，然后输出洗好的整副牌。/","text":"2.现有扑克牌类设计一个此类对randomValue值的比较器，生成一副牌后用此比较器洗牌，然后输出洗好的整副牌。设计对rank值的比较器，然后对整副牌进行排序输出，观察效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class Card implements Comparable&lt;Card&gt;&#123; char suit; char rank; double randomValue; Card(char aSuit,char aRank) &#123; suit=aSuit; rank=aRank; randomValue=Math.random(); &#125; void dispaly() &#123; System.out.print( Character.toString(suit)+Character.toString(rank)+&#x27; &#x27;); &#125; public int compareTo(Card card) &#123; return this.randomValue&gt;card.randomValue?1:(this.randomValue&lt;card.randomValue?-1:0); &#125; &#125;class CompareRank implements Comparator&lt;Card&gt;&#123; public int compare(Card a,Card b) &#123; return a.rank&gt;b.rank?1:(a.rank&lt;b.rank?-1:0); &#125;&#125;import java.util.*;public class CardSort &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub char[] suits= &#123;&#x27;梅&#x27;,&#x27;方&#x27;,&#x27;桃&#x27;,&#x27;心&#x27;&#125;; char[] values= &#123;&#x27;A&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;T&#x27;,&#x27;J&#x27;,&#x27;Q&#x27;,&#x27;K&#x27;&#125;; List&lt;Card&gt; cards=new LinkedList&lt;Card&gt;(); for(int i=0;i&lt;13;i++) &#123; for(int j=0;j&lt;4;j++) &#123; cards.add(new Card(suits[j],values[i])); &#125; &#125; cards.add(new Card(&#x27;小&#x27;,&#x27;鬼&#x27;)); cards.add(new Card(&#x27;大&#x27;,&#x27;鬼&#x27;)); Collections.sort(cards); for(int i=0;i&lt;54;i++) &#123;cards.get(i).dispaly(); &#125; System.out.println(); Collections.sort(cards,new CompareRank()); for(int i=0;i&lt;54;i++) &#123;cards.get(i).dispaly(); &#125; &#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:54:27.336Z","path":"wiki/计算机基础知识/编程语言/Java/Java反射学习笔记/","text":"1.反射概念JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，通过Class实例获取class信息的方法称为反射（Reflection）。 JVM总是动态加载class，可以在运行期根据条件来控制加载class。 2.获取字段 先获取Class实例，再获取Field实例，然后调用Field.setAccessible(true)，用Field.get(Object)获取指定实例的指定字段的值。 3.调用方法 4.调用构造方法 5.获取继承关系 6.动态代理Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:54:15.632Z","path":"wiki/计算机基础知识/编程语言/Java/随机生成100个0到200的整数 用折半查找法（二分法）查找50是初始数据的第几个数， 并输出查找过程（即和什么数进行了比较）。/","text":"1、随机生成100个0到200的整数用折半查找法（二分法）查找50是初始数据的第几个数， 并输出查找过程（即和什么数进行了比较）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Random0To200 &#123; public int random; public int num; public void display() &#123;System.out.print(random+&quot;在第&quot;+num+&quot;个位置 &quot;);&#125; &#125; ```javapublic class find50 &#123; private static Random0To200[] randomArrays; public static void main(String[] args) &#123;int num=0; randomArrays = new Random0To200[100]; for(int i=0;i&lt;100;i++) &#123;randomArrays[i]= new Random0To200(); randomArrays[i].random=(int) (Math.random()*201); randomArrays[i].num=i; &#125; for(int i=0;i&lt;100;i++) &#123;randomArrays[i].display();num++; if(num==10) &#123;num=0; System.out.println(); &#125;&#125; System.out.println(); Random0To200 temp=new Random0To200(); for(int i=0;i&lt;100;i++) &#123; for(int j=i;j&lt;100;j++) &#123; if(randomArrays[i].random&gt;randomArrays[j].random) &#123;temp=randomArrays[i]; randomArrays[i]=randomArrays[j]; randomArrays[j]=temp; &#125; &#125; &#125; System.out.println(&quot;排序后&quot;); for(int i=0;i&lt;100;i++) &#123; randomArrays[i].display();num++; if(num==10) &#123;num=0; System.out.println(); &#125;&#125; System.out.println(&quot;&quot;); int low=0; int high=99; int mid; while(low&lt;=high) &#123;mid=(low+high)/2; if(randomArrays[mid].random==50) &#123;System.out.println(randomArrays[mid].random+&quot;=50&quot;); randomArrays[mid].display(); System.out.println(); randomArrays[mid].random=0; &#125; else if(randomArrays[mid].random&lt;50) &#123;low=mid+1; System.out.println(randomArrays[mid].random+&quot;&lt;50&quot;);&#125; else &#123;high=mid-1; System.out.println(randomArrays[mid].random+&quot;&gt;50&quot;);&#125; &#125; System.out.println(&quot; 已无50&quot;);&#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:54:05.135Z","path":"wiki/计算机基础知识/编程语言/Java/java继承与多态/","text":"1、设计一个数据类型判断类Polymorphism，使用重载、装箱等技术判断一个不带等号的Java表达式的结果的数据类型。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Polymorphism &#123; private final static String INT_TYPE = &quot;int&quot;; private final static String LONG_TYPE = &quot;long&quot;; private final static String DOUBLE_TYPE = &quot;double&quot;; private final static String FLOAT_TYPE = &quot;float&quot;; private final static String CHAR_TYPE = &quot;char&quot;; private final static String BYTE_TYPE = &quot;byte&quot;; private final static String SHORT_TYPE = &quot;short&quot;; private final static String BOOLAEN_TYPE = &quot;boolean&quot;; private final static String String_TYPE = &quot;String&quot;; public static String getType(int i) &#123; return INT_TYPE; &#125; public static String getType(long l) &#123; return LONG_TYPE; &#125; public static String getType(double d) &#123; return DOUBLE_TYPE; &#125; public static String getType(float f) &#123; return FLOAT_TYPE; &#125; public static String getType(char c) &#123; return CHAR_TYPE; &#125; public static String getType(byte by) &#123; return BYTE_TYPE; &#125; public static String getType(short s) &#123; return SHORT_TYPE; &#125; public static String getType(boolean bo) &#123; return BOOLAEN_TYPE; &#125; public static String getType(String Str) &#123; return String_TYPE; &#125; public static String getType(Object obj)&#123; return obj != null ? obj.toString().split(&quot;@&quot;)[0] : null; &#125; public static void main(String[] args) &#123; System.out.println(&quot;100是&quot;+getType(100)+&quot;类型&quot;); System.out.println(&quot;1ds是&quot;+getType(&quot;1ds&quot;)+&quot;类型&quot;); System.out.println(&quot;8==9是&quot;+getType(8==9)+&quot;类型&quot;); System.out.println(&quot;100.15是&quot;+getType(100.15)+&quot;类型&quot;); System.out.println(&quot;a是&quot;+getType(&#x27;a&#x27;)+&quot;类型&quot;); System.out.println(&quot;100+222.5是&quot;+getType(100+222.5)+&quot;类型&quot;); System.out.println(&quot;100+&#x27;a&#x27;是&quot;+getType(100+&#x27;a&#x27;)+&quot;类型&quot;); System.out.println(&quot;5.9/54是&quot;+getType(5.9/54)+&quot;类型&quot;); System.out.println(&quot;599999999L是&quot;+getType(599999999L)+&quot;类型&quot;); &#125; &#125; 2、设计一个链表结点类LinkNode此类可以存放int、long、float、double、byte、short、String、StringBuffer类型的数据。用此类：a、随机产生100个整数（范围自定）的链表，在生成的过程中从小到大排列，然后输出；b、随机产生100个6个英文字母的单词的链表，在生成的过程中从小到大排列，然后输出。（关注装箱和拆箱相关概念 Integer String） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class LinkNode &#123; public Object value; public LinkNode nextNode; public LinkNode(Object value,LinkNode nextNode) &#123;this.value=value; this.nextNode=nextNode;&#125; public LinkNode() &#123;&#125; public LinkNode(Object value) &#123;this.value=value;&#125;&#125;package text5; public class RandomInt&#123; public static void main(String[] args) &#123; StringBuffer StrB=new StringBuffer(); LinkNode firstNode=new LinkNode(0); firstNode.nextNode=new LinkNode(0); for(int i=0;i&lt;105;i++) &#123; LinkNode aNew=new LinkNode(); LinkNode compare=firstNode.nextNode; LinkNode before=firstNode; compare=firstNode.nextNode; int aNum=(int)(Math.random()*1001); aNew=new LinkNode(aNum); if(i==0) &#123; compare=aNew; continue; &#125; while(aNum&gt;Integer.parseInt(compare.value.toString())) &#123;if(compare.nextNode!=null) &#123;compare=compare.nextNode; before=before.nextNode; &#125; else &#123;before=before.nextNode; break; &#125; &#125; if(before!=compare) &#123;before.nextNode=aNew; aNew.nextNode=compare;&#125; else &#123; compare.nextNode=aNew; &#125; &#125; for(int i=1;i&lt;103;i++) &#123; if(i&gt;2) &#123;System.out.print(i-2+&quot;: &quot;+firstNode.value+&quot; &quot;);&#125; firstNode=firstNode.nextNode; if((i-2)%10==0) System.out.println(); &#125; &#125; &#125;package text5;public class RandomStr &#123; public static void main(String[] args) &#123; StringBuffer StrB=new StringBuffer(); LinkNode firstNode=new LinkNode(&quot;first&quot;); firstNode.nextNode=new LinkNode(&quot; &quot;); for(int i=0;i&lt;105;i++) &#123; LinkNode aNew=new LinkNode(); LinkNode compare=firstNode.nextNode; LinkNode before=firstNode; compare=firstNode.nextNode; StrB=new StringBuffer(); for (int j=0;j&lt;6;j++) &#123;int aNum=(int)(Math.random()*26); char aChar=(char)(&#x27;a&#x27;+aNum); StrB.append(aChar); &#125; aNew=new LinkNode(StrB); if(i==0) &#123; compare=aNew; continue; &#125; while(StrB.toString().compareTo(compare.value.toString())&gt;0) &#123;if(compare.nextNode!=null) &#123;compare=compare.nextNode; before=before.nextNode; &#125; else &#123;before=before.nextNode; break; &#125; &#125; if(before!=compare) &#123;before.nextNode=aNew; aNew.nextNode=compare;&#125; else &#123; compare.nextNode=aNew; &#125; &#125; for(int i=1;i&lt;103;i++) &#123; if(i&gt;2) &#123;System.out.print(i-2+&quot;: &quot;+firstNode.value+&quot; &quot;);&#125; firstNode=firstNode.nextNode; if((i-2)%10==0) System.out.println(); &#125; &#125; &#125; 3、A、在main()中使用上题的LinkNode类创建4个实例并赋予不同的值（long、double、 StringBuffer、MyDate），然后使用Object中默认的toString()方法（从超级父类继承而来） 显示结果。 1234567891011121314151617181920212223242526272829public class LinkNodes extends LinkNode&#123; public LinkNodes(Object value,LinkNode nextNode) &#123;this.value=value; this.nextNode=nextNode;&#125; public LinkNodes() &#123;&#125; public LinkNodes(Object value) &#123;this.value=value;&#125; public String toString(long longNum) &#123; String str=longNum+&quot;&quot;; return str; &#125; public String toString(double doubleNum) &#123;String str=doubleNum+&quot;&quot;; return str; &#125; public String toString(StringBuffer StrBuffer) &#123;String str=StrBuffer+&quot;&quot;; return str; &#125; public String toString(MyDate myDateNum) &#123;String str=myDateNum.year+&quot; &quot;+myDateNum.month+&quot; &quot;+myDateNum.day+&quot; &quot;+myDateNum.hour+&quot; &quot;+myDateNum.minute+&quot; &quot;+myDateNum.second; return str; &#125;&#125; B、继承LinkNode类创建新类LinkNodeS在其中重写Object中默认的toString()方法（将结点的value转换成对应的字符串），main()中用LinkNodeS类同样创建4个实例，并赋予和上面同样的值（long、double、StringBuffer、MyDate），观察使用新的toString()方法的效果，体会继承与多态。(MyDate的日期toString用标准格式) 123456789101112131415161718192021222324252627public class UseOfLinkNodes &#123; public static void main(String[] args) &#123; StringBuffer strBuffer=new StringBuffer(&quot;aaa&quot;); MyDate myDate=new MyDate(); LinkNode longNum=new LinkNode(594785L); LinkNode doubleNum=new LinkNode(599.5); LinkNode StringBuffer=new LinkNode(strBuffer); LinkNode myDateNum=new LinkNode(myDate); System.out.println(longNum.value.toString()); System.out.println(doubleNum.value.toString()); System.out.println(StringBuffer.value.toString()); System.out.println(myDateNum.value.toString()); System.out.println(); LinkNodes longNum2=new LinkNodes(594785L); LinkNodes doubleNum2=new LinkNodes(599.5); LinkNodes StringBuffer2=new LinkNodes(strBuffer); LinkNodes myDateNum2=new LinkNodes(myDate); String myDateNum2Str=myDateNum2.toString((MyDate)myDateNum2.value); System.out.println(longNum2.toString((long)longNum2.value)); System.out.println(doubleNum2.toString((double)doubleNum2.value)); System.out.println(StringBuffer2.toString((StringBuffer)StringBuffer2.value)); System.out.println(myDateNum2Str);&#125;&#125; 4、：用Animal作为基类，鸟类、昆虫类、爬行类和鱼类作为Animal的子类设计类有来自4个类别（鸟类、昆虫类、爬行类和鱼类）的100个动物聚在一起开会，商议和另一个动物部落打仗事宜，会议要求每个动物都要报告自己所属的动物类别和自己的天赋，以便选拔人才、组织兵力出战。设计：用Animal作为基类，鸟类、昆虫类、爬行类和鱼类各作为Animal的子类设计类层次结构，设计时运用继承、重写并设计多态机制，同时对每个子类至少要添加一个其描述的动物特有的行为和一个特有的属性，以更准确地描述子类对象。使用：用循环随机生成这100个动物装入动物数组，要对每个动物进行编号和随机命名，用循环让每个参会的动物报告自己的类别和天赋。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Animal &#123; public int id; //编号 public StringBuffer name;//名字 public String type; //类别：鸟类、昆虫类、爬行类和鱼类之一 public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is “+id+” and I am just an animal, my type is going to be determined later.&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I don’t know what I am talented at right now.&quot;); &#125; public void showName() &#123; System.out.println(&quot;My name is &quot;+this.name); &#125;&#125; class Fish extends Animal &#123; public Fish(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;fish&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is fish&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at swiming&quot;); &#125; &#125; class Bird extends Animal &#123; public Bird(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;bird&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is bird&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at flying&quot;); &#125; &#125; class Insect extends Animal &#123; public Insect(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;insect&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is insect&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at working&quot;); &#125; &#125; class Reptile extends Animal &#123; public Reptile(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;reptile&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is reptile&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at crawling&quot;); &#125; &#125; 123456789101112131415161718192021222324252627282930313233public class AnimalRandom &#123; public static void main(String[] args) &#123; Animal[] animalArmy = new Animal[100]; for(int i = 0; i&lt;100; i++) &#123; int type = (int)( Math.random()*4 ); StringBuffer name = new StringBuffer(); for(int j = 0; j&lt;4; j++) &#123; int word = (int)( Math.random()*26 ); name.append( (char)(word + &#x27;a&#x27;) ); &#125; switch (type) &#123; case 0: animalArmy[i] = new Bird(i, name); break; case 1: animalArmy[i] = new Fish(i, name); break; case 2: animalArmy[i] = new Insect(i, name); break; case 3: animalArmy[i] = new Reptile(i,name); &#125; animalArmy[i].showName(); animalArmy[i].showType(); animalArmy[i].showTalent(); System.out.println(); &#125;&#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:53:53.095Z","path":"wiki/计算机基础知识/编程语言/Java/编程计算1^1+2^2+3^3+4^4+5^5+……+20^20/","text":"1.用对分法解方程 x^(1&#x2F;2)&#x3D;cos(x) （x&gt;0）a、先在纸上研究好算法b、使用Math.sqrt(), Math.cos(),Math.PI;c、实型数的比较方法（不能用相等，要用差的绝对值很小作为判断）d、大致的结果区间e、怎么结束，常量（到怎样的精度则停止循环计算）（Math.abs()）f、取中值g、例子：-1.3*X+2&#x3D;sinX 123456789101112131415161718ublic static void main(String[] args) &#123; // TODO Auto-generated method stub double minNum=0d,maxNum=1d,xNumber=0.5d,sqrt,cos,absSubstractiveSum=1d; for(;absSubstractiveSum&gt;0.0000001;) &#123;sqrt=Math.sqrt(xNumber); cos=Math.cos(xNumber); absSubstractiveSum=(double)Math.abs(sqrt-cos); if(sqrt-cos&lt;0) &#123;minNum=xNumber; xNumber=(minNum+maxNum)/2;&#125; else &#123;maxNum=xNumber; xNumber=(minNum+maxNum)/2;&#125; &#125; System.out.println(xNumber); &#125;&#125; 2. 用欧几里德辗转相除法求两个正整数的最大公约数 12345678910111213public class Ogimed &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int a=52,b=4; System.out.println(getGCD(a,b)); &#125; static int getGCD(int a,int b) &#123; if(a%b==0) return b; return getGCD(b,a%b); &#125;&#125; 3.利用级数展开式计算cos（x）a、注意循环控制的设计(结束条件)b、反复查找了源程序，没有问题，但运行的结果就是不对，试着从其他方面找原因c、可以和Math.cos()的结果做一个比较d、不用数组。到网上找通项公式；e、结束条件，常量 123456789101112131415161718192021public class CosX &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int x=0; System.out.println(cos(x)); &#125; public static double cos(double x) &#123; double sumOfItem=1; double item=x; double EPSILON=0.0000000000000001; int num=1; while(Math.abs(item)&gt;EPSILON) &#123; item=-item*x*x/((2*num)*(2*num-1)); sumOfItem+=item; num++; &#125; return sumOfItem;&#125;&#125; 4. 编程计算1000以内的质数（输出格式：一行10个，按列右对齐）a、注意设计好“信号变量”，isPrimeb、Switch((Integer.toString(intWorker)).length())c、如何按列右对齐 5. 将任意一个字符串颠倒排列输出a、引用正确的类及其方法b、主要是合理运用String或StringBuffer的方法以及循环控制c、学习使用length()、charAt()等函数d、研究各种可能的情况 1234567891011121314151617181920212223public class primeNumInside1000 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int i,j; int num=0; for(i=1;i&lt;=1000;i++) &#123; for(j=2;j&lt;i;j++) &#123; if(i%j==0) break; &#125; if(i==j) &#123;String str=Integer.toString(j); System.out.printf(&quot;%4s&quot;,str); num++;&#125;; if(num==10) &#123;num=0; System.out.println(); &#125;&#125;&#125; 5.将任意一个字符串颠倒排列输出a、引用正确的类及其方法b、主要是合理运用String或StringBuffer的方法以及循环控制c、学习使用length()、charAt()等函数d、研究各种可能的情况 12345678910111213public class reverseString &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub StringBuffer str=new StringBuffer(&quot;anihC yadhtriB yppaH&quot;); StringBuffer str2=new StringBuffer(&quot;&quot;); int length=str.length(); for(int number=length;number&gt;0;number--) &#123; char temp=str.charAt(number-1); str2.append(temp); &#125; System.out.println(str2);&#125;&#125; 6. 符号三角形（输入－－＋－＋＋－＋）(第一行从第10列开始，整个三角形右对齐)a、想办法控制好输出的格式b、什么是符号三角形c、如何控制起始位置d、字符的比较，是否可以考虑用异或 1234567891011121314151617181920212223public class symbolicTriangle &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub char[] line=new char[]&#123;&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27; &#x27;,&#x27;-&#x27;,&#x27;-&#x27;,&#x27;+&#x27;,&#x27;-&#x27;,&#x27;+&#x27;,&#x27;+&#x27;,&#x27;-&#x27;,&#x27;+&#x27;&#125;; System.out.println(line); for(int i=9;line[15]!=&#x27; &#x27;;i++) &#123; for(int j=16;j!=i;j--) &#123;int flag = line[j]^line[j-1]; if(flag==0) &#123;line[j]=&#x27;+&#x27;;&#125; else &#123;line[j]=&#x27;-&#x27;;&#125; &#125; line[i]=&#x27; &#x27;; System.out.println(line); &#125; &#125;&#125; 7、编程计算1^1+2^2+3^3+4^4+5^5+……+20^20b、注意结果的大小，体会数据的范围； c、需要用到数组； d、———————————– e、不能在运算过程中使用实型数 f、使用数组，一个数组元素装一位 g、要使用辅助方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PowersumForm1to20 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub sumOf20Power20(); &#125; public static void sumOf20Power20() &#123; int[] sum=new int[50]; int[] temp; sum[0]=5; for(int i=3;i&lt;=20;i++) &#123; temp=nPowerN(i); addToSum(temp,sum); display(sum); &#125; &#125; public static void carry(int[] anArray) &#123; for(int i=0;i&lt;anArray.length-1;i++) &#123; anArray[i+1]+=anArray[i]/10; anArray[i]%=10; &#125; &#125; public static void addToSum(int[] anArray,int[] sumArray) &#123; for(int i=0;i&lt;sumArray.length;i++) &#123; sumArray[i]+=anArray[i]; &#125; carry(sumArray); &#125; public static int[] nPowerN(int aNumber) &#123; int[] tempArray=new int[50]; tempArray[0]=aNumber; carry(tempArray); for(int i=0;i&lt;aNumber-1;i++) &#123; for(int j=0;j&lt;tempArray.length;j++) tempArray[j]*=aNumber; carry(tempArray); &#125; return tempArray; &#125; public static void display(int[] anArray) &#123; boolean isAllPrefixZero=true; for(int i=anArray.length-1;i&gt;=0;i--) &#123; if(anArray[i]!=0) isAllPrefixZero=false; if(!isAllPrefixZero) System.out.print(anArray[i]); &#125; System.out.println(); &#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:53:42.831Z","path":"wiki/计算机基础知识/编程语言/Java/java模拟堆栈，时间类MyDate，字符串链表节点类，类BankCustomer/","text":"1、将你在实验3中设计的模拟堆栈程序，封装成一个类（注意访问控制的运用、getter和setter的运用、构造方法的设计等），并用这个堆栈类重写中缀表达式转换成后缀表达式程序。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class StackImiate &#123; private int maxSize; private char[] a; private int top; StackImiate(int maxSize) &#123; this.maxSize=maxSize; a=new char[maxSize]; top=-1; &#125; public void push(char str) &#123; a[++top]=str; &#125; public char pop() &#123; return a[top--]; &#125; public boolean isEmpty() &#123; return(top==-1); &#125; public boolean isFull() &#123; return(top==maxSize); &#125; public int length() &#123;return top+1;&#125; public char peek() &#123; return a[top]; &#125; public char peekN(int n) &#123; //System.out.println(a[n]); return a[n]; &#125; public void displayStack(String s) &#123; System.out.print(s); System.out.print(&quot; Stack (bottom--&gt;top): &quot;); for(int j=0;j&lt;maxSize;j++) &#123; System.out.print(peekN(j)+&quot; &quot;); &#125; System.out.println(); &#125;&#125;public class InToPost &#123; public static void main(String[] args) &#123; String strResult=new String(); String Input=&quot;a+b*c+(d*e+f)*g&quot;; System.out.println(&quot;中缀表达式&quot;+Input); strResult=strResult+doTrans(Input); System.out.println(); System.out.println(&quot;后缀表达式&quot;+strResult); &#125; public static StringBuffer doTrans(String Input) &#123; StackImiate str=new StackImiate(50); StringBuffer strResultTemp=new StringBuffer(); for (int i = 0; i &lt;Input.length(); i++) &#123; char ch = Input.charAt(i); str.displayStack(&quot;Get &quot; + ch + &quot; &quot;); switch (ch) &#123; case &#x27;+&#x27;: case &#x27;-&#x27;: gotOper(ch, 1,str,strResultTemp); break; case &#x27;*&#x27;: case &#x27;/&#x27;: case &#x27;%&#x27;: gotOper(ch, 2,str,strResultTemp); break; case &#x27;(&#x27;: str.push(ch); break; case &#x27;)&#x27;: gotParen(ch,str,strResultTemp); break; default: strResultTemp =strResultTemp.append(ch); break; &#125; &#125; while (!str.isEmpty()) &#123; str.displayStack(&quot;out &quot;); strResultTemp = strResultTemp.append(str.pop()); &#125; str.displayStack(&quot;End &quot;); return strResultTemp; &#125; public static void gotParen(char ch,StackImiate str,StringBuffer strResultTemp) &#123; // TODO Auto-generated method stub while (!str.isEmpty()) &#123; char chx = (char) str.pop(); if (chx == &#x27;(&#x27;) &#123; break; &#125; else &#123; strResultTemp =strResultTemp.append(chx); &#125; &#125; &#125; private static void gotOper(char ch, int i,StackImiate str,StringBuffer strResultTemp) &#123; // TODO Auto-generated method stub while (!str.isEmpty()) &#123; char opTop = (char) str.pop(); if (opTop == &#x27;(&#x27;) &#123; str.push(&#x27;(&#x27;); break; &#125; else &#123; int k; if (opTop == &#x27;+&#x27; || opTop == &#x27;-&#x27;) &#123; k = 1; &#125; else &#123; k = 2; &#125; if (k &lt; i) &#123; str.push(opTop); break; &#125; else &#123; strResultTemp = strResultTemp.append(opTop); &#125; &#125; &#125; str.push(ch); &#125; &#125; 2、设计一个时间类MyDate：（日期均大于1900年）a、其中包括年、月、日、时、分、秒。其他成员变量可根据需要增设；b、可以直接获得时间的年、月、日、小时、分钟、秒数；(public修饰)c、计算日期的dayOfWeek（星期几）；d、输入任意一个月份，将此月的日历输出（按星期格式）；e、输入任意年份，将此年的年历输出；f、输出时间，要求三种格式： yyyy年MM月dd日hh小时mm分ss秒；（Chinese）yyyy-MM-dd hh:mm:ss（European）yyyyMMddhhmmss（compact）g、设计三个构造方法：1、参数只有年月日的构造方法，小时分钟秒设为0；2、完全参数的构造方法；3、如果使用无参数的构造方法则初始化为系统时间。h、不要直接使用Java提供的Date类，那样就达不到练习的效果了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183import java.text.SimpleDateFormat;public class MyDate &#123; public int year,month,day,hour,minute,second; String strDate; public MyDate() &#123;SimpleDateFormat myDateFormat =new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;); java.util.Date date0=new java.util.Date(); strDate=myDateFormat.format(date0); year = Integer.parseInt( strDate.substring(0,4)); month = Integer.parseInt( strDate.substring(4,6)); day = Integer.parseInt( strDate.substring(6,8)); hour = Integer.parseInt( strDate.substring(8,10)); minute = Integer.parseInt( strDate.substring(10,12)); second = Integer.parseInt( strDate.substring(12,14)); &#125; public MyDate(int year0,int month0,int day0) &#123;year=year0; month=month0; day=day0; hour=0; minute=0; second=0;&#125; public MyDate(int year0,int month0,int day0,int hour0,int minite0,int second0) &#123;year=year0; month=month0; day=day0; hour=hour0; minute=minite0; second=second0;&#125; public int getYear() &#123;return year;&#125; public int getMonth() &#123;return month;&#125; public String getDate() &#123;return day+&quot;/&quot;+month+&quot;/&quot;+year;&#125; public int getHour() &#123;return hour;&#125; public int getMinite() &#123;return minute;&#125; public int getSecond() &#123;return second;&#125; public void displayChinese() &#123;System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;+hour+&quot;时&quot;+minute+&quot;分&quot;+second+&quot;秒&quot;);&#125; public void displayEU() &#123;System.out.println(year+&quot;-&quot;+month+&quot;-&quot;+day+&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second+&quot; &quot;);&#125; public void displayCompact() &#123;System.out.println(year+&quot; &quot;+month+&quot; &quot;+day+&quot; &quot;+hour+&quot; &quot;+minute+&quot; &quot;+second);&#125; public void displayMonth(int year,int month) //输出一月的日历 &#123; int sum=0; for(int i=1900;i&lt;year;i++) &#123; if(i%4==0&amp;&amp;i%100!=0||i%400==0) &#123;sum+=366;&#125; else &#123;sum+=365;&#125; &#125; for(int i=1;i&lt;month;i++) &#123; if(i==2) &#123;if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123;sum+=29;&#125; else &#123;sum+=28;&#125; &#125; else &#123; if(i==4||i==6||i==9||i==11) &#123;sum+=30;&#125; else &#123;sum+=31;&#125; &#125; &#125; sum+=1; int wekday=sum%7; System.out.println(&quot;日\\t一\\t二\\t三\\t四\\t五\\t六&quot;); for(int i=1;i&lt;=wekday;i++) &#123;System.out.print(&quot;\\t&quot;);&#125; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123;if(month!=2) &#123;if(month==4||month==6||month==9||month==11) &#123;for(int i=1;i&lt;=30;i++) &#123;if(sum%7==6) &#123;System.out.print(i+&quot;\\n&quot;);&#125; else&#123; System.out.print(i+&quot;\\t&quot;);&#125; sum++;&#125;&#125; else &#123;for(int i=1;i&lt;=31;i++) &#123;if(sum%7==6) &#123;System.out.print(i+&quot;\\n&quot;);&#125; else &#123;System.out.print(i+&quot;\\t&quot;);&#125; sum++;&#125; &#125;&#125; else &#123;for(int i=1;i&lt;=29;i++) &#123;if(sum%7==6) &#123;System.out.print(i+&quot;\\n&quot;);&#125; else &#123;System.out.print(i+&quot;\\t&quot;);&#125; sum++; &#125;&#125;&#125; else &#123;if(month!=2) &#123;if(month==4||month==6||month==9||month==11) &#123;for(int i=1;i&lt;=30;i++) &#123;if(sum%7==6) &#123;System.out.print(i+&quot;\\n&quot;);&#125; else&#123; System.out.print(i+&quot;\\t&quot;);&#125; sum++;&#125;&#125; else &#123;for(int i=1;i&lt;=31;i++) &#123;if(sum%7==6) &#123;System.out.print(i+&quot;\\n&quot;);&#125; else &#123;System.out.print(i+&quot;\\t&quot;);&#125; sum++;&#125; &#125;&#125; else &#123;for(int i=1;i&lt;=28;i++) &#123;if(sum%7==6) &#123;System.out.print(i+&quot;\\n&quot;);&#125; else &#123;System.out.print(i+&quot;\\t&quot;);&#125; sum++; &#125;&#125;&#125;&#125; public void displayYear(int year) //输出一年的日历 &#123;for(int i=1;i&lt;13;i++) &#123;System.out.println(&quot; 第&quot;+i+&quot;月&quot;); displayMonth(year,i); System.out.println(); &#125; &#125; public String dayOfWeek(int year,int month,int day) //判断某天为一周的星期几 &#123;int sum=0; for(int i=1900;i&lt;year;i++) &#123; if(i%4==0&amp;&amp;i%100!=0||i%400==0) &#123;sum+=366;&#125; else &#123;sum+=365;&#125; &#125; for(int i=1;i&lt;month;i++) &#123; if(i==2) &#123; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123;sum+=29;&#125; else &#123;sum+=28;&#125; &#125; else &#123; if(i==4||i==6||i==9||i==11) &#123;sum+=30;&#125; else &#123;sum+=31;&#125; &#125; &#125; sum+=1; int wekFirstday=sum%7; int dayOfWeek=wekFirstday; int i=0; while(i&lt;day) &#123;i++;dayOfWeek++;&#125; if(dayOfWeek!=7) &#123;return &quot;第&quot;+year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日为星期&quot;+dayOfWeek;&#125; else &#123;return &quot;第&quot;+year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日为星期日&quot;;&#125; &#125;&#125;public class UseMyDate &#123; public static void main(String[] args) &#123; MyDate myDate=new MyDate(); myDate.displayChinese(); myDate.displayEU(); myDate.displayCompact(); MyDate myDate1=new MyDate(2008,8,8); myDate1.displayChinese(); myDate1.displayEU(); myDate1.displayCompact(); MyDate myDate2=new MyDate(2008,8,8,20,0,0); myDate2.displayChinese(); myDate2.displayEU(); myDate2.displayCompact(); myDate.displayMonth(2014,4); System.out.println(); myDate.displayYear(2011); &#125;&#125; 3、设计一个字符串链表节点类：a)其中包括两个成员变量：Value（String类型）和下一个节点nextNode，方法有：setValue()，getValue()和display();b)用此类生成一个循环链表来解决斗地主发牌的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class ChainNode &#123; public String Value; public ChainNode nextNode; public String suit; public ChainNode() &#123;Value=&quot;&quot;; nextNode=null; suit=&quot;&quot;;&#125; public ChainNode(String Value,ChainNode nextNode, String suit) &#123;this.Value=Value; this.nextNode=nextNode; this.suit=suit;&#125; public ChainNode(String Value, String suit) &#123;this.Value=Value; this.suit=suit;&#125; public void setValue(String suit,String value) &#123;this.Value=value; this.suit=suit;&#125; public String getValue() &#123;return Value;&#125; public void display() &#123;System.out.print(suit+Value+&quot; &quot;);&#125;&#125;public class DealCards &#123; public static void main(String[] args) &#123; String suits[]=new String[] &#123;&quot;黑桃&quot;,&quot;梅花&quot;,&quot;方块&quot;,&quot;红桃&quot;&#125;; String Value[]=new String[] &#123;&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&#125;; ChainNode[] cardsOfPlayer = new ChainNode[3]; for(int i = 0; i&lt;3; i++) &#123; cardsOfPlayer[i] = new ChainNode(); &#125; ChainNode firstCard=new ChainNode(&quot;&quot;,&quot;大王&quot;); firstCard.nextNode=new ChainNode(&quot;&quot;,&quot;小王&quot;); ChainNode lastCard=firstCard.nextNode; for(int i=0;i&lt;4;i++) &#123; for(int j=0;j&lt;13;j++) &#123;lastCard.nextNode= new ChainNode(Value[j],suits[i]); lastCard=lastCard.nextNode; &#125; &#125; lastCard.nextNode=firstCard; int random=0; int players=0; ChainNode choose=firstCard; ChainNode before=lastCard; for(int num=54;num&gt;3;num--) &#123; random=(int)(Math.random()*num); for(;random&gt;1;random--) &#123;before=choose; choose=choose.nextNode;&#125; before.nextNode=choose.nextNode; choose.nextNode=cardsOfPlayer[players].nextNode; cardsOfPlayer[players].nextNode=choose; choose=before.nextNode; players++; players=players%3; &#125; for(int i = 0; i&lt;3; i++) &#123; System.out.println(&quot;\\n第&quot;+(i+1)+&quot;个玩家的牌是&quot;); ChainNode pri = cardsOfPlayer[i].nextNode; while(pri != null) &#123; pri.display(); pri = pri.nextNode; &#125; &#125; System.out.println(&quot;\\nThe Last Three Cards：&quot;); for(int i = 0; i&lt;3; i++) &#123; choose.display(); choose = choose.nextNode; &#125; System.out.println(); System.out.println(); &#125;&#125; 4、设计一个用于管理银行客户的类BankCustomer：仅描述客户的几个重要方面：帐号、身份证号、姓名、联系方式、密码、账户余额。所有的成员变量均用private访问控制，因此每一个成员变量就要有相应的存取器（getter和setter，即获取和设置其值的相应的成员方法。需要setter还是getter，还是两者都要，视情况而定） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import java.text.SimpleDateFormat;public class BankCustomer &#123; private String ID; private String peopleID; private String name; private String phone; private String password; private double balance; public BankCustomer(String peopleID,String name,String phone) &#123;String strDate; SimpleDateFormat myDateFormat =new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;); java.util.Date date0=new java.util.Date(); strDate=myDateFormat.format(date0); ID=strDate; this.peopleID=peopleID; this.name=name; this.phone=phone; this.password=&quot;666666&quot;; this.balance=0; &#125; public double getbalance() &#123;return balance;&#125; public String getID() &#123;return ID;&#125; public String getPhone() &#123;return phone;&#125; public String getPelpleID() &#123;return peopleID;&#125; public String getName() &#123;return name;&#125; public void setName(String password,String name) &#123;if(ifPassword(password)) &#123;this.name=name; System.out.println(&quot;您的姓名已设置&quot;);&#125; else &#123;System.out.println(&quot;密码错误&quot;);&#125; &#125; public void setPeopleID(String password,String peopleID) &#123;if(ifPassword(password)) &#123;this.peopleID=peopleID; System.out.println(&quot;您的身份证号已设置&quot;);&#125; else &#123;System.out.println(&quot;密码错误&quot;);&#125;&#125; public void setPhone(String password,String phone) &#123;if(ifPassword(password)) &#123;this.phone=phone; System.out.println(&quot;您的电话已设置&quot;);&#125; else &#123;System.out.println(&quot;密码错误&quot;);&#125; &#125; public boolean ifPassword(String password)//判断密码是否正确 &#123;if(this.password==password) return true; else return false; &#125; public void deposit(String password,double money) &#123; if(ifPassword(password)) &#123;balance+=money; System.out.println(&quot;您的账户已充值&quot;+balance+&quot;元，您的余额为&quot;+balance);&#125; else &#123;System.out.println(&quot;密码错误&quot;);&#125; &#125; public void withdraw(String password,double money) &#123;if(ifPassword(password)) &#123;if(balance&gt;money) &#123;balance-=money; System.out.println(&quot;您的账户已取出&quot;+balance+&quot;元，您的余额为&quot;+balance);&#125; else &#123;System.out.println(&quot;您的余额为不足&quot;);&#125;&#125; else &#123;System.out.println(&quot;密码错误&quot;);&#125; &#125; public void displayCustomer(String password) &#123;if(ifPassword(password)) &#123;System.out.println(&quot; 您的身份证为&quot;+peopleID); System.out.println(&quot; 您的余额为&quot;+balance); System.out.println(&quot; 您的账号为&quot;+ID); System.out.println(&quot; 您的姓名为&quot;+name); System.out.println(&quot; 您的电话为&quot;+phone); &#125; else &#123;System.out.println(&quot;密码错误&quot;);&#125; &#125; public void changePassWord(String oldPassword,String newPassword1,String newPassword2) &#123;if(ifPassword(oldPassword)) &#123;if( newPassword1== newPassword2) &#123;if(newPassword1.length()&gt;5) &#123;this.password=newPassword1; System.out.println(&quot;已修改密码&quot;);&#125; else &#123;System.out.println(&quot;你输入的密码不到6位，请重新输入&quot;);&#125;&#125; else &#123;System.out.println(&quot;你输入的两次密码不一样，请重新输入&quot;);&#125; &#125; else &#123;System.out.println(&quot;密码错误&quot;);&#125; &#125;&#125;package text4;public class Customer &#123; public static void main(String[] args) &#123; BankCustomer myCard=new BankCustomer(&quot;430725000000000000&quot;,&quot;罗琪源&quot;,&quot;000000000000&quot;); myCard.setName(&quot;666666&quot;,&quot;&quot;); myCard.setName(&quot;567891&quot;,&quot;&quot;); myCard.setPeopleID(&quot;666666&quot;,&quot;430725200112190032&quot;); myCard.setPeopleID(&quot;567891&quot;,&quot;430725200112190032&quot;); myCard.setPhone(&quot;666666&quot;,&quot;18569126258&quot;); myCard.setPhone(&quot;567891&quot;,&quot;18569126258&quot;); myCard.getbalance(); myCard.getID(); myCard.getPhone(); myCard.getPelpleID(); myCard.getName(); myCard.deposit(&quot;666666&quot;, 5000); myCard.deposit(&quot;567891&quot;, 5000);//deposit money myCard.withdraw(&quot;666666&quot;,10000); myCard.withdraw(&quot;567891&quot;,10000); myCard.withdraw(&quot;567891&quot;,5000);//withdraw money myCard.displayCustomer(&quot;666666&quot;); myCard.displayCustomer(&quot;567891&quot;);//displayCustomer myCard.changePassWord(&quot;666666&quot;, &quot;567891&quot;, &quot;567891&quot;); myCard.changePassWord(&quot;888888&quot;, &quot;567891&quot;, &quot;567891&quot;); myCard.changePassWord(&quot;567891&quot;, &quot;567891&quot;, &quot;666666&quot;);//change password situations myCard.deposit(&quot;666666&quot;, 5000); myCard.deposit(&quot;567891&quot;, 5000);//when change password deposit money myCard.withdraw(&quot;666666&quot;,10000); myCard.withdraw(&quot;567891&quot;,10000); myCard.withdraw(&quot;567891&quot;,5000);//when change password withdraw money myCard.displayCustomer(&quot;666666&quot;); myCard.displayCustomer(&quot;567891&quot;);//when change password displayCustomer myCard.getbalance(); myCard.getID(); myCard.getPhone(); myCard.getPelpleID(); myCard.getName(); myCard.setName(&quot;666666&quot;,&quot;&quot;); myCard.setName(&quot;567891&quot;,&quot;&quot;); myCard.setPeopleID(&quot;666666&quot;,&quot;430725200112190032&quot;); myCard.setPeopleID(&quot;567891&quot;,&quot;430725200112190032&quot;); myCard.setPhone(&quot;666666&quot;,&quot;18569126258&quot;); myCard.setPhone(&quot;567891&quot;,&quot;18569126258&quot;); &#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:53:26.722Z","path":"wiki/计算机基础知识/编程语言/Java/分别用抽象类和接口实现四个动物类（鱼类、鸟类、爬行类、昆虫类）的类别和天赋/","text":"1.将实验五第四题中的四个动物类（鱼类、鸟类、爬行类、昆虫类）的报告类别和天赋，分别用抽象类和接口来完成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241abstract class AbstractClass &#123; public int id; //编号 public StringBuffer name;//名字 public String type; //类别：鸟类、昆虫类、爬行类和鱼类之一 abstract public void showType();//在console上秀自己的类别 abstract public void showTalent();//在console上秀自己的天赋特长 public void showName() &#123; System.out.println(&quot;My name is &quot;+this.name+&quot;, i am from AbstractClass(抽象类)&quot;); &#125;&#125;class Fish extends AbstractClass&#123; public Fish(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;fish&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is fish&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at swiming&quot;); &#125; &#125;class Bird extends AbstractClass&#123; public Bird(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;bird&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is bird&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at flying&quot;); &#125;&#125; class Insect extends AbstractClass&#123; public Insect(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;insect&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is insect&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at working&quot;); &#125; &#125;class Reptile extends AbstractClass&#123; public Reptile(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;reptile&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is reptile&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at crawling&quot;); &#125;&#125; interface Animal2&#123;public void showType();public void showTalent();public void showName();&#125; class Fish2 implements Animal2 &#123; public int id; //编号 public StringBuffer name;//名字 public String type; //类别：鸟类、昆虫类、爬行类和鱼类之一 public Fish2(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;fish&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is fish&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at swiming&quot;); &#125; public void showName() &#123; System.out.println(&quot;My name is &quot;+this.name+&quot;, i am from Interface(接口)&quot;); &#125; &#125; class Bird2 implements Animal2 &#123; public int id; //编号 public StringBuffer name;//名字 public String type; //类别：鸟类、昆虫类、爬行类和鱼类之一 public Bird2(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;fish&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is bird&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at flying&quot;); &#125; public void showName() &#123; System.out.println(&quot;My name is &quot;+this.name+&quot;, i am from Interface(接口)&quot;); &#125; &#125; class Insect2 implements Animal2 &#123; public int id; //编号 public StringBuffer name;//名字 public String type; //类别：鸟类、昆虫类、爬行类和鱼类之一 public Insect2(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;fish&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is insect&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at working&quot;); &#125; public void showName() &#123; System.out.println(&quot;My name is &quot;+this.name+&quot;, i am from Interface(接口)&quot;); &#125; &#125; class Reptile2 implements Animal2 &#123; public int id; //编号 public StringBuffer name;//名字 public String type; //类别：鸟类、昆虫类、爬行类和鱼类之一 public Reptile2(int id,StringBuffer name) &#123;this.id=id; this.name=name; this.type=&quot;fish&quot;; &#125; public void showType()//在console上秀自己的类别 &#123; System.out.println(&quot;My ID is &quot;+id+&quot; and I am just an animal, my type is reptile&quot;); &#125; public void showTalent()//在console上秀自己的天赋特长 &#123; System.out.println(&quot;I am talented at crawling&quot;); &#125; public void showName() &#123; System.out.println(&quot;My name is &quot;+this.name+&quot;, i am from Interface(接口)&quot;); &#125; &#125;public class UseOfAnimal &#123; public static void main(String[] args) &#123; AbstractClass[] animalArmy = new AbstractClass[100]; for(int i = 0; i&lt;100; i++) &#123; int type = (int)( Math.random()*4 ); StringBuffer name = new StringBuffer(); for(int j = 0; j&lt;4; j++) &#123; int word = (int)( Math.random()*26 ); name.append((char)(word + &#x27;a&#x27;) ); &#125; switch (type) &#123; case 0: animalArmy[i] = new Bird(i, name); break; case 1: animalArmy[i] = new Fish(i, name); break; case 2: animalArmy[i] = new Insect(i, name); break; case 3: animalArmy[i] = new Reptile(i,name); &#125; animalArmy[i].showName(); animalArmy[i].showType(); animalArmy[i].showTalent(); System.out.println(); &#125; Animal2[] animalArmy2 = new Animal2[100]; for(int i = 0; i&lt;100; i++) &#123; int type = (int)( Math.random()*4 ); StringBuffer name = new StringBuffer(); for(int j = 0; j&lt;4; j++) &#123; int word = (int)( Math.random()*26 ); name.append( (char)(word + &#x27;a&#x27;) ); &#125; switch (type) &#123; case 0: animalArmy2[i] = new Bird2(i, name); break; case 1: animalArmy2[i] = new Fish2(i, name); break; case 2: animalArmy2[i] = new Insect2(i, name); break; case 3: animalArmy2[i] = new Reptile2(i,name); &#125; animalArmy2[i].showName(); animalArmy2[i].showType(); animalArmy2[i].showTalent(); System.out.println(); &#125;&#125;&#125;","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"}]},{"title":"","date":"2023-02-15T01:52:49.664Z","path":"wiki/软件项目/小型项目/C++状态模式，建造者模式，观察者模式，单例模式，备忘录模式实现超市购物/","text":"一、设计内容及要求 .该课程设计的基本目标：1.掌握系统分析与设计的基本概念和方法。2.掌握23种设计模式的基本概念。3.掌握设计模式的常用方法和C++语言的编程实现。4.了解在软件开发过程中所面临的问题的最佳解决方案，通过一种简单快捷的方式来学习软件设计。 该课程设计要求开发一个小型的应用程序，其内容来源于：1.对于该课程的相应的实验报告的内容的扩展。2.本科学习阶段开发过的系统的重要部分的改造或代码重构。3.设计者自己全新构造的小系统。 该课程设计的主要要求：1.要求设计的小系统包含至少3个该课程中提及的设计模式。2.设计的小系统包含简单的应用界面。系统开发的程序设计语言不限。 二、系统的主要目标与功能在本次设计中，考虑到目前超市都流行在线购物，于是我设计了一个超市在线网上购物的系统，这个系统的主要目标是帮助人们在家里购买自己需要的套餐，充值账户，同时该系统能查看自己的历史金额变动记录，也能够撤销前一次购买或充值，这样能够帮助没有时间的人们快速购物，也能够减少疫情期间出门购物的可能带来的危害。本超市目前功能如下 查看超市套餐 购买超市套餐” 给账户充值 查看历史余额记录 撤回上次存款或消费 退出本超市在线购物系统 三、系统中使用的设计模式（详细描述场景、解决的问题、模式的效果及意义）•1.状态模式：状态模式在购物时提供用户信息和余额的信息，允许购买后余额少于0，但当余额少于0后不能购买。在进入程序时便初始化账户，通过这个账户记录余额信息，同时考虑到余额不足时不能购物，考虑到方便，设计余额不足购买时允许赊欠，但当前余额小于0时不能购物，这样是考虑到实际，余额小于0时是不能购买的，因此使用状态模式。 •2.建造者模式：建筑者模式用于构建不同的购买套餐，帮助快速购买，并且使客户便于查看各个套餐的内容与价格便于购买。 •3.观察者模式：在进入系统时会有弹窗信息提醒客户套餐的信息，并提醒客户注意财产安全，这样是考虑到现实中大部分应用都会在初次使用时提醒使用者。 •4.单例模式：只允许创建一个超市类，且该超市类是建造者模式的指挥者，指挥套餐的建立。 •5.备忘录模式：记录在系统中的余额变动历史记录，并可以撤销上一次余额变动的操作，在现实中大部分购物应用都可以查看历史记录与撤销，因此利用备忘录模式实现该操作，便于观察余额变化。 项目源码：https://github.com/1105358600/DesignPattern","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:52:39.327Z","path":"wiki/软件项目/小型项目/芯片+步进电机档位控制实验/","text":"1、系统功能目的：学习步进电机的控制。使用设备：步进电机、两位共阴数码管、按键功能：驱动步进电机以不同转速（4档）转动，并将当前档位用数码管显示(1)按键 KEY1 作为启动和停止的切换按键；(2)按键 KEY2 加速键。(3)最开始按下 KEY1 ，系统以默认的最低档位（1档最低，4档最高）启动电机转动；(4)每按一次 KEY2 ，电机转速提升一档。提到最高4档后，自动降到最低的1档。(5)数码管显示当前的档位。(6)电机处于停止状态时，数码管显示0。 2、硬件结构本课程实验主控芯片选择的是STM32F103ZET6作为MCU，该芯片是STM32F103里面配置非常强大的了,它拥有的资源包括：64KB SRAM、 512KB FLASH、2个基本定时器、4个通用定时器、2个高级定时器、2个DMA控制器（共12个通道）、3个SPI、2个IIC、5个串口、1个USB、1个CAN、3个12位ADC、1个12位DAC、1个SDIO接口、1个FSMC接口以及112个通用IO口。该芯片的配置十分强悍，并且还带外部总线（FSMC）可以用来外扩SRAM和连接LCD等，通过FSMC（可变静态存储控制器）驱动LCD，可以显著提高LCD的刷屏速度。 3、主要外设本项目用到的主要外设为步进电机与两位共阴数码管，其中步进电机由ULN2003芯片控制。ULN2003是高耐压、大电流达林顿阵列，由七个硅NPN达林顿管组成。ULN2003的每一对达林顿都串联一个2.7K的基极电阻,在5V的工作电压下它能与TTL和CMOS电路直接相连，可以直接处理原先需要标准逻辑缓冲器来处理的数据。ULN2003工作电压高，工作电流大，灌电流可达500mA，并且能够在关态时承受50V的电压，输出还可以在高负载电流并行运行。步进电机的驱动采用1-2相励磁法：1相和2相轮流交替导通，精度较高，且运转平滑。每送一个励磁信转动二分之一标称角度。有称为半步驱动。4相电机中，1、2种方式称4相4拍，3种称4相8拍。1-2相励磁法如下图所示，即采用A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA的方式陆续为线圈通电。 共阴数码管是指八段数码管的八段发光二极管的阴极（负极）都连在一起，而阳极对应的各段分别控制。 4、设计思路4.1硬件设计原理IN1(连接在PF0),IN2(连接在PF1),IN3(连接在PF2),IN4(连接在PF3)驱动板电源负极连接开发板GND，正极连接开发板5v。连接如下图所示（连线紧密，请根据杜邦线颜色来判断） 数码管的连接如下图所示。1接PD3，2接PC8,3接PG13,4接PG7,5接PG11,6接PD6,7接PA8,8接PC7,9接PC6,10接PC9。 模块本身的连接方式如下图所示。 4.2软件设计流程实验代码 首先步进电机的工作原理实际上是电磁铁的作用原理。是将电脉冲信号转变为角位移或线位移的开环控制步进电机元件，通过控制施加在电机线圈上的电脉冲顺序、频率和数量，可以实现对步进电机的转向、速度和旋转角度的控制，配合以直线运动执行机构或齿轮箱装置，更可以实现更加复杂、精密的线性运动控制要求。 共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极的数码管，共阴数码管在应用时应将公共极COM接到地线GND上，当某一字段发光二极管的阳极为高电平时，相应字段就点亮，当某一字段的阳极为低电平时，相应字段就不亮。 在整体流程上，通过芯片上的按键控制步进电机的转速与数码管的显示，按键 KEY1 作为启动和停止的切换按键，按键 KEY2 用来增大步进电机工作档位，故在软件设计时，首先要根据这些硬件设施设置对应的模块，包括对应的按键模块key.h与key.c用来读取是否进行按键操作，还有数码管对应的模块led.h与led.c来处理按键后的数码管，与最后的步进电机的模块motor.h与motor.c来处理步进电机的转动速度。 在key模块中，主要靠KEY_Init()与KEY_Scan（）函数实现控制， 其中KEY_Scan（）用来进行按键处理，若检测到按键KEY1或KEY2，则赋值KEY0_PRES与KEY1_PRES。 在led模块中，使用LED_Init函数，通过GPIO_Initure()与HAL_GPIO_WritePin()对控制数码管各部分亮灭的每个引脚进行初始化。 在motor.c模块中，通过Motor_Init（）函数对控制A、B、C、D四个线圈的PF0、PF1、PF2、PF3进行初始化。 在main.c模块中，采用1-2相励磁法驱动步进电机，1相和2相交替导通。在本系统中分别由PF0、PF1、PF2和PF3分别来控制线圈A、B、C、D的通电，因此采用如下方法通过对四个引脚的状态的控制，分别按A→AB→B→BC→C→CD→D→DA的顺序对线圈进行充放电从而产生电流驱动步进电机。通过HAL_Delay（）进行对电机转机转速的控制，针对不同档位采用大小不同的参数speed，档位越低speed值越大，从而在每一轮次对线圈进行充放电的过程中延迟更长的时间。通过open和level两个参数来控制步进电机的是否工作与其工作档位。当按下KEY1键时，KEY0_PRES响应，此时先判断open的值，若open为1则置0；若open为0则置1且level默认为1。当按下KEY2键时，KEY1_PRES响应，此时先判断level的值，再使其加一，当level为4时将其置为1，再通过HAL_GPIO_WritePin()函数控制引脚从而控制数码管各部分的亮灭，使得数码管能够显示对应档位的数字。 5、软件开发环境5.1软件开发环境安装和配置开发工具为RT-Thread Studio。访问官网https://www.rt-thread.org/page/studio.html，在官网下载最新的 RT-Thread Studio 软件安装包。使用MCUISP工具配合开发板上的下载电路可实现串口下载，此外还需下载CH340驱动。5.2工程文件的目录结构和文件本工程文件共分为4个模块，包括对应的按键模块key.h与key.c用来读取是否进行按键操作，还有数码管对应的模块led.h与led.c来处理按键后的数码管，与最后的步进电机的模块motor.h与motor.c来处理步进电机的转动速度，然后还有main.c文件，以进入主函数。 首先打开RT-Thread Studio，导入我们建好的裸板模板工程 Template，之后将工程文件中的.h头文件与.cpp文件复制，粘贴到创建的工程下的applications文件夹内，点击按下图进行配置，使编译生成.hex 文件。 然后点击构建按钮完成编译构建，之后打开MCUISP下载到电路板上，在电路板上进行测试。 6、运行和测试项目总体的接线情况如下： 上电后，首先数码管显示为0，步进电机尚未工作。 首先按下KEY1按键，此时系统以默认的最低档位1档开始工作，数码管数字显示为1，步进电机开始工作，旋转速度为1档，较慢。 再按下KEY2按键，此时数码管数字显示为2，步进电机旋转速度提升至2档。 此时，连续两次按下KEY2按键，此时数码管数字显示先升到3再升到4，步进电机旋转速度提升至4档，为最高档。 再次按下KEY2按键后，数码管数字显示变为1，步进电机旋转速度降至1档。 最后按下KEY1按键，数码管数字显示变为0，步进电机停止工作。","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:52:24.879Z","path":"wiki/软件项目/小型项目/C++重载实现m_n_k三维矩阵，且矩阵元素为复数/","text":"1.实验要求 设计实现三维（3D）矩阵A[i] [j] [k]，支持矩阵运算符+，[]，&#x3D;等运算符重载，并完成结果展示 矩阵中元素为复数类型 2.代码展示1.complex类1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; using namespace std; class Complex &#123; public: Complex() &#123; real=0; imag=0; &#125; Complex(double r,double i) &#123; real=r; imag=i; &#125; friend Complex operator+(Complex &amp;c1, Complex &amp;c2) &#123; Complex c; c.real=c1.real+c2.real; c.imag=c1.imag+c2.imag; return c; &#125; friend Complex operator-(Complex &amp;c1, Complex &amp;c2) &#123; Complex c; c.real=c1.real-c2.real; c.imag=c1.imag-c2.imag; return c; &#125; /*Complex &amp;Complex::operator=(const Complex &amp;c1) &#123; Complex* c; c-&gt;real=c1.real; c-&gt;imag=c1.imag; return c; &#125; */ void display()&#123; cout&lt;&lt;&quot;(&quot;&lt;&lt;real&lt;&lt;&quot;,&quot;&lt;&lt;imag&lt;&lt;&quot;i)&quot;; &#125; double real; double imag; &#125;; 2.二维矩阵Martix_22类，矩阵元素为Complex类型12345678910111213141516#include&lt;iostream&gt;#include&lt;stdlib.h&gt;// 用于退出程序#include &quot;Complex.cpp&quot;using namespace std;class Matrix// 设立一个矩阵类&#123;public: int row,col; Complex *p;// 用来储存矩阵元素 Matrix(); Matrix(int r,int c); Matrix(const Matrix &amp;m); void disp();//展示矩阵 friend Matrix operator + (const Matrix &amp;am,const Matrix &amp;bm);// 加法运算符的重载 Matrix &amp; operator = (const Matrix &amp;a);// “=”运算符的重载&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&quot;Martix_22.h&quot;Matrix::Matrix()&#123; row=1; col=2; p=new Complex();&#125;Matrix::Matrix(int r,int c):row(r),col(c)&#123; int i=r*c; this-&gt;row=r; this-&gt;col=c; p=new Complex(); for(int a=0;a&lt;i;a++) &#123; p[a]=*new Complex(); cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素实部：&quot;&lt;&lt;endl; cin&gt;&gt;p[a].real; cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素虚部：&quot;&lt;&lt;endl; cin&gt;&gt;p[a].imag; &#125;&#125; Matrix::Matrix(const Matrix &amp;m)// 当加法运算符重载函数被调用时，会调用复制构造函数，由于数据成&#123; // 员有指针，因此为了防止析构函数调用时发生错误，设立一个复制构 // 造函数 row=m.row; col=m.col; int len=col*row; p=new Complex[len]; for(int i=0;i&lt;len;i++) &#123; p[i]=m.p[i]; &#125;&#125;void Matrix::disp()&#123; for(int i=0;i&lt;row;i++) &#123; cout&lt;&lt;&#x27;\\t&#x27;; for(int j=0;j&lt;col;j++) p[i*col+j].display(); cout&lt;&lt;endl; &#125;&#125;Matrix operator + (const Matrix &amp;am,const Matrix &amp;bm)&#123; if(am.row==bm.row&amp;&amp;am.col==bm.col) &#123; int i,j; Matrix temp(am); i=am.row*am.col; for(j=0;j&lt;i;j++) &#123; temp.p[j]=am.p[j]+bm.p[j]; &#125; return temp; &#125; else &#123; cout&lt;&lt;&quot;++++program terminated!&quot;&lt;&lt;endl; exit(1); &#125;&#125;Matrix &amp; Matrix::operator = (const Matrix &amp;bm)&#123; if((row==0)&amp;&amp;(col==0)) &#123; if(p) delete p; row=bm.row; col=bm.col; int len=bm.row*bm.col; p=new Complex[len]; for(int i=0;i&lt;len;i++) &#123; p[i]=bm.p[i]; &#125; return *this; &#125; else if((row==bm.row)&amp;&amp;(col==bm.col)) &#123; for(int i=0;i&lt;row*col;i++) &#123; this-&gt;p[i]=bm.p[i]; &#125; return *this; &#125; else if((row!=bm.row)||(col!=bm.col)) &#123; for(int i=0;i&lt;row*col;i++) &#123; this-&gt;p[i]=bm.p[i]; &#125; return *this; &#125;&#125; 3.三维矩阵类，包含二维矩阵的数组1234567891011121314151617#include&lt;iostream&gt;#include&lt;stdlib.h&gt;// 用于退出程序#include &quot;Martix_22.h&quot;using namespace std;class Matrix_33// 设立一个矩阵类&#123;public: Matrix *res; int h,row,col; Matrix_33(); Matrix_33(int r,int c,int h); Matrix_33(const Matrix_33 &amp;m); void disp();//展示矩阵 friend Matrix_33 operator + (const Matrix_33 &amp;am,const Matrix_33 &amp;bm);// 加法运算符的重载 Matrix_33 &amp; operator = (const Matrix_33 &amp;a);// “=”运算符的重载 Matrix &amp; operator [] (int i);// []运算符的重载&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&quot;Martix_33.h&quot;Matrix_33::Matrix_33()&#123; this-&gt;h=2; this-&gt;row=1; this-&gt;col=2; this-&gt;res=new Matrix();&#125;Matrix_33::Matrix_33(int r,int c,int h)&#123; this-&gt;h=h; this-&gt;row=r; this-&gt;col=c; res=new Matrix(); for(int j=0;j&lt;h;j++) &#123;cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;j+1&lt;&lt;&quot;个二维矩阵：&quot;&lt;&lt;endl; res[j].row=r; res[j].col=c; res[j].p=new Complex(); res[j]=*new Matrix(); res[j].row=r; res[j].col=c; res[j]=*new Matrix(r,c); /*res[j].row=r; res[j].col=c; int i=r*c; res[j].p=new Complex(); for(int a=0;a&lt;i;a++) &#123;cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素实部：&quot;&lt;&lt;endl; cin&gt;&gt;res[j].p[a].real; cout&lt;&lt;&quot;请输入第&quot;&lt;&lt;a+1&lt;&lt;&quot;个元素虚部：&quot;&lt;&lt;endl; cin&gt;&gt;res[j].p[a].imag; &#125;*/ res[j].disp(); &#125;&#125;Matrix_33::Matrix_33(const Matrix_33 &amp;m_33)// 当加法运算符重载函数被调用时，会调用复制构造函数，由于数据成&#123; // 员有指针，因此为了防止析构函数调用时发生错误，设立一个复制构造函数 h=m_33.h; row=m_33.row; col=m_33.col; res=m_33.res; if(!res)// 当指针未被赋值时，指针被赋予随机数，或当指针被赋值后，通过此语句指针也可以被删除调 delete res;// 空间,从而去使用新的空间 for(int j=0;j&lt;h;j++) &#123; res[j].row=row; res[j].col=col; res[j].p=new Complex(); res[j]=m_33.res[j]; &#125; &#125;void Matrix_33::disp()&#123; for(int j=0;j&lt;h;j++) &#123; cout&lt;&lt;&quot;该三维矩阵的第&quot;&lt;&lt;j+1&lt;&lt;&quot;个&quot;&lt;&lt;row&lt;&lt;&#x27;*&#x27;&lt;&lt;col&lt;&lt;&quot;阶二维矩阵:&quot; &lt;&lt;endl; for(int i=0;i&lt;row;i++) &#123; for(int c=0;c&lt;col;c++) &#123; cout&lt;&lt;&#x27;\\t&#x27;; res[j].p[i*col+c].display(); &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125; &#125;Matrix_33 operator + (const Matrix_33 &amp;am,const Matrix_33 &amp;bm)&#123; if(am.h==bm.h) &#123; Matrix_33 temp; temp.h=am.h; temp.row=am.row; temp.col=am.col; temp.res=new Matrix(); for(int j=0;j&lt;am.h;j++) &#123; temp.res[j].row=am.res[0].row; temp.res[j].col=am.res[0].col; temp.res[j].p=new Complex(); cout&lt;&lt;&quot;第&quot;&lt;&lt;j&lt;&lt;&quot;个二维矩阵&quot;&lt;&lt;endl; /*temp.res[j].p-&gt;real=am.res[j].p-&gt;real+bm.res[j].p-&gt;real; temp.res[j].p-&gt;imag=am.res[j].p-&gt;imag+bm.res[j].p-&gt;imag;*/ for(int i=0;i&lt;temp.row;i++) &#123; for(int c=0;c&lt;temp.col;c++) &#123; temp.res[j].p[i*temp.col+c]=*new Complex(); temp.res[j].p[i*temp.col+c]=am.res[j].p[i*temp.col+c]+bm.res[j].p[i*temp.col+c]; temp.res[j].p[i*temp.col+c].display(); &#125; cout&lt;&lt;endl; &#125; &#125; return temp; &#125;&#125;Matrix &amp; Matrix_33::operator [] (int i)&#123; return this-&gt;res[i];&#125;Matrix_33 &amp; Matrix_33::operator = (const Matrix_33 &amp;bm)&#123; h=bm.h; row=bm.row; col=bm.col; this-&gt;res=new Matrix(); &#123; for(int j=0;j&lt;h;j++) &#123; this-&gt;res[j].row=bm.res[j].row; this-&gt;res[j].col=bm.res[j].col; this-&gt;res[j].p=new Complex(); for(int i=0;i&lt;row*col;i++) &#123; this-&gt;res[j].p-&gt;real=bm.res[j].p-&gt;real; this-&gt;res[j].p-&gt;imag=bm.res[j].p-&gt;imag; &#125; &#125;&#125;&#125; 4.main函数12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include &quot;Martix_33.h&quot;using namespace std;int main()&#123; int h,row,col; cout&lt;&lt;&quot;请输入三维矩阵的行数和列数和高:&quot;&lt;&lt;endl; cin&gt;&gt;row&gt;&gt;col&gt;&gt;h; cout&lt;&lt;&quot;请输入三维矩阵A:&quot;&lt;&lt;endl; Matrix_33 am(row,col,h); cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; am.disp(); cout&lt;&lt;&quot;请输入三维矩阵B:&quot;&lt;&lt;endl; Matrix_33 bm(row,col,h); cout&lt;&lt;&quot;B:&quot;&lt;&lt;endl; bm.disp(); int i; Matrix_33 cm; cout&lt;&lt;&quot;C=A+B:&quot;&lt;&lt;endl; cm=am+bm; cout&lt;&lt;&quot;请输入i显示B[i]，即第i个二维矩阵:&quot;&lt;&lt;endl; cin&gt;&gt;i; bm[i].disp(); return 0;&#125; 3.实验截图初始化A，B矩阵，可自由设定三维矩阵的行，列，高，以及对应元素的虚部实部重载+，[]，&#x3D;运算符，输出3D矩阵C&#x3D;A+B以及B[i]","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:52:14.030Z","path":"wiki/软件项目/小型项目/C++设计模式实践——线上购物系统/","text":"一、系统的主要目标与功能 &amp;emsp; 在本次设计中，考虑到目前疫情反复不断，为了方便群众，超市都推出在线购物并有配送员送货，于是我设计了一个超市在线网上购物送货的系统，这个系统的主要目标是帮助人们在家里购买自己需要的套餐，充值账户，同时该系统能查看自己的历史金额变动记录，也能够撤销前一次操作，这样能够帮助疫情期间的人们快速购物，也能够减少疫情期间出门购物的可能带来的危害。本超市目前功能如下： 查看超市套餐 购买超市套餐 给账户充值 查看历史余额记录 撤回上次操作 系统自动提示配送员 退出本超市在线购物系 系统运行比较简单，且每一步完成后都会有提示信息，按照提示信息一步一步运行即可。 二 、系统中使用的设计模式（UML类图、详细描述场景、解决的问题、模式的效果及意义） •1.状态模式： &amp;emsp;对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。在一个对象内在状态改变时也改变了其行为，这个对象看起来像改变了其类，因此选择使用状态模式。• &amp;emsp;•设计思路：在本系统中，状态模式在购物时提供用户信息和余额的信息，分别为正常状态GreenState，欠款状态RedState与会员VIP状态。在进入程序时便初始化账户Account，通过这个账户记录余额balance信息，同时考虑到余额不足时不能购物，考虑到特殊情况，设计余额不足购买时允许赊欠，但当前余额小于0时不能购物，这样是考虑到实际，余额小于0时是不能购买的；此外若充值后余额超过1000元，则当前状态变为VIP模式，之后购买商品可以有8折优惠。 &amp;emsp;程序设计：Account中有属性state来聚合AccountState记录当前Account的状态，且有RedState，GreenState，VIP三个子状态继承AccountState，AccountState中有balance余额属性，在每个子状态里面有stateCheck()函数，可以在调用该函数后判断balance的数值，来改变当前Account所处的状态，并在改变状态后改变消费的行为。Accout有函数deposit和withdraw，分别是存款和取款来对balance进行操作，并会根据属性state的不同有不同的行为。 &amp;emsp;Account中有属性msStrategy，这是与策略模式结合的属性，在代码中设计的为若状态为GreenState或RedState，即初试化为MessageStrategy2直接在窗口输出，若为VIP状态，则初试化为MessageStrategy1，产生MessageBox弹窗通知。 •2.建造者模式 &amp;emsp;建筑者模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示。• &amp;emsp;设计思路：在本系统中建造者模式可用于构建不同的套餐1，套餐2，套餐3，由超市Supermarket作为指挥者，将套餐的内部表象与生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象Product，并且使客户便于查看各个套餐的内容与价格便于购买。 &amp;emsp;程序设计：首先Supermarket是系统中建造者模式的Director指导者，拥有Construct()函数，且拥有Builder类的bld属性，使用Construct（）即可调佣bld中的BuildPartA，B，C函数，来构建出Product产品类，从而返回Product完成建造，将Product的复杂构造在ConcreteBuilder内实现，而Supermarket只需要设置不同的bld属性和调用Construct（）函数，即可创建不同的产品，实现产品构建的封装。 •3.观察者模式 &amp;emsp;观察者模式建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。 &amp;emsp;设计思路：在本系统中，观察者模式的观察目标为商家系统Supermarket，具体观察者为配送员DeliveryObserver，多个配送员DeliveryObserver观察对应的商家系统Supermarket，当有客户在商家购买套餐时，商家系统会发出通知提醒观察了自己的配送员。 &amp;emsp;程序设计：在Supermarket中有Attach()和Detach()两个函数与list&lt;DeliveryObserver*&gt;accs即 DeliveryObserver的一个列表，Attach()来增加配送员Observer为观察者，Detach()删除观察者Observer，然后在消费者进行购物后，通过调用notify（）函数来进行通知，且Observer中具体的notify（）函数与策略模式相结合，对于list中的单数采用MessageStrategy1通知，list采用MessageStrategy2来通知。 •4.单例模式 &amp;emsp;单例类只有一个实例对象，且该单例对象必须由单例类自行创建，单例类对外提供一个访问该单例的全局访问点。• &amp;emsp;设计思路：在本系统中，单例类为商家类，只允许创建一个商家类，且该商家类是建造者模式的指挥者，指挥套餐的建立。 &amp;emsp;程序设计：在Supermarket里面，有私有静态的Supermarket类属性_instance，然后将构造函数定义为保护函数防止外界调用，在调用构造函数时判断_instance是否为空，若为空则可初始化，否则返回_instance。 •5.策略模式 &amp;emsp;该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式的主要目的是将算法的定义与使用分开，将算法的定义放在专门的策略类中，每一个策略类封装了一种实现算法，在出现新的算法时，只需要增加一个新的实现了抽象策略类的具体策略类即可。 &amp;emsp;设计思路：本系统中，策略模式在观察者模式的基础上使用，在观察者模式通知Observer时，通知方式可选择不同的策略，如短信通知或软件信息通知等，在本系统中选择弹窗通知MessageStrategy1与直接输出通知MessageStrategy2来模拟这两种不同的通知方式。 &amp;emsp;此外，策略模式与状态模式也有在一起联合使用，若Account目前状态为GreenState或RedState，即初试化为MessageStrategy2直接在命令行窗口输出，若为VIP状态，则初试化为MessageStrategy1，产生MessageBox弹窗通知。 &amp;emsp;程序设计：MessageStrategy有两个子类，分别为MessageStrategy1与MessageStrategy2，MessageStrategy1即采用MessageBox进行弹窗输出，而MessageStrategy2即为cout直接输出，使用时可具体不同的策略类来实现不同的通知方式 •6.备忘录模式 &amp;emsp;在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态。 &amp;emsp;设计思路：在本系统中，备忘录模式记录在系统中的余额变动，并可查看所有的历史变动记录，并可以撤销上一次余额变动的操作，在现实中大部分购物应用都可以查看历史记录与撤销，因此利用备忘录模式实现该操作，便于观察余额变化。 &amp;emsp;程序设计：首先通过UserInfoDTO来在主函数中将每次余额改变时的balance即state记入Memento，然后利用Caretaker中的mementoList来记录每次余额改变后的Memento值。在查看历史记录时，即调用UserInfoDTO的getStateFromMemento()函数来遍历mementoList所有记录的历史余额；在想要进行撤销操作时，即首先调用user.getStateFromMemento（）获取最近一次操作后的余额值，之后调用p-&gt;setbalance(user.getState())将余额记录到Account账户中，且对于第一次操作与第0次操作有不同的撤销行为。 三、系统运行截图 &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; &amp;emsp; 四、设计模式总结 &amp;emsp; 本次实践作业我使用了一些比较常见的设计模式，包括状态模式，单例模式，建造者模式，观察者模式，策略模式，备忘录模式。我个人认为在设计模式的使用有两个亮点。 &amp;ensp;第一个亮点就是策略模式与观察者模式与状态模式联合使用，而不是将策略模式进行单一的使用。这个想法是我在进行观察者模式设计时，发现观察者模式的通知功能可以有不同的策略实现后做出的模式设计。我将策略模式与观察者模式与状态模式联合使用，对于不同的观察者，不同的状态时会有不同的行为，因此我将策略模式融合到这两种模式中，这也是对于设计模式的一种深入使用，而不仅仅是生硬的套用。在本次实践中，。 &amp;ensp; 第二个亮点是备忘录模式的使用，我个人认为备忘录模式的理解和代码设计都有一定的难度，在实践过程中也确实遇到了一些困难如Caretaker和Memento的区别，以及如何存和取历史数据，但经过认真学习进行了解决。 &amp;ensp; 通过使用这些设计模式，代码对修改有了封闭性，在客户端没有具体实现，难以修改，而在进行扩展时更加容易，如对于策略模式，如果想要添加一个新的策略实现不同的通知方式，只需要增加一个策略实现的子类MessageStrategy3即可实现策略添加。 五、个人的模式学习心得 &amp;emsp;在本次面向对象与系统建模的课程学习中，我个人认为收获良多，与本科学习过的设计模式相比学到了更多与更加深入，首先是因为研一与本科学习时相比自己做过的项目与见过的代码更多，更加理解了为什么要运用设计模式来进行代码封装与复用，如何使用设计模式来更好的扩展代码，为什么设计代码时要满足开闭原则等多项原则。（而不像是本科学习时觉得进行这些设计模式的使用没有用处，反而让人看不懂代码具体逻辑）。&amp;emsp;此外，也正是提前了解到了设计模式的重要性，我学习的兴趣也更加浓厚，因此我除了在上课时的学习，还购买了《大话设计模式》进行课外学习，同时参加了软件设计师的考试，于是我对设计模式的复用性有了更深入的了解，对于重要的模式如观察者模式、状态模式、工厂模式，适配器模式等理论方面有了更加深入的理解，对于每种设计模式的UML类图也更加理解，对于该在哪种应用场景来使用某种设计模式、如何用代码实现这些模式也更加明确，对一些不太常见的模式如原型模式，访问者模式也了解更多，更加理解了设计模式对于修改封闭，扩展开放的好处，对于迪米特法则、单一职责原则等更加理解。 六、意见和建议 &amp;emsp;个人认为对于设计模式的学习不能追求通过上课来速成，要在自己进行代码编写的过程中以及后续代码修改过程中才能深入理解设计模式的重要性。&amp;emsp;因此对于学习过程中建议可以不用课本，直接用能够运行的使用了2-3个设计模式的简单项目，并编写2个不同的代码，一个没有使用设计模式的代码，一个使用了设计模式代码，首先演示让同学们了解代码的作用，然后平时作业可以让同学们分别对两种代码进行扩展，如对于状态模式，可以让学生对两种代码都加一种状态，这样可能比对着书本更容易理解设计模式的作用，而在期末作业上也可以要求同学们对于上课时的简单项目进行扩展，如多加几个设计模式。 七、main函数与抽象类代码 &amp;emsp;Main函数：可以看到在Main函数与抽象类中没有看到具体的实现代码，仅仅只有函数的调用，因此基本满足开闭原则，扩展性良好，想要扩展时仅仅只需要增加子类。 .","tags":[],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"}]},{"title":"","date":"2023-02-15T01:51:36.795Z","path":"wiki/计算机基础知识/编程语言/GoLang/Golang版LeetCode基本算法函数/","text":"二维数组 1234567 matrix := make([][]int, m) for i := range matrix &#123; matrix[i] = make([]int, n) &#125; ans := make([][]int,0)//动态二维数组，初始化或清除所以元素ans =append(ans,[]int )//添加元素 2.排序 1234567891011121314151617count:=[2002]int&#123;&#125;arrColne := append([]int&#123;&#125;, arr...)//克隆一个新数组sort.Ints（count[:]）//[2002]int 与[]int 不是一种类型，要先变成切片后再排序//go语言没有返回数组最小的min函数，需要自己定义sort.Ints(arr) //从小到大sort.Sort(sort.Reverse(sort.IntSlice(arr))) //从大到小sort.Slice(nums, func(i, j int) bool &#123;return nums[i] &gt; nums[j]&#125;)//自定义排序从大到小sort.Slice(index, func(i, j int) bool &#123; a, b := array[index[i]], array[index[j]] return a &lt; b || (a == b &amp;&amp; index[i] &lt; index[j])&#125;)/* array[i] = count index[i] = i 自定义排序，实现index下标根据arr的值排序*/ 3.字符串 12345678910strings.ContainsAny（str1.str2）//判断str1中是否存在str2strings.Count(str1, str2)//判断字符串str2在字符串str1中的个数string(&#x27;a&#x27;)//int，字符转字符串strconv.Atoi() (int, error)//字符串转intstrconv.Itoa()//int转字符串,如需要int每一位值时可使用Itoa+Atoibytes:=byte[] str:=string(a)//byte数组转stringstr[i]//下标遍历只读，不能修改strBytes := []byte(str)//修改string，需要将 string 转为 []byte 修改后unicode.IsDigit(c)//判断是否是字符串 4.遍历 123for v:=range arr//v为下标for _,v:=range arr//v为数值，注意用for each时，若只需要arr[i]，一定要在前面加上_，不然返回的是inext：for &#123;&#125;continue next//在遍历时如果要退出可使用continue退出多重循环 5.位运算 1x&amp;=x-1//求x二进制中1的个数 6.数组插入 12copy(res[i+1:], res[i:]) res[i] = num //将数组下标i后面的copy到下标i+1，然后插入到下标i处","tags":[],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"GoLang","slug":"计算机基础知识/编程语言/GoLang","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GoLang/"}]},{"title":"Hello World","date":"2023-02-14T01:15:19.740Z","path":"wiki/index/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]}],"categories":[{"name":"软件项目","slug":"软件项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/"},{"name":"小型项目","slug":"软件项目/小型项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E5%9E%8B%E9%A1%B9%E7%9B%AE/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"计算机基础知识/数据库","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法笔记","slug":"计算机基础知识/算法笔记","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"操作系统","slug":"计算机基础知识/操作系统","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"算法笔记","slug":"算法笔记","permalink":"https://pistachiout.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"},{"name":"Android项目","slug":"软件项目/Android项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Android%E9%A1%B9%E7%9B%AE/"},{"name":"编程语言","slug":"计算机基础知识/编程语言","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"计算机基础知识/编程语言/Java","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"},{"name":"JavaWeb项目","slug":"软件项目/JavaWeb项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/JavaWeb%E9%A1%B9%E7%9B%AE/"},{"name":"Linux项目","slug":"软件项目/Linux项目","permalink":"https://pistachiout.github.io/categories/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/Linux%E9%A1%B9%E7%9B%AE/"},{"name":"实用工具","slug":"实用工具","permalink":"https://pistachiout.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"},{"name":"论文研究","slug":"论文研究","permalink":"https://pistachiout.github.io/categories/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"},{"name":"python","slug":"计算机基础知识/编程语言/python","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/"},{"name":"GoLang","slug":"计算机基础知识/编程语言/GoLang","permalink":"https://pistachiout.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/GoLang/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://pistachiout.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://pistachiout.github.io/tags/Java/"}]}